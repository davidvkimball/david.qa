/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/style-settings.ts
var style_settings_exports = {};
__export(style_settings_exports, {
  applyCustomColors: () => applyCustomColors,
  getCardSpacing: () => getCardSpacing,
  getEmptyValueMarker: () => getEmptyValueMarker,
  getListSeparator: () => getListSeparator,
  getMinGridColumns: () => getMinGridColumns,
  getMinMasonryColumns: () => getMinMasonryColumns,
  getTagStyle: () => getTagStyle,
  getZoomSensitivity: () => getZoomSensitivity,
  hasCardBackground: () => hasCardBackground,
  shouldHideEmptyProperties: () => shouldHideEmptyProperties,
  shouldHideMissingProperties: () => shouldHideMissingProperties,
  shouldShowOlderDateOnly: () => shouldShowOlderDateOnly,
  shouldShowRecentTimeOnly: () => shouldShowRecentTimeOnly,
  showTagHashPrefix: () => showTagHashPrefix,
  showTimestampIcon: () => showTimestampIcon
});
function getCSSVariable(name, defaultValue) {
  const value = getComputedStyle(document.body).getPropertyValue(name).trim();
  return value || defaultValue;
}
function getCSSVariableAsNumber(name, defaultValue) {
  const value = getCSSVariable(name, "");
  if (!value)
    return defaultValue;
  const parsed = parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}
function hasBodyClass(className) {
  return document.body.classList.contains(className);
}
function getMinMasonryColumns() {
  return getCSSVariableAsNumber("--dynamic-views-min-masonry-columns", 2);
}
function getMinGridColumns() {
  return getCSSVariableAsNumber("--dynamic-views-min-grid-columns", 1);
}
function hasCardBackground() {
  return hasBodyClass("dynamic-views-card-background");
}
function showTimestampIcon() {
  return !hasBodyClass("dynamic-views-timestamp-icon-hide");
}
function getTagStyle() {
  if (hasBodyClass("dynamic-views-tag-style-minimal"))
    return "minimal";
  if (hasBodyClass("dynamic-views-tag-style-theme"))
    return "theme";
  return "plain";
}
function showTagHashPrefix() {
  return hasBodyClass("dynamic-views-show-tag-hash");
}
function getCardSpacing() {
  return getCSSVariableAsNumber("--dynamic-views-card-spacing", 12);
}
function shouldShowRecentTimeOnly() {
  return hasBodyClass("dynamic-views-timestamp-recent-time-only");
}
function shouldShowOlderDateOnly() {
  return hasBodyClass("dynamic-views-timestamp-older-date-only");
}
function getListSeparator() {
  let value = getComputedStyle(document.body).getPropertyValue(
    "--dynamic-views-list-separator"
  );
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    value = value.slice(1, -1);
  }
  return value || ", ";
}
function getEmptyValueMarker() {
  let value = getComputedStyle(document.body).getPropertyValue(
    "--dynamic-views-empty-value-marker"
  );
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    value = value.slice(1, -1);
  }
  return value || "\u2014";
}
function shouldHideMissingProperties() {
  return hasBodyClass("dynamic-views-hide-missing-properties");
}
function shouldHideEmptyProperties() {
  return hasBodyClass("dynamic-views-hide-empty-properties");
}
function getZoomSensitivity() {
  return getCSSVariableAsNumber("--dynamic-views-zoom-sensitivity", 0.15);
}
function applyCustomColors(cardEl, theme, cache) {
  var _a, _b, _c, _d, _e;
  if ((_a = cache.titleColor) == null ? void 0 : _a[theme]) {
    cardEl.style.setProperty(
      "--dynamic-views-title-color",
      cache.titleColor[theme]
    );
  }
  if ((_b = cache.snippetColor) == null ? void 0 : _b[theme]) {
    cardEl.style.setProperty(
      "--dynamic-views-snippet-color",
      cache.snippetColor[theme]
    );
  }
  if ((_c = cache.tagsColor) == null ? void 0 : _c[theme]) {
    cardEl.style.setProperty(
      "--dynamic-views-tags-color",
      cache.tagsColor[theme]
    );
  }
  if ((_d = cache.timestampColor) == null ? void 0 : _d[theme]) {
    cardEl.style.setProperty(
      "--dynamic-views-timestamp-color",
      cache.timestampColor[theme]
    );
  }
  if ((_e = cache.metadataColor) == null ? void 0 : _e[theme]) {
    cardEl.style.setProperty(
      "--dynamic-views-metadata-color",
      cache.metadataColor[theme]
    );
  }
}
var init_style_settings = __esm({
  "src/utils/style-settings.ts"() {
  }
});

// src/utils/property.ts
var property_exports = {};
__export(property_exports, {
  getAllBasesImagePropertyValues: () => getAllBasesImagePropertyValues,
  getAllDatacoreImagePropertyValues: () => getAllDatacoreImagePropertyValues,
  getAllVaultProperties: () => getAllVaultProperties,
  getFirstBasesDatePropertyValue: () => getFirstBasesDatePropertyValue,
  getFirstBasesPropertyValue: () => getFirstBasesPropertyValue,
  getFirstDatacoreDatePropertyValue: () => getFirstDatacoreDatePropertyValue,
  getFirstDatacorePropertyValue: () => getFirstDatacorePropertyValue,
  getPropertyLabel: () => getPropertyLabel,
  isValidUri: () => isValidUri
});
function getFirstBasesPropertyValue(app, entry, propertyString) {
  if (!propertyString || !propertyString.trim())
    return null;
  const properties = propertyString.split(",").map((p) => p.trim()).filter((p) => p);
  for (const prop of properties) {
    let value = entry.getValue(prop);
    if (value && typeof value === "object" && "icon" in value && !("data" in value)) {
      value = entry.getValue(`formula.${prop}`);
    }
    if (value && typeof value === "object" && "data" in value) {
      return value;
    }
  }
  return null;
}
function getFirstDatacorePropertyValue(page, propertyString) {
  if (!propertyString || !propertyString.trim())
    return null;
  const properties = propertyString.split(",").map((p) => p.trim()).filter((p) => p);
  for (const prop of properties) {
    const value = page.value(prop);
    if (value !== null && value !== void 0) {
      return value;
    }
  }
  return null;
}
function getFirstBasesDatePropertyValue(app, entry, propertyString) {
  if (!propertyString || !propertyString.trim())
    return null;
  const properties = propertyString.split(",").map((p) => p.trim()).filter((p) => p);
  for (const prop of properties) {
    let value = entry.getValue(prop);
    if (value && typeof value === "object" && "icon" in value && !("data" in value) && !("date" in value)) {
      value = entry.getValue(`formula.${prop}`);
    }
    if (value && typeof value === "object" && "date" in value && value.date instanceof Date) {
      return value;
    }
  }
  return null;
}
function getFirstDatacoreDatePropertyValue(page, propertyString) {
  if (!propertyString || !propertyString.trim())
    return null;
  const properties = propertyString.split(",").map((p) => p.trim()).filter((p) => p);
  for (const prop of properties) {
    const value = page.value(prop);
    if (value && typeof value === "object" && "toMillis" in value) {
      return value;
    }
  }
  return null;
}
function getAllBasesImagePropertyValues(app, entry, propertyString) {
  if (!propertyString || !propertyString.trim())
    return [];
  const properties = propertyString.split(",").map((p) => p.trim()).filter((p) => p);
  const allImages = [];
  for (const prop of properties) {
    let value = entry.getValue(prop);
    if (value && typeof value === "object" && "icon" in value && !("data" in value)) {
      value = entry.getValue(`formula.${prop}`);
    }
    if (!value || !(typeof value === "object" && "data" in value))
      continue;
    const data = value.data;
    if (data == null || data === "")
      continue;
    if (Array.isArray(data)) {
      for (const item of data) {
        if (typeof item === "string" || typeof item === "number") {
          const str = String(item);
          if (str.trim())
            allImages.push(str);
        }
      }
    } else if (typeof data === "string" || typeof data === "number") {
      const str = String(data);
      if (str.trim())
        allImages.push(str);
    }
  }
  return allImages;
}
function getAllDatacoreImagePropertyValues(page, propertyString) {
  if (!propertyString || !propertyString.trim())
    return [];
  const properties = propertyString.split(",").map((p) => p.trim()).filter((p) => p);
  const allImages = [];
  for (const prop of properties) {
    const value = page.value(prop);
    if (value === null || value === void 0)
      continue;
    if (Array.isArray(value)) {
      for (const item of value) {
        if (typeof item === "object" && item !== null && "path" in item) {
          const pathValue = item.path;
          if (typeof pathValue === "string" || typeof pathValue === "number") {
            const str = String(pathValue).trim();
            if (str)
              allImages.push(str);
          }
        } else if (typeof item === "string" || typeof item === "number") {
          const str = String(item).trim();
          if (str)
            allImages.push(str);
        }
      }
    } else {
      if (typeof value === "object" && value !== null && "path" in value) {
        const pathValue = value.path;
        if (typeof pathValue === "string" || typeof pathValue === "number") {
          const str = String(pathValue).trim();
          if (str)
            allImages.push(str);
        }
      } else if (typeof value === "string" || typeof value === "number") {
        const str = String(value).trim();
        if (str)
          allImages.push(str);
      }
    }
  }
  return allImages;
}
function getPropertyLabel(propertyName) {
  if (!propertyName || propertyName === "")
    return "";
  const mappedLabel = PROPERTY_LABEL_MAP[propertyName.toLowerCase()];
  if (mappedLabel)
    return mappedLabel;
  if (propertyName.startsWith("note.")) {
    return propertyName.slice(5);
  }
  return propertyName;
}
function getAllVaultProperties(app) {
  const properties = /* @__PURE__ */ new Set();
  properties.add("file.path");
  properties.add("file.tags");
  properties.add("file.mtime");
  properties.add("file.ctime");
  properties.add("file path");
  properties.add("file tags");
  properties.add("created time");
  properties.add("modified time");
  const metadataCache = app.metadataCache;
  if (typeof metadataCache.getAllPropertyInfos === "function") {
    const allPropertyInfos = metadataCache.getAllPropertyInfos();
    if (allPropertyInfos) {
      for (const [propertyName] of Object.entries(allPropertyInfos)) {
        properties.add(propertyName);
      }
    }
  }
  return Array.from(properties).sort((a, b) => {
    const aBasesFormat = a.startsWith("file.");
    const bBasesFormat = b.startsWith("file.");
    const aHumanFormat = (a.startsWith("file ") || a.includes(" time")) && !aBasesFormat;
    const bHumanFormat = (b.startsWith("file ") || b.includes(" time")) && !bBasesFormat;
    if (aBasesFormat && !bBasesFormat)
      return -1;
    if (!aBasesFormat && bBasesFormat)
      return 1;
    if (aHumanFormat && !bHumanFormat)
      return -1;
    if (!aHumanFormat && bHumanFormat)
      return 1;
    return a.localeCompare(b);
  });
}
function isValidUri(value) {
  if (!value || typeof value !== "string")
    return false;
  const trimmed = value.trim();
  if (trimmed.length < 5 || trimmed.length > 2048)
    return false;
  if (!trimmed.includes("://"))
    return false;
  const uriPattern = /^[a-zA-Z][a-zA-Z0-9+.-]*:\/\/.+$/;
  return uriPattern.test(trimmed);
}
var PROPERTY_LABEL_MAP;
var init_property = __esm({
  "src/utils/property.ts"() {
    PROPERTY_LABEL_MAP = {
      "file.file": "file",
      file: "file",
      "file.name": "file name",
      "file name": "file name",
      "file.basename": "file base name",
      "file base name": "file base name",
      "file.ext": "file extension",
      "file.extension": "file extension",
      "file extension": "file extension",
      "file.backlinks": "file backlinks",
      "file backlinks": "file backlinks",
      "file.ctime": "created time",
      "created time": "created time",
      "file.embeds": "file embeds",
      "file embeds": "file embeds",
      "file.fullname": "file full name",
      "file full name": "file full name",
      "file.links": "file links",
      "file links": "file links",
      "file.path": "file path",
      path: "file path",
      "file path": "file path",
      "file.size": "file size",
      "file size": "file size",
      "file.tags": "file tags",
      "file tags": "file tags",
      tags: "tags",
      "note.tags": "tags",
      "file.mtime": "modified time",
      "modified time": "modified time",
      "file.folder": "folder",
      folder: "folder"
    };
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h3, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h3, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h3, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h3 = (hm - m) / 100;
          return h3 * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DynamicViewsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");

// src/constants.ts
var DEFAULT_VIEW_SETTINGS = {
  titleProperty: "",
  descriptionProperty: "",
  imageProperty: "",
  urlProperty: "",
  propertyDisplay1: "file.tags",
  propertyDisplay2: "",
  propertyDisplay3: "file.path",
  propertyDisplay4: "file.mtime",
  propertyDisplay5: "",
  propertyDisplay6: "",
  propertyDisplay7: "",
  propertyDisplay8: "",
  propertyDisplay9: "",
  propertyDisplay10: "",
  propertyDisplay11: "",
  propertyDisplay12: "",
  propertyDisplay13: "",
  propertyDisplay14: "",
  propertyLayout12SideBySide: false,
  propertyLayout34SideBySide: true,
  propertyLayout56SideBySide: false,
  propertyLayout78SideBySide: false,
  propertyLayout910SideBySide: false,
  propertyLayout1112SideBySide: false,
  propertyLayout1314SideBySide: false,
  propertyGroup1Position: "bottom",
  propertyGroup2Position: "bottom",
  propertyGroup3Position: "bottom",
  propertyGroup4Position: "bottom",
  propertyGroup5Position: "bottom",
  propertyGroup6Position: "bottom",
  propertyGroup7Position: "bottom",
  propertyLabels: "hide",
  showTitle: true,
  subtitleProperty: "",
  showTextPreview: true,
  fallbackToContent: true,
  fallbackToEmbeds: "always",
  imageFormat: "thumbnail-right",
  coverFitMode: "crop",
  imageAspectRatio: 1,
  queryHeight: 0,
  listMarker: "bullet",
  cardSize: 400
};
var DEFAULT_SETTINGS = {
  titleProperty: "",
  descriptionProperty: "",
  imageProperty: "",
  urlProperty: "",
  omitFirstLine: false,
  showTitle: true,
  subtitleProperty: "",
  showTextPreview: true,
  fallbackToContent: true,
  fallbackToEmbeds: "always",
  propertyDisplay1: "file.tags",
  propertyDisplay2: "",
  propertyDisplay3: "file.path",
  propertyDisplay4: "file.mtime",
  propertyDisplay5: "",
  propertyDisplay6: "",
  propertyDisplay7: "",
  propertyDisplay8: "",
  propertyDisplay9: "",
  propertyDisplay10: "",
  propertyDisplay11: "",
  propertyDisplay12: "",
  propertyDisplay13: "",
  propertyDisplay14: "",
  propertyLayout12SideBySide: false,
  propertyLayout34SideBySide: true,
  propertyLayout56SideBySide: false,
  propertyLayout78SideBySide: false,
  propertyLayout910SideBySide: false,
  propertyLayout1112SideBySide: false,
  propertyLayout1314SideBySide: false,
  propertyGroup1Position: "bottom",
  propertyGroup2Position: "bottom",
  propertyGroup3Position: "bottom",
  propertyGroup4Position: "bottom",
  propertyGroup5Position: "bottom",
  propertyGroup6Position: "bottom",
  propertyGroup7Position: "bottom",
  propertyLabels: "hide",
  imageFormat: "thumbnail-right",
  coverFitMode: "crop",
  imageAspectRatio: 1,
  timestampFormat: "",
  listMarker: "bullet",
  randomizeAction: "shuffle",
  thumbnailCacheSize: "balanced",
  queryHeight: 0,
  openFileAction: "card",
  openRandomInNewPane: true,
  showShuffleInRibbon: true,
  showRandomInRibbon: true,
  smartTimestamp: true,
  createdTimeProperty: "",
  modifiedTimeProperty: "",
  fallbackToFileMetadata: true,
  cardSize: 400
};
var DEFAULT_UI_STATE = {
  sortMethod: "mtime-desc",
  viewMode: "card",
  searchQuery: "",
  resultLimit: "",
  widthMode: "normal"
};

// src/utils/sanitize.ts
function sanitizeString(value) {
  if (typeof value !== "string")
    return value;
  return value.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, "");
}
function sanitizeObject(obj) {
  const sanitized = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string") {
      sanitized[key] = sanitizeString(value);
    } else {
      sanitized[key] = value;
    }
  }
  return sanitized;
}

// src/persistence.ts
var PersistenceManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.data = {
      globalSettings: { ...DEFAULT_SETTINGS },
      defaultViewSettings: { ...DEFAULT_VIEW_SETTINGS },
      queryStates: {},
      viewSettings: {}
    };
  }
  async load() {
    const loadedData = await this.plugin.loadData();
    if (loadedData) {
      this.data = {
        globalSettings: {
          ...DEFAULT_SETTINGS,
          ...loadedData.globalSettings || {}
        },
        defaultViewSettings: {
          ...DEFAULT_VIEW_SETTINGS,
          ...loadedData.defaultViewSettings || {}
        },
        queryStates: loadedData.queryStates || {},
        viewSettings: loadedData.viewSettings || {}
      };
    }
  }
  async save() {
    await this.plugin.saveData(this.data);
  }
  getGlobalSettings() {
    return { ...this.data.globalSettings };
  }
  async setGlobalSettings(settings) {
    const sanitized = sanitizeObject(settings);
    this.data.globalSettings = { ...this.data.globalSettings, ...sanitized };
    await this.save();
  }
  getDefaultViewSettings() {
    return { ...this.data.defaultViewSettings };
  }
  async setDefaultViewSettings(settings) {
    const sanitized = sanitizeObject(settings);
    this.data.defaultViewSettings = {
      ...this.data.defaultViewSettings,
      ...sanitized
    };
    await this.save();
  }
  getUIState(ctime) {
    const state = this.data.queryStates[ctime.toString()];
    return state ? { ...state } : { ...DEFAULT_UI_STATE };
  }
  async setUIState(ctime, state) {
    const key = ctime.toString();
    const current = this.data.queryStates[key] || { ...DEFAULT_UI_STATE };
    const sanitized = {};
    for (const [k, v] of Object.entries(state)) {
      const key2 = k;
      if (k === "searchQuery" && typeof v === "string") {
        sanitized[key2] = sanitizeString(
          v.slice(0, 500)
        );
      } else if (typeof v === "string") {
        sanitized[key2] = sanitizeString(v);
      } else {
        sanitized[key2] = v;
      }
    }
    this.data.queryStates[key] = { ...current, ...sanitized };
    await this.save();
  }
  async clearUIState(ctime) {
    delete this.data.queryStates[ctime.toString()];
    await this.save();
  }
  getViewSettings(ctime) {
    const settings = this.data.viewSettings[ctime.toString()];
    return settings ? { ...settings } : {};
  }
  async setViewSettings(ctime, settings) {
    const key = ctime.toString();
    const current = this.data.viewSettings[key] || {};
    const sanitized = sanitizeObject(settings);
    this.data.viewSettings[key] = { ...current, ...sanitized };
    await this.save();
  }
  async clearViewSettings(ctime) {
    delete this.data.viewSettings[ctime.toString()];
    await this.save();
  }
};

// src/components/view.tsx
var import_obsidian6 = require("obsidian");

// src/shared/card-renderer.tsx
var import_obsidian3 = require("obsidian");
init_style_settings();
init_property();

// src/utils/link-parser.ts
function isWebUrl(url) {
  return /^https?:\/\//i.test(url);
}
function hasUriScheme(url) {
  return /^[a-z][a-z0-9+.-]*:\/\//i.test(url);
}
function normalizePath(path) {
  if (path.startsWith("<") && path.endsWith(">")) {
    path = path.slice(1, -1);
  }
  try {
    return decodeURIComponent(path);
  } catch (e) {
    return path;
  }
}
function stripTrailingPunctuation(url) {
  const match = url.match(/^(.+?)([.,;:!?]+)$/);
  if (match) {
    return [match[1], match[2]];
  }
  return [url, ""];
}
function findLinksInText(text) {
  const segments = [];
  const linkPattern = /!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]|\[\[([^\]|]+)(?:\|([^\]]+))?\]\]|!\[([^\]]*)\]\((?:<([^>]+)>|([^)]+))\)|\[([^\]]+)\]\((?:<([^>]+)>|([^)]+))\)|<([a-z][a-z0-9+.-]*:\/\/[^>]+)>|([a-z][a-z0-9+.-]*:\/\/[^\s<>[\]()]+)/gi;
  let lastIndex = 0;
  let match;
  while ((match = linkPattern.exec(text)) !== null) {
    if (match.index > lastIndex) {
      segments.push({
        type: "text",
        content: text.slice(lastIndex, match.index)
      });
    }
    const rawMatch = match[0];
    let parsed = null;
    let actualRaw = rawMatch;
    if (match[1] !== void 0) {
      parsed = {
        type: "internal",
        url: match[1],
        caption: match[2] || match[1],
        isEmbed: true,
        isWebUrl: false
      };
    } else if (match[3] !== void 0) {
      parsed = {
        type: "internal",
        url: match[3],
        caption: match[4] || match[3],
        isEmbed: false,
        isWebUrl: false
      };
    } else if (match[5] !== void 0 || match[6] !== void 0 || match[7] !== void 0) {
      const caption = match[5] || "";
      const path = normalizePath(match[6] || match[7]);
      const external = hasUriScheme(path);
      parsed = {
        type: external ? "external" : "internal",
        url: path,
        caption: caption || path,
        isEmbed: true,
        isWebUrl: isWebUrl(path)
      };
    } else if (match[8] !== void 0) {
      const caption = match[8];
      const path = normalizePath(match[9] || match[10]);
      const external = hasUriScheme(path);
      parsed = {
        type: external ? "external" : "internal",
        url: path,
        caption,
        isEmbed: false,
        isWebUrl: isWebUrl(path)
      };
    } else if (match[11] !== void 0) {
      const url = match[11];
      parsed = {
        type: "external",
        url,
        caption: url,
        isEmbed: false,
        isWebUrl: isWebUrl(url)
      };
    } else if (match[12] !== void 0) {
      const [cleanUrl, trailing] = stripTrailingPunctuation(match[12]);
      parsed = {
        type: "external",
        url: cleanUrl,
        caption: cleanUrl,
        isEmbed: false,
        isWebUrl: isWebUrl(cleanUrl)
      };
      actualRaw = cleanUrl;
      if (trailing) {
        segments.push({ type: "link", link: parsed, raw: actualRaw });
        segments.push({ type: "text", content: trailing });
        lastIndex = match.index + rawMatch.length;
        continue;
      }
    }
    if (parsed) {
      segments.push({ type: "link", link: parsed, raw: actualRaw });
    } else {
      segments.push({ type: "text", content: rawMatch });
    }
    lastIndex = match.index + rawMatch.length;
  }
  if (lastIndex < text.length) {
    segments.push({ type: "text", content: text.slice(lastIndex) });
  }
  if (segments.length === 0) {
    segments.push({ type: "text", content: text });
  }
  return segments;
}

// src/utils/image-color.ts
function extractAverageColor(img) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    return "rgb(128, 128, 128)";
  }
  const targetSize = 50;
  canvas.width = targetSize;
  canvas.height = targetSize;
  ctx.drawImage(img, 0, 0, targetSize, targetSize);
  const imageData = ctx.getImageData(0, 0, targetSize, targetSize);
  const data = imageData.data;
  let r = 0, g = 0, b = 0;
  const pixelCount = targetSize * targetSize;
  for (let i = 0; i < data.length; i += 4) {
    r += data[i];
    g += data[i + 1];
    b += data[i + 2];
  }
  r = Math.floor(r / pixelCount);
  g = Math.floor(g / pixelCount);
  b = Math.floor(b / pixelCount);
  return `rgb(${r}, ${g}, ${b})`;
}
function calculateLuminance(rgbString) {
  const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (!match)
    return 0.5;
  const r = parseInt(match[1]) / 255;
  const g = parseInt(match[2]) / 255;
  const b = parseInt(match[3]) / 255;
  const gammaCorrect = (val) => val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  const rLinear = gammaCorrect(r);
  const gLinear = gammaCorrect(g);
  const bLinear = gammaCorrect(b);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function getColorTheme(rgbString) {
  return calculateLuminance(rgbString) > 0.5 ? "light" : "dark";
}

// src/shared/constants.ts
var BATCH_SIZE = 50;
var SCROLL_TOLERANCE = 1;
var IMAGE_ASPECT_RATIO = 0.55;

// src/shared/image-loader.ts
function handleImageLoad(imgEl, imageEmbedContainer, cardEl, onLayoutUpdate) {
  const ambientColor = extractAverageColor(imgEl);
  imageEmbedContainer.style.setProperty("--ambient-color", ambientColor);
  cardEl.style.setProperty("--ambient-color", ambientColor);
  const colorTheme = getColorTheme(ambientColor);
  cardEl.setAttribute("data-ambient-theme", colorTheme);
  if (imgEl.naturalWidth > 0 && imgEl.naturalHeight > 0) {
    const imgAspect = imgEl.naturalHeight / imgEl.naturalWidth;
    const containerMaxAspect = parseFloat(
      getComputedStyle(document.body).getPropertyValue(
        "--dynamic-views-image-aspect-ratio"
      ) || String(IMAGE_ASPECT_RATIO)
    );
    if (imgAspect < containerMaxAspect) {
      cardEl.style.setProperty("--actual-aspect-ratio", imgAspect.toString());
    }
  }
  if (onLayoutUpdate) {
    onLayoutUpdate();
  }
}
function setupImageLoadHandler(imgEl, imageEmbedContainer, cardEl, onLayoutUpdate) {
  imgEl.addEventListener("load", () => {
    handleImageLoad(imgEl, imageEmbedContainer, cardEl, onLayoutUpdate);
  });
}

// src/shared/image-zoom-handler.ts
var import_obsidian2 = require("obsidian");

// node_modules/@panzoom/panzoom/dist/panzoom.es.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
if (typeof window !== "undefined") {
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }
  if (typeof window.CustomEvent !== "function") {
    window.CustomEvent = function CustomEvent2(event, params) {
      params = params || { bubbles: false, cancelable: false, detail: null };
      var evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };
  }
}
var isIE = typeof document !== "undefined" && !!document.documentMode;
var divStyle;
function createStyle() {
  if (divStyle) {
    return divStyle;
  }
  return divStyle = document.createElement("div").style;
}
var prefixes = ["webkit", "moz", "ms"];
var prefixCache = {};
function getPrefixedName(name) {
  if (prefixCache[name]) {
    return prefixCache[name];
  }
  var divStyle2 = createStyle();
  if (name in divStyle2) {
    return prefixCache[name] = name;
  }
  var capName = name[0].toUpperCase() + name.slice(1);
  var i = prefixes.length;
  while (i--) {
    var prefixedName = "".concat(prefixes[i]).concat(capName);
    if (prefixedName in divStyle2) {
      return prefixCache[name] = prefixedName;
    }
  }
}
function getCSSNum(name, style) {
  return parseFloat(style[getPrefixedName(name)]) || 0;
}
function getBoxStyle(elem, name, style) {
  if (style === void 0) {
    style = window.getComputedStyle(elem);
  }
  var suffix = name === "border" ? "Width" : "";
  return {
    left: getCSSNum("".concat(name, "Left").concat(suffix), style),
    right: getCSSNum("".concat(name, "Right").concat(suffix), style),
    top: getCSSNum("".concat(name, "Top").concat(suffix), style),
    bottom: getCSSNum("".concat(name, "Bottom").concat(suffix), style)
  };
}
function setStyle(elem, name, value) {
  elem.style[getPrefixedName(name)] = value;
}
function setTransition(elem, options) {
  var transform = getPrefixedName("transform");
  setStyle(elem, "transition", "".concat(transform, " ").concat(options.duration, "ms ").concat(options.easing));
}
function setTransform(elem, _a, _options) {
  var x = _a.x, y = _a.y, scale = _a.scale, isSVG = _a.isSVG;
  setStyle(elem, "transform", "scale(".concat(scale, ") translate(").concat(x, "px, ").concat(y, "px)"));
  if (isSVG && isIE) {
    var matrixValue = window.getComputedStyle(elem).getPropertyValue("transform");
    elem.setAttribute("transform", matrixValue);
  }
}
function getDimensions(elem) {
  var parent = elem.parentNode;
  var style = window.getComputedStyle(elem);
  var parentStyle = window.getComputedStyle(parent);
  var rectElem = elem.getBoundingClientRect();
  var rectParent = parent.getBoundingClientRect();
  return {
    elem: {
      style,
      width: rectElem.width,
      height: rectElem.height,
      top: rectElem.top,
      bottom: rectElem.bottom,
      left: rectElem.left,
      right: rectElem.right,
      margin: getBoxStyle(elem, "margin", style),
      border: getBoxStyle(elem, "border", style)
    },
    parent: {
      style: parentStyle,
      width: rectParent.width,
      height: rectParent.height,
      top: rectParent.top,
      bottom: rectParent.bottom,
      left: rectParent.left,
      right: rectParent.right,
      padding: getBoxStyle(parent, "padding", parentStyle),
      border: getBoxStyle(parent, "border", parentStyle)
    }
  };
}
var events = {
  down: "mousedown",
  move: "mousemove",
  up: "mouseup mouseleave"
};
if (typeof window !== "undefined") {
  if (typeof window.PointerEvent === "function") {
    events = {
      down: "pointerdown",
      move: "pointermove",
      up: "pointerup pointerleave pointercancel"
    };
  } else if (typeof window.TouchEvent === "function") {
    events = {
      down: "touchstart",
      move: "touchmove",
      up: "touchend touchcancel"
    };
  }
}
function onPointer(event, elem, handler, eventOpts) {
  events[event].split(" ").forEach(function(name) {
    elem.addEventListener(name, handler, eventOpts);
  });
}
function destroyPointer(event, elem, handler) {
  events[event].split(" ").forEach(function(name) {
    elem.removeEventListener(name, handler);
  });
}
function findEventIndex(pointers, event) {
  var i = pointers.length;
  while (i--) {
    if (pointers[i].pointerId === event.pointerId) {
      return i;
    }
  }
  return -1;
}
function addPointer(pointers, event) {
  var i;
  if (event.touches) {
    i = 0;
    for (var _i = 0, _a = event.touches; _i < _a.length; _i++) {
      var touch = _a[_i];
      touch.pointerId = i++;
      addPointer(pointers, touch);
    }
    return;
  }
  i = findEventIndex(pointers, event);
  if (i > -1) {
    pointers.splice(i, 1);
  }
  pointers.push(event);
}
function removePointer(pointers, event) {
  if (event.touches) {
    while (pointers.length) {
      pointers.pop();
    }
    return;
  }
  var i = findEventIndex(pointers, event);
  if (i > -1) {
    pointers.splice(i, 1);
  }
}
function getMiddle(pointers) {
  pointers = pointers.slice(0);
  var event1 = pointers.pop();
  var event2;
  while (event2 = pointers.pop()) {
    event1 = {
      clientX: (event2.clientX - event1.clientX) / 2 + event1.clientX,
      clientY: (event2.clientY - event1.clientY) / 2 + event1.clientY
    };
  }
  return event1;
}
function getDistance(pointers) {
  if (pointers.length < 2) {
    return 0;
  }
  var event1 = pointers[0];
  var event2 = pointers[1];
  return Math.sqrt(Math.pow(Math.abs(event2.clientX - event1.clientX), 2) + Math.pow(Math.abs(event2.clientY - event1.clientY), 2));
}
function isAttached(node) {
  var currentNode = node;
  while (currentNode && currentNode.parentNode) {
    if (currentNode.parentNode === document)
      return true;
    currentNode = currentNode.parentNode instanceof ShadowRoot ? currentNode.parentNode.host : currentNode.parentNode;
  }
  return false;
}
function getClass(elem) {
  return (elem.getAttribute("class") || "").trim();
}
function hasClass(elem, className) {
  return elem.nodeType === 1 && " ".concat(getClass(elem), " ").indexOf(" ".concat(className, " ")) > -1;
}
function isExcluded(elem, options) {
  for (var cur = elem; cur != null; cur = cur.parentNode) {
    if (hasClass(cur, options.excludeClass) || options.exclude.indexOf(cur) > -1) {
      return true;
    }
  }
  return false;
}
var rsvg = /^http:[\w\.\/]+svg$/;
function isSVGElement(elem) {
  return rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== "svg";
}
function shallowClone(obj) {
  var clone = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = obj[key];
    }
  }
  return clone;
}
var defaultOptions = {
  animate: false,
  canvas: false,
  cursor: "move",
  disablePan: false,
  disableZoom: false,
  disableXAxis: false,
  disableYAxis: false,
  duration: 200,
  easing: "ease-in-out",
  exclude: [],
  excludeClass: "panzoom-exclude",
  handleStartEvent: function(e) {
    e.preventDefault();
    e.stopPropagation();
  },
  maxScale: 4,
  minScale: 0.125,
  overflow: "hidden",
  panOnlyWhenZoomed: false,
  pinchAndPan: false,
  relative: false,
  setTransform,
  startX: 0,
  startY: 0,
  startScale: 1,
  step: 0.3,
  touchAction: "none"
};
function Panzoom(elem, options) {
  if (!elem) {
    throw new Error("Panzoom requires an element as an argument");
  }
  if (elem.nodeType !== 1) {
    throw new Error("Panzoom requires an element with a nodeType of 1");
  }
  if (!isAttached(elem)) {
    throw new Error("Panzoom should be called on elements that have been attached to the DOM");
  }
  options = __assign(__assign({}, defaultOptions), options);
  var isSVG = isSVGElement(elem);
  var parent = elem.parentNode;
  parent.style.overflow = options.overflow;
  parent.style.userSelect = "none";
  parent.style.touchAction = options.touchAction;
  (options.canvas ? parent : elem).style.cursor = options.cursor;
  elem.style.userSelect = "none";
  elem.style.touchAction = options.touchAction;
  setStyle(elem, "transformOrigin", typeof options.origin === "string" ? options.origin : isSVG ? "0 0" : "50% 50%");
  function resetStyle() {
    parent.style.overflow = "";
    parent.style.userSelect = "";
    parent.style.touchAction = "";
    parent.style.cursor = "";
    elem.style.cursor = "";
    elem.style.userSelect = "";
    elem.style.touchAction = "";
    setStyle(elem, "transformOrigin", "");
  }
  function setOptions(opts) {
    if (opts === void 0) {
      opts = {};
    }
    for (var key in opts) {
      if (opts.hasOwnProperty(key)) {
        options[key] = opts[key];
      }
    }
    if (opts.hasOwnProperty("cursor") || opts.hasOwnProperty("canvas")) {
      parent.style.cursor = elem.style.cursor = "";
      (options.canvas ? parent : elem).style.cursor = options.cursor;
    }
    if (opts.hasOwnProperty("overflow")) {
      parent.style.overflow = opts.overflow;
    }
    if (opts.hasOwnProperty("touchAction")) {
      parent.style.touchAction = opts.touchAction;
      elem.style.touchAction = opts.touchAction;
    }
  }
  var x = 0;
  var y = 0;
  var scale = 1;
  var isPanning = false;
  zoom(options.startScale, { animate: false, force: true });
  setTimeout(function() {
    pan(options.startX, options.startY, { animate: false, force: true });
  });
  function trigger(eventName, detail, opts) {
    if (opts.silent) {
      return;
    }
    var event = new CustomEvent(eventName, { detail });
    elem.dispatchEvent(event);
  }
  function setTransformWithEvent(eventName, opts, originalEvent) {
    var value = { x, y, scale, isSVG, originalEvent };
    requestAnimationFrame(function() {
      if (typeof opts.animate === "boolean") {
        if (opts.animate) {
          setTransition(elem, opts);
        } else {
          setStyle(elem, "transition", "none");
        }
      }
      opts.setTransform(elem, value, opts);
      trigger(eventName, value, opts);
      trigger("panzoomchange", value, opts);
    });
    return value;
  }
  function constrainXY(toX, toY, toScale, panOptions) {
    var opts = __assign(__assign({}, options), panOptions);
    var result = { x, y, opts };
    if (!opts.force && (opts.disablePan || opts.panOnlyWhenZoomed && scale === opts.startScale)) {
      return result;
    }
    toX = parseFloat(toX);
    toY = parseFloat(toY);
    if (!opts.disableXAxis) {
      result.x = (opts.relative ? x : 0) + toX;
    }
    if (!opts.disableYAxis) {
      result.y = (opts.relative ? y : 0) + toY;
    }
    if (opts.contain) {
      var dims = getDimensions(elem);
      var realWidth = dims.elem.width / scale;
      var realHeight = dims.elem.height / scale;
      var scaledWidth = realWidth * toScale;
      var scaledHeight = realHeight * toScale;
      var diffHorizontal = (scaledWidth - realWidth) / 2;
      var diffVertical = (scaledHeight - realHeight) / 2;
      if (opts.contain === "inside") {
        var minX = (-dims.elem.margin.left - dims.parent.padding.left + diffHorizontal) / toScale;
        var maxX = (dims.parent.width - scaledWidth - dims.parent.padding.left - dims.elem.margin.left - dims.parent.border.left - dims.parent.border.right + diffHorizontal) / toScale;
        result.x = Math.max(Math.min(result.x, maxX), minX);
        var minY = (-dims.elem.margin.top - dims.parent.padding.top + diffVertical) / toScale;
        var maxY = (dims.parent.height - scaledHeight - dims.parent.padding.top - dims.elem.margin.top - dims.parent.border.top - dims.parent.border.bottom + diffVertical) / toScale;
        result.y = Math.max(Math.min(result.y, maxY), minY);
      } else if (opts.contain === "outside") {
        var minX = (-(scaledWidth - dims.parent.width) - dims.parent.padding.left - dims.parent.border.left - dims.parent.border.right + diffHorizontal) / toScale;
        var maxX = (diffHorizontal - dims.parent.padding.left) / toScale;
        result.x = Math.max(Math.min(result.x, maxX), minX);
        var minY = (-(scaledHeight - dims.parent.height) - dims.parent.padding.top - dims.parent.border.top - dims.parent.border.bottom + diffVertical) / toScale;
        var maxY = (diffVertical - dims.parent.padding.top) / toScale;
        result.y = Math.max(Math.min(result.y, maxY), minY);
      }
    }
    if (opts.roundPixels) {
      result.x = Math.round(result.x);
      result.y = Math.round(result.y);
    }
    return result;
  }
  function constrainScale(toScale, zoomOptions) {
    var opts = __assign(__assign({}, options), zoomOptions);
    var result = { scale, opts };
    if (!opts.force && opts.disableZoom) {
      return result;
    }
    var minScale = options.minScale;
    var maxScale = options.maxScale;
    if (opts.contain) {
      var dims = getDimensions(elem);
      var elemWidth = dims.elem.width / scale;
      var elemHeight = dims.elem.height / scale;
      if (elemWidth > 1 && elemHeight > 1) {
        var parentWidth = dims.parent.width - dims.parent.border.left - dims.parent.border.right;
        var parentHeight = dims.parent.height - dims.parent.border.top - dims.parent.border.bottom;
        var elemScaledWidth = parentWidth / elemWidth;
        var elemScaledHeight = parentHeight / elemHeight;
        if (options.contain === "inside") {
          maxScale = Math.min(maxScale, elemScaledWidth, elemScaledHeight);
        } else if (options.contain === "outside") {
          minScale = Math.max(minScale, elemScaledWidth, elemScaledHeight);
        }
      }
    }
    result.scale = Math.min(Math.max(toScale, minScale), maxScale);
    return result;
  }
  function pan(toX, toY, panOptions, originalEvent) {
    var result = constrainXY(toX, toY, scale, panOptions);
    if (x !== result.x || y !== result.y) {
      x = result.x;
      y = result.y;
      return setTransformWithEvent("panzoompan", result.opts, originalEvent);
    }
    return { x, y, scale, isSVG, originalEvent };
  }
  function zoom(toScale, zoomOptions, originalEvent) {
    var result = constrainScale(toScale, zoomOptions);
    var opts = result.opts;
    if (!opts.force && opts.disableZoom) {
      return;
    }
    toScale = result.scale;
    var toX = x;
    var toY = y;
    if (opts.focal) {
      var focal = opts.focal;
      toX = (focal.x / toScale - focal.x / scale + x * toScale) / toScale;
      toY = (focal.y / toScale - focal.y / scale + y * toScale) / toScale;
    }
    var panResult = constrainXY(toX, toY, toScale, { relative: false, force: true });
    x = panResult.x;
    y = panResult.y;
    scale = toScale;
    return setTransformWithEvent("panzoomzoom", opts, originalEvent);
  }
  function zoomInOut(isIn, zoomOptions) {
    var opts = __assign(__assign(__assign({}, options), { animate: true }), zoomOptions);
    return zoom(scale * Math.exp((isIn ? 1 : -1) * opts.step), opts);
  }
  function zoomIn(zoomOptions) {
    return zoomInOut(true, zoomOptions);
  }
  function zoomOut(zoomOptions) {
    return zoomInOut(false, zoomOptions);
  }
  function zoomToPoint(toScale, point, zoomOptions, originalEvent) {
    var dims = getDimensions(elem);
    var effectiveArea = {
      width: dims.parent.width - dims.parent.padding.left - dims.parent.padding.right - dims.parent.border.left - dims.parent.border.right,
      height: dims.parent.height - dims.parent.padding.top - dims.parent.padding.bottom - dims.parent.border.top - dims.parent.border.bottom
    };
    var clientX = point.clientX - dims.parent.left - dims.parent.padding.left - dims.parent.border.left - dims.elem.margin.left;
    var clientY = point.clientY - dims.parent.top - dims.parent.padding.top - dims.parent.border.top - dims.elem.margin.top;
    if (!isSVG) {
      clientX -= dims.elem.width / scale / 2;
      clientY -= dims.elem.height / scale / 2;
    }
    var focal = {
      x: clientX / effectiveArea.width * (effectiveArea.width * toScale),
      y: clientY / effectiveArea.height * (effectiveArea.height * toScale)
    };
    return zoom(toScale, __assign(__assign({}, zoomOptions), { animate: false, focal }), originalEvent);
  }
  function zoomWithWheel(event, zoomOptions) {
    event.preventDefault();
    var opts = __assign(__assign(__assign({}, options), zoomOptions), { animate: false });
    var delta = event.deltaY === 0 && event.deltaX ? event.deltaX : event.deltaY;
    var wheel = delta < 0 ? 1 : -1;
    var toScale = constrainScale(scale * Math.exp(wheel * opts.step / 3), opts).scale;
    return zoomToPoint(toScale, event, opts, event);
  }
  function reset(resetOptions) {
    var opts = __assign(__assign(__assign({}, options), { animate: true, force: true }), resetOptions);
    scale = constrainScale(opts.startScale, opts).scale;
    var panResult = constrainXY(opts.startX, opts.startY, scale, opts);
    x = panResult.x;
    y = panResult.y;
    return setTransformWithEvent("panzoomreset", opts);
  }
  var origX;
  var origY;
  var startClientX;
  var startClientY;
  var startScale;
  var startDistance;
  var pointers = [];
  function handleDown(event) {
    if (isExcluded(event.target, options)) {
      return;
    }
    addPointer(pointers, event);
    isPanning = true;
    options.handleStartEvent(event);
    origX = x;
    origY = y;
    trigger("panzoomstart", { x, y, scale, isSVG, originalEvent: event }, options);
    var point = getMiddle(pointers);
    startClientX = point.clientX;
    startClientY = point.clientY;
    startScale = scale;
    startDistance = getDistance(pointers);
  }
  function handleMove(event) {
    if (!isPanning || origX === void 0 || origY === void 0 || startClientX === void 0 || startClientY === void 0) {
      return;
    }
    addPointer(pointers, event);
    var current = getMiddle(pointers);
    var hasMultiple = pointers.length > 1;
    var toScale = scale;
    if (hasMultiple) {
      if (startDistance === 0) {
        startDistance = getDistance(pointers);
      }
      var diff = getDistance(pointers) - startDistance;
      toScale = constrainScale(diff * options.step / 80 + startScale).scale;
      zoomToPoint(toScale, current, { animate: false }, event);
    }
    if (!hasMultiple || options.pinchAndPan) {
      pan(origX + (current.clientX - startClientX) / toScale, origY + (current.clientY - startClientY) / toScale, {
        animate: false
      }, event);
    }
  }
  function handleUp(event) {
    if (pointers.length === 1) {
      trigger("panzoomend", { x, y, scale, isSVG, originalEvent: event }, options);
    }
    removePointer(pointers, event);
    if (!isPanning) {
      return;
    }
    isPanning = false;
    origX = origY = startClientX = startClientY = void 0;
  }
  var bound = false;
  function bind() {
    if (bound) {
      return;
    }
    bound = true;
    onPointer("down", options.canvas ? parent : elem, handleDown);
    onPointer("move", document, handleMove, { passive: true });
    onPointer("up", document, handleUp, { passive: true });
  }
  function destroy() {
    bound = false;
    destroyPointer("down", options.canvas ? parent : elem, handleDown);
    destroyPointer("move", document, handleMove);
    destroyPointer("up", document, handleUp);
  }
  if (!options.noBind) {
    bind();
  }
  return {
    bind,
    destroy,
    eventNames: events,
    getPan: function() {
      return { x, y };
    },
    getScale: function() {
      return scale;
    },
    getOptions: function() {
      return shallowClone(options);
    },
    handleDown,
    handleMove,
    handleUp,
    pan,
    reset,
    resetStyle,
    setOptions,
    setStyle: function(name, value) {
      return setStyle(elem, name, value);
    },
    zoom,
    zoomIn,
    zoomOut,
    zoomToPoint,
    zoomWithWheel
  };
}
Panzoom.defaultOptions = defaultOptions;

// src/shared/image-zoom-gestures.ts
var import_obsidian = require("obsidian");
init_style_settings();
function setupImageZoomGestures(imgEl, container, app, file) {
  let panzoomInstance = null;
  let clickHandler = null;
  let dblclickHandler = null;
  let contextmenuHandler = null;
  let loadHandler = null;
  function attachPanzoom() {
    var _a;
    const zoomSensitivity = getZoomSensitivity();
    const isMobile = (_a = app == null ? void 0 : app.isMobile) != null ? _a : false;
    let startScale = 1;
    let minScale = 0.1;
    if (isMobile) {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const naturalWidth = imgEl.naturalWidth;
      const naturalHeight = imgEl.naturalHeight;
      const widthScale = viewportWidth / naturalWidth;
      const heightScale = viewportHeight / naturalHeight;
      startScale = Math.min(1, widthScale, heightScale);
      minScale = startScale;
    }
    panzoomInstance = Panzoom(imgEl, {
      maxScale: 4,
      minScale,
      startScale,
      step: zoomSensitivity,
      canvas: false,
      cursor: "move"
    });
    container.addEventListener("wheel", panzoomInstance.zoomWithWheel, {
      passive: false
    });
    clickHandler = (e) => {
      e.stopPropagation();
    };
    imgEl.addEventListener("click", clickHandler);
    dblclickHandler = (e) => {
      e.stopPropagation();
      panzoomInstance == null ? void 0 : panzoomInstance.reset();
    };
    imgEl.addEventListener("dblclick", dblclickHandler);
    if (app && file) {
      contextmenuHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const menu = new import_obsidian.Menu();
        app.workspace.trigger("file-menu", menu, file, "file-explorer");
        menu.showAtMouseEvent(e);
      };
      imgEl.addEventListener("contextmenu", contextmenuHandler);
    }
  }
  if (imgEl.complete && imgEl.naturalWidth > 0) {
    attachPanzoom();
  } else {
    loadHandler = () => {
      attachPanzoom();
    };
    imgEl.addEventListener("load", loadHandler, { once: true });
  }
  return () => {
    if (panzoomInstance) {
      container.removeEventListener("wheel", panzoomInstance.zoomWithWheel, {
        passive: false
      });
      panzoomInstance.destroy();
    }
    if (clickHandler) {
      imgEl.removeEventListener("click", clickHandler);
    }
    if (dblclickHandler) {
      imgEl.removeEventListener("dblclick", dblclickHandler);
    }
    if (contextmenuHandler) {
      imgEl.removeEventListener("contextmenu", contextmenuHandler);
    }
    if (loadHandler) {
      imgEl.removeEventListener("load", loadHandler);
    }
  };
}

// src/shared/image-zoom-handler.ts
var zoomListenerCleanups = /* @__PURE__ */ new WeakMap();
function handleImageZoomClick(e, cardPath, app, zoomCleanupFns2, zoomedOriginalParents2) {
  const isZoomEnabled = document.body.classList.contains(
    "dynamic-views-image-zoom-enabled"
  );
  if (!isZoomEnabled)
    return;
  e.stopPropagation();
  const embedEl = e.currentTarget;
  const isZoomed = embedEl.classList.contains("is-zoomed");
  if (isZoomed) {
    closeImageZoom(embedEl, zoomCleanupFns2, zoomedOriginalParents2);
  } else {
    openImageZoom(
      embedEl,
      cardPath,
      app,
      zoomCleanupFns2,
      zoomedOriginalParents2
    );
  }
}
function closeImageZoom(embedEl, zoomCleanupFns2, zoomedOriginalParents2) {
  embedEl.classList.remove("is-zoomed");
  const originalParent = zoomedOriginalParents2.get(embedEl);
  if (originalParent && embedEl.parentElement !== originalParent) {
    originalParent.appendChild(embedEl);
    zoomedOriginalParents2.delete(embedEl);
  }
  const cleanup = zoomCleanupFns2.get(embedEl);
  if (cleanup) {
    cleanup();
    zoomCleanupFns2.delete(embedEl);
  }
  const removeListeners = zoomListenerCleanups.get(embedEl);
  if (removeListeners) {
    removeListeners();
    zoomListenerCleanups.delete(embedEl);
  }
}
function openImageZoom(embedEl, cardPath, app, zoomCleanupFns2, zoomedOriginalParents2) {
  const viewContainer = embedEl.closest(".workspace-leaf-content");
  if (viewContainer) {
    viewContainer.querySelectorAll(".image-embed.is-zoomed").forEach((el) => {
      el.classList.remove("is-zoomed");
      const originalParent2 = zoomedOriginalParents2.get(el);
      if (originalParent2 && el.parentElement !== originalParent2) {
        originalParent2.appendChild(el);
        zoomedOriginalParents2.delete(el);
      }
      const cleanup2 = zoomCleanupFns2.get(el);
      if (cleanup2) {
        cleanup2();
        zoomCleanupFns2.delete(el);
      }
    });
  }
  const isConstrained = document.body.classList.contains(
    "dynamic-views-zoom-constrain-to-editor"
  );
  const originalParent = embedEl.parentElement;
  if (originalParent && !isConstrained) {
    zoomedOriginalParents2.set(embedEl, originalParent);
    document.body.appendChild(embedEl);
  }
  embedEl.classList.add("is-zoomed");
  const imgEl = embedEl.querySelector("img");
  if (!imgEl) {
    console.warn("Dynamic Views: Zoom opened but no img element found");
    return;
  }
  const file = app.vault.getAbstractFileByPath(cardPath);
  const cleanup = setupImageZoomGestures(
    imgEl,
    embedEl,
    app,
    file instanceof import_obsidian2.TFile ? file : void 0
  );
  zoomCleanupFns2.set(embedEl, cleanup);
  const closeZoom = (evt) => {
    const target = evt.target;
    if (!embedEl.contains(target)) {
      embedEl.classList.remove("is-zoomed");
      const originalParent2 = zoomedOriginalParents2.get(embedEl);
      if (originalParent2 && embedEl.parentElement !== originalParent2) {
        originalParent2.appendChild(embedEl);
        zoomedOriginalParents2.delete(embedEl);
      }
      const cleanup2 = zoomCleanupFns2.get(embedEl);
      if (cleanup2) {
        cleanup2();
        zoomCleanupFns2.delete(embedEl);
      }
      const removeListeners = zoomListenerCleanups.get(embedEl);
      if (removeListeners) {
        removeListeners();
        zoomListenerCleanups.delete(embedEl);
      }
    }
  };
  const handleEscape = (evt) => {
    if (evt.key === "Escape") {
      embedEl.classList.remove("is-zoomed");
      const originalParent2 = zoomedOriginalParents2.get(embedEl);
      if (originalParent2 && embedEl.parentElement !== originalParent2) {
        originalParent2.appendChild(embedEl);
        zoomedOriginalParents2.delete(embedEl);
      }
      const cleanup2 = zoomCleanupFns2.get(embedEl);
      if (cleanup2) {
        cleanup2();
        zoomCleanupFns2.delete(embedEl);
      }
      const removeListeners = zoomListenerCleanups.get(embedEl);
      if (removeListeners) {
        removeListeners();
        zoomListenerCleanups.delete(embedEl);
      }
    }
  };
  setTimeout(() => {
    document.addEventListener("click", closeZoom);
    document.addEventListener("keydown", handleEscape);
  }, 0);
  zoomListenerCleanups.set(embedEl, () => {
    document.removeEventListener("click", closeZoom);
    document.removeEventListener("keydown", handleEscape);
  });
}

// src/shared/card-renderer.tsx
function renderLink(link, app) {
  if (link.type === "internal") {
    if (link.isEmbed) {
      return /* @__PURE__ */ h(
        "span",
        {
          className: "internal-embed",
          "data-src": link.url,
          onClick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            const newLeaf = e.metaKey || e.ctrlKey;
            void app.workspace.openLinkText(link.url, "", newLeaf);
          }
        },
        link.caption
      );
    }
    return /* @__PURE__ */ h(
      "a",
      {
        href: link.url,
        className: "internal-link",
        "data-href": link.url,
        draggable: true,
        onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          const newLeaf = e.metaKey || e.ctrlKey;
          void app.workspace.openLinkText(link.url, "", newLeaf);
        },
        onDragStart: (e) => {
          const file = app.metadataCache.getFirstLinkpathDest(link.url, "");
          if (!(file instanceof import_obsidian3.TFile))
            return;
          const dragData = app.dragManager.dragFile(e, file);
          app.dragManager.onDragStart(e, dragData);
        }
      },
      link.caption
    );
  }
  if (link.isEmbed) {
    return /* @__PURE__ */ h(
      "img",
      {
        src: link.url,
        alt: link.caption,
        className: "external-embed",
        onClick: (e) => {
          e.stopPropagation();
        }
      }
    );
  }
  return /* @__PURE__ */ h(
    "a",
    {
      href: link.url,
      className: "external-link",
      target: link.isWebUrl ? "_blank" : void 0,
      rel: link.isWebUrl ? "noopener noreferrer" : void 0,
      onClick: (e) => {
        e.stopPropagation();
      },
      onDragStart: (e) => {
        var _a, _b;
        (_a = e.dataTransfer) == null ? void 0 : _a.clearData();
        const dragText = link.caption === link.url ? link.url : `[${link.caption}](${link.url})`;
        (_b = e.dataTransfer) == null ? void 0 : _b.setData("text/plain", dragText);
      }
    },
    link.caption
  );
}
function renderTextWithLinks(text, app) {
  const segments = findLinksInText(text);
  const elements = [];
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (segment.type === "text") {
      elements.push(segment.content);
    } else {
      elements.push(/* @__PURE__ */ h("span", { key: i }, renderLink(segment.link, app)));
    }
  }
  return /* @__PURE__ */ h(Fragment, null, elements);
}
var zoomCleanupFns = /* @__PURE__ */ new Map();
var zoomedOriginalParents = /* @__PURE__ */ new Map();
function renderPropertyContent(propertyName, card, resolvedValue, timeIcon, settings, app) {
  const stringValue = typeof resolvedValue === "string" ? resolvedValue : "";
  return renderProperty(
    propertyName,
    null,
    stringValue,
    settings,
    card,
    app,
    timeIcon
  );
}
function CoverCarousel({
  imageArray,
  updateLayoutRef
}) {
  const onCarouselRef = (carouselEl) => {
    if (!carouselEl)
      return;
    let currentSlide = 0;
    const slides = Array.from(carouselEl.querySelectorAll(".carousel-slide"));
    const updateSlide = (newIndex, direction) => {
      const oldSlide = slides[currentSlide];
      const newSlide = slides[newIndex];
      if (!oldSlide || !newSlide)
        return;
      console.log("// CAROUSEL TRANSITION (Datacore):", {
        from: currentSlide,
        to: newIndex,
        direction,
        oldClasses: oldSlide.className,
        newClasses: newSlide.className
      });
      newSlide.classList.remove("is-active", "slide-left", "slide-right");
      newSlide.classList.add(
        direction === "next" ? "slide-right" : "slide-left"
      );
      console.log("// After positioning new slide:", newSlide.className);
      void newSlide.offsetHeight;
      oldSlide.classList.remove("is-active", "slide-left", "slide-right");
      oldSlide.classList.add(
        direction === "next" ? "slide-left" : "slide-right"
      );
      newSlide.classList.add("is-active");
      setTimeout(() => {
        newSlide.classList.remove("slide-left", "slide-right");
      }, 310);
      console.log("// After transition:", {
        oldClasses: oldSlide.className,
        newClasses: newSlide.className
      });
      currentSlide = newIndex;
    };
    const leftArrow = carouselEl.querySelector(".carousel-nav-left");
    const rightArrow = carouselEl.querySelector(".carousel-nav-right");
    leftArrow == null ? void 0 : leftArrow.addEventListener("click", (e) => {
      e.stopPropagation();
      const newIndex = currentSlide === 0 ? imageArray.length - 1 : currentSlide - 1;
      const direction = currentSlide === 0 ? "next" : "prev";
      updateSlide(newIndex, direction);
    });
    rightArrow == null ? void 0 : rightArrow.addEventListener("click", (e) => {
      e.stopPropagation();
      const newIndex = currentSlide === imageArray.length - 1 ? 0 : currentSlide + 1;
      const direction = currentSlide === imageArray.length - 1 ? "prev" : "next";
      updateSlide(newIndex, direction);
    });
  };
  return /* @__PURE__ */ h("div", { className: "card-cover card-cover-carousel", ref: onCarouselRef }, /* @__PURE__ */ h("div", { className: "carousel-slides" }, imageArray.map(
    (url, index) => /* @__PURE__ */ h(
      "div",
      {
        key: index,
        className: `carousel-slide ${index === 0 ? "is-active" : ""}`
      },
      /* @__PURE__ */ h(
        "div",
        {
          className: "image-embed",
          style: { "--cover-image-url": `url("${url}")` }
        },
        index === 0 && /* @__PURE__ */ h("div", { className: "carousel-indicator" }, /* @__PURE__ */ h(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "24",
            height: "24",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            "stroke-width": "2",
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
          },
          /* @__PURE__ */ h("rect", { x: "5", y: "7", width: "13", height: "10", rx: "1" }),
          /* @__PURE__ */ h("polyline", { points: "4 2,8 2,8 7" }),
          /* @__PURE__ */ h("polyline", { points: "8 2,16 2,16 7" }),
          /* @__PURE__ */ h("polyline", { points: "16 2,20 2,20 7" })
        )),
        /* @__PURE__ */ h(
          "img",
          {
            src: url,
            alt: "",
            onLoad: (e) => {
              var _a;
              if (index === 0) {
                const imgEl = e.currentTarget;
                const imageEmbedEl = imgEl.parentElement;
                if (imageEmbedEl) {
                  const slideEl = imageEmbedEl.parentElement;
                  if (slideEl) {
                    const carouselEl = (_a = slideEl.parentElement) == null ? void 0 : _a.parentElement;
                    if (carouselEl) {
                      const cardEl = carouselEl.closest(
                        ".card"
                      );
                      if (cardEl) {
                        handleImageLoad(
                          imgEl,
                          imageEmbedEl,
                          cardEl,
                          updateLayoutRef.current
                        );
                      }
                    }
                  }
                }
              }
            }
          }
        )
      )
    )
  )), /* @__PURE__ */ h("div", { className: "carousel-nav-left" }, /* @__PURE__ */ h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    },
    /* @__PURE__ */ h("polyline", { points: "15 18 9 12 15 6" })
  )), /* @__PURE__ */ h("div", { className: "carousel-nav-right" }, /* @__PURE__ */ h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    },
    /* @__PURE__ */ h("polyline", { points: "9 18 15 12 9 6" })
  )));
}
function renderProperty(propertyName, propertyValue, resolvedValue, settings, card, app, timeIcon) {
  if (propertyName === "") {
    return null;
  }
  if (resolvedValue === null && shouldHideMissingProperties()) {
    return null;
  }
  if (resolvedValue === "" && shouldHideEmptyProperties()) {
    return null;
  }
  const labelAbove = settings.propertyLabels === "above" ? /* @__PURE__ */ h("div", { className: "property-label" }, getPropertyLabel(propertyName)) : null;
  const labelInline = settings.propertyLabels === "inline" ? /* @__PURE__ */ h("span", { className: "property-label-inline" }, getPropertyLabel(propertyName), " ") : null;
  if (!resolvedValue) {
    return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("span", { className: "empty-value-marker" }, getEmptyValueMarker()))));
  }
  if (resolvedValue.startsWith('{"type":"array","items":[')) {
    try {
      const arrayData = JSON.parse(resolvedValue);
      if (arrayData.type === "array" && Array.isArray(arrayData.items)) {
        const separator = getListSeparator();
        return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("span", { className: "list-wrapper" }, arrayData.items.map(
          (item, idx) => /* @__PURE__ */ h("span", { key: idx }, /* @__PURE__ */ h("span", { className: "list-item" }, renderTextWithLinks(item, app)), idx < arrayData.items.length - 1 && /* @__PURE__ */ h("span", { className: "list-separator" }, separator))
        )))));
      }
    } catch (e) {
    }
  }
  if (propertyName === "file.mtime" || propertyName === "file.ctime" || propertyName === "timestamp" || propertyName === "modified time" || propertyName === "created time") {
    return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("span", null, showTimestampIcon() && settings.propertyLabels === "hide" && /* @__PURE__ */ h(
      "svg",
      {
        className: "timestamp-icon",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      timeIcon === "calendar" ? /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("path", { d: "M8 2v4" }), /* @__PURE__ */ h("path", { d: "M16 2v4" }), /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }), /* @__PURE__ */ h("path", { d: "M3 10h18" })) : /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("circle", { cx: "12", cy: "12", r: "10" }), /* @__PURE__ */ h("polyline", { points: "12 6 12 12 16 14" }))
    ), /* @__PURE__ */ h("span", null, resolvedValue)))));
  } else if ((propertyName === "tags" || propertyName === "note.tags") && card.yamlTags.length > 0) {
    const showHashPrefix = showTagHashPrefix();
    return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("div", { className: "tags-wrapper" }, card.yamlTags.map(
      (tag) => /* @__PURE__ */ h(
        "a",
        {
          key: tag,
          href: "#",
          className: "tag",
          onClick: (e) => {
            var _a;
            e.preventDefault();
            const searchPlugin = app.internalPlugins.plugins["global-search"];
            if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
              searchPlugin.instance.openGlobalSearch("tag:" + tag);
            }
          }
        },
        showHashPrefix ? "#" + tag : tag
      )
    )))));
  } else if ((propertyName === "file.tags" || propertyName === "file tags") && card.tags.length > 0) {
    const showHashPrefix = showTagHashPrefix();
    return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("div", { className: "tags-wrapper" }, card.tags.map(
      (tag) => /* @__PURE__ */ h(
        "a",
        {
          key: tag,
          href: "#",
          className: "tag",
          onClick: (e) => {
            var _a;
            e.preventDefault();
            const searchPlugin = app.internalPlugins.plugins["global-search"];
            if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
              searchPlugin.instance.openGlobalSearch("tag:" + tag);
            }
          }
        },
        showHashPrefix ? "#" + tag : tag
      )
    )))));
  } else if ((propertyName === "file.path" || propertyName === "path" || propertyName === "file path") && resolvedValue) {
    return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("div", { className: "path-wrapper" }, resolvedValue.split("/").filter((f) => f).map((segment, idx, array) => {
      const allParts = resolvedValue.split("/").filter((f) => f);
      const cumulativePath = allParts.slice(0, idx + 1).join("/");
      const isLastSegment = idx === array.length - 1;
      const segmentClass = isLastSegment ? "path-segment filename-segment" : "path-segment file-path-segment";
      return /* @__PURE__ */ h(
        "span",
        {
          key: idx,
          style: { display: "inline-flex", alignItems: "center" }
        },
        /* @__PURE__ */ h(
          "span",
          {
            className: segmentClass,
            onClick: (e) => {
              var _a, _b, _c;
              e.stopPropagation();
              const fileExplorer = (_b = (_a = app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["file-explorer"];
              if ((_c = fileExplorer == null ? void 0 : fileExplorer.instance) == null ? void 0 : _c.revealInFolder) {
                const folder = app.vault.getAbstractFileByPath(cumulativePath);
                if (folder) {
                  fileExplorer.instance.revealInFolder(folder);
                }
              }
            },
            onContextMenu: !isLastSegment ? (e) => {
              e.stopPropagation();
              e.preventDefault();
              const folderFile = app.vault.getAbstractFileByPath(
                cumulativePath
              );
              if (folderFile instanceof import_obsidian3.TFolder) {
                const menu = new import_obsidian3.Menu();
                app.workspace.trigger(
                  "file-menu",
                  menu,
                  folderFile,
                  "file-explorer"
                );
                menu.showAtMouseEvent(
                  e
                );
              }
            } : void 0
          },
          segment
        ),
        idx < array.length - 1 && /* @__PURE__ */ h("span", { className: "path-separator" }, "/")
      );
    })))));
  }
  return /* @__PURE__ */ h(Fragment, null, labelAbove, labelInline, /* @__PURE__ */ h("div", { className: "property-content-wrapper" }, /* @__PURE__ */ h("div", { className: "property-content" }, /* @__PURE__ */ h("span", null, renderTextWithLinks(resolvedValue, app)))));
}
function CardRenderer({
  cards,
  settings,
  viewMode,
  sortMethod,
  isShuffled,
  focusableCardIndex,
  containerRef,
  updateLayoutRef,
  app,
  onCardClick,
  onFocusChange
}) {
  return /* @__PURE__ */ h(
    "div",
    {
      ref: containerRef,
      className: viewMode === "masonry" ? "dynamic-views-masonry" : "dynamic-views-grid",
      style: settings.queryHeight > 0 ? { maxHeight: `${settings.queryHeight}px`, overflowY: "auto" } : {}
    },
    cards.map(
      (card, index) => /* @__PURE__ */ h(
        Card,
        {
          key: card.path,
          card,
          index,
          settings,
          viewMode,
          sortMethod,
          isShuffled,
          focusableCardIndex,
          containerRef,
          updateLayoutRef,
          app,
          onCardClick,
          onFocusChange
        }
      )
    )
  );
}
function Card({
  card,
  index,
  settings,
  viewMode,
  sortMethod,
  isShuffled,
  focusableCardIndex,
  containerRef,
  updateLayoutRef,
  app,
  onCardClick,
  onFocusChange
}) {
  const useCreatedTime = sortMethod.startsWith("ctime") && !isShuffled;
  const timeIcon = useCreatedTime ? "calendar" : "clock";
  const isArray = Array.isArray(card.imageUrl);
  const imageArray = isArray ? card.imageUrl.flat().filter(
    (url) => typeof url === "string" && url.length > 0
  ) : card.imageUrl ? [card.imageUrl] : [];
  const imageFormat = settings.imageFormat;
  let format = "none";
  let position = "right";
  if (imageFormat === "none") {
    format = "none";
  } else if (imageFormat.startsWith("thumbnail-")) {
    format = "thumbnail";
    position = imageFormat.split("-")[1];
  } else if (imageFormat.startsWith("cover-")) {
    format = "cover";
    position = imageFormat.split("-")[1];
  }
  const cardClasses = ["card"];
  if (format === "cover") {
    cardClasses.push("image-format-cover");
    cardClasses.push(`card-cover-${position}`);
    cardClasses.push(`card-cover-${settings.coverFitMode}`);
  } else if (format === "thumbnail") {
    cardClasses.push("image-format-thumbnail");
    cardClasses.push(`card-thumbnail-${position}`);
  }
  const handleDrag = (e) => {
    const file = app.vault.getAbstractFileByPath(card.path);
    if (!(file instanceof import_obsidian3.TFile))
      return;
    const dragData = app.dragManager.dragFile(e, file);
    app.dragManager.onDragStart(e, dragData);
  };
  return /* @__PURE__ */ h(
    "div",
    {
      className: cardClasses.join(" "),
      "data-path": card.path,
      draggable: settings.openFileAction === "card",
      onDragStart: settings.openFileAction === "card" ? handleDrag : void 0,
      tabIndex: index === focusableCardIndex ? 0 : -1,
      onClick: (e) => {
        if (settings.openFileAction === "card") {
          const target = e.target;
          const isLink = target.tagName === "A" || target.closest("a");
          const isTag = target.classList.contains("tag") || target.closest(".tag");
          const isImage = target.tagName === "IMG";
          if (!isLink && !isTag && !isImage) {
            const newLeaf = e.metaKey || e.ctrlKey;
            if (onCardClick) {
              onCardClick(card.path, newLeaf);
            } else {
              void app.workspace.openLinkText(card.path, "", newLeaf);
            }
          }
        }
      },
      onFocus: () => {
        if (onFocusChange) {
          onFocusChange(index);
        }
      },
      onKeyDown: (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          if (settings.openFileAction === "card") {
            const newLeaf = e.metaKey || e.ctrlKey;
            if (onCardClick) {
              onCardClick(card.path, newLeaf);
            } else {
              void app.workspace.openLinkText(card.path, "", newLeaf);
            }
          }
        } else if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          e.preventDefault();
          handleArrowKey(e, index, viewMode, containerRef, onFocusChange);
        } else if (e.key === "Tab") {
          e.preventDefault();
        }
      },
      onMouseEnter: (e) => {
        app.workspace.trigger("hover-link", {
          event: e,
          source: "dynamic-views",
          hoverParent: e.currentTarget,
          targetEl: e.currentTarget,
          linktext: card.path,
          sourcePath: card.path
        });
        const imageSelector = format === "cover" ? ".card-cover img" : ".card-thumbnail img";
        const imgEl = e.currentTarget.querySelector(
          imageSelector
        );
        const firstImage = imageArray[0];
        if (imgEl && firstImage) {
          imgEl.src = firstImage;
        }
      },
      style: {
        cursor: settings.openFileAction === "card" ? "pointer" : "default"
      }
    },
    (settings.showTitle || card.hasValidUrl) && /* @__PURE__ */ h(
      "div",
      {
        className: card.hasValidUrl ? "card-title-container" : "card-title"
      },
      settings.showTitle && /* @__PURE__ */ h("div", { className: card.hasValidUrl ? "card-title" : void 0 }, settings.openFileAction === "title" ? /* @__PURE__ */ h(
        "a",
        {
          href: card.path,
          className: "internal-link",
          "data-href": card.path,
          draggable: true,
          onDragStart: handleDrag,
          onClick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            const newLeaf = e.metaKey || e.ctrlKey;
            void app.workspace.openLinkText(card.path, "", newLeaf);
          }
        },
        card.title
      ) : card.title),
      card.hasValidUrl && card.urlValue && /* @__PURE__ */ h(
        "svg",
        {
          className: "card-title-url-icon text-icon-button svg-icon",
          xmlns: "http://www.w3.org/2000/svg",
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          onClick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.open(card.urlValue, "_blank", "noopener,noreferrer");
          },
          title: "Open URL"
        },
        /* @__PURE__ */ h("path", { d: "M21 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6" }),
        /* @__PURE__ */ h("path", { d: "m21 3-9 9" }),
        /* @__PURE__ */ h("path", { d: "M15 3h6v6" })
      )
    ),
    settings.subtitleProperty && card.subtitle && /* @__PURE__ */ h("div", { className: "card-subtitle" }, renderProperty(
      settings.subtitleProperty,
      null,
      card.subtitle,
      { ...settings, propertyLabels: "hide" },
      card,
      app,
      timeIcon
    )),
    format === "cover" && /* @__PURE__ */ h(
      "div",
      {
        className: imageArray.length > 0 ? "card-cover-wrapper" : "card-cover-wrapper card-cover-wrapper-placeholder"
      },
      imageArray.length > 0 ? (() => {
        const shouldShowCarousel = (position === "top" || position === "bottom") && imageArray.length >= 2;
        if (shouldShowCarousel) {
          return /* @__PURE__ */ h(
            CoverCarousel,
            {
              imageArray,
              updateLayoutRef
            }
          );
        }
        return /* @__PURE__ */ h("div", { className: "card-cover" }, /* @__PURE__ */ h(
          "div",
          {
            className: "image-embed",
            style: {
              "--cover-image-url": `url("${imageArray[0] || ""}")`
            },
            onClick: (e) => {
              handleImageZoomClick(
                e,
                card.path,
                app,
                zoomCleanupFns,
                zoomedOriginalParents
              );
            }
          },
          /* @__PURE__ */ h(
            "img",
            {
              src: imageArray[0] || "",
              alt: "",
              onLoad: (e) => {
                const imgEl = e.currentTarget;
                const imageEmbedEl = imgEl.parentElement;
                if (imageEmbedEl) {
                  const imageEl = imageEmbedEl.parentElement;
                  if (imageEl) {
                    const cardEl = imageEl.closest(
                      ".card"
                    );
                    if (cardEl) {
                      handleImageLoad(
                        imgEl,
                        imageEmbedEl,
                        cardEl,
                        updateLayoutRef.current
                      );
                    }
                  }
                }
              }
            }
          )
        ));
      })() : /* @__PURE__ */ h("div", { className: "card-cover-placeholder" })
    ),
    format === "cover" && (position === "left" || position === "right") && (() => {
      setTimeout(() => {
        const cardEl = document.querySelector(
          `[data-path="${card.path}"]`
        );
        if (!cardEl)
          return;
        const aspectRatio = typeof settings.imageAspectRatio === "string" ? parseFloat(settings.imageAspectRatio) : settings.imageAspectRatio || 1;
        const wrapperRatio = aspectRatio / (aspectRatio + 1);
        const elementSpacing = 8;
        cardEl.style.setProperty(
          "--dynamic-views-wrapper-ratio",
          wrapperRatio.toString()
        );
        const updateWrapperDimensions = () => {
          const cardWidth = cardEl.offsetWidth;
          const targetWidth2 = Math.floor(wrapperRatio * cardWidth);
          const paddingValue2 = targetWidth2 + elementSpacing;
          cardEl.style.setProperty(
            "--dynamic-views-side-cover-width",
            `${targetWidth2}px`
          );
          cardEl.style.setProperty(
            "--dynamic-views-side-cover-content-padding",
            `${paddingValue2}px`
          );
          return { cardWidth, targetWidth: targetWidth2, paddingValue: paddingValue2 };
        };
        const {
          cardWidth: _cardWidth,
          targetWidth,
          paddingValue
        } = updateWrapperDimensions();
        const cardComputed = getComputedStyle(cardEl);
        console.log(
          "[CSS Variable Check]",
          "cardEl classes:",
          cardEl.className,
          "--side-cover-width on card style:",
          cardEl.style.getPropertyValue("--dynamic-views-side-cover-width"),
          "card computed --side-cover-width:",
          cardComputed.getPropertyValue("--dynamic-views-side-cover-width")
        );
        const computedStyle = cardComputed;
        console.log(
          "[Side Cover Debug - card-renderer]",
          "cardPath:",
          card.path,
          "position:",
          position,
          "aspectRatio:",
          aspectRatio,
          "wrapperRatio:",
          wrapperRatio,
          "cardOffsetWidth:",
          cardEl.offsetWidth,
          "cardClientWidth:",
          cardEl.clientWidth,
          "padding:",
          computedStyle.padding,
          "targetWidth:",
          targetWidth,
          "paddingValue:",
          paddingValue
        );
        setTimeout(() => {
          const wrapper = cardEl.querySelector(
            ".card-cover-wrapper"
          );
          const cover = cardEl.querySelector(".card-cover");
          const img = cardEl.querySelector(
            ".card-cover img"
          );
          if (wrapper && cover && img) {
            const wrapperComputed = getComputedStyle(wrapper);
            console.log(
              "[Wrapper CSS Debug - card-renderer]",
              "wrapper classes:",
              wrapper.className,
              "wrapper.style.width:",
              wrapper.style.width,
              "wrapper parent is card:",
              wrapper.parentElement === cardEl,
              "wrapper CSS width value:",
              wrapperComputed.getPropertyValue("width"),
              "wrapper resolves variable:",
              wrapperComputed.getPropertyValue(
                "--dynamic-views-side-cover-width"
              )
            );
            console.log(
              "[Side Cover Rendered - card-renderer]",
              "cardPath:",
              card.path,
              "position:",
              position,
              "wrapperWidth:",
              wrapper.offsetWidth,
              "wrapperComputedWidth:",
              wrapperComputed.width,
              "coverWidth:",
              cover.offsetWidth,
              "coverComputedWidth:",
              getComputedStyle(cover).width,
              "imgWidth:",
              img.offsetWidth,
              "imgComputedWidth:",
              getComputedStyle(img).width
            );
          }
        }, 200);
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const target = entry.target;
            const newCardWidth = target.offsetWidth;
            if (newCardWidth === 0) {
              console.log(
                "[Side Cover Resize - card-renderer] Skipped - cardWidth is 0"
              );
              continue;
            }
            const newTargetWidth = Math.floor(wrapperRatio * newCardWidth);
            const newPaddingValue = newTargetWidth + elementSpacing;
            cardEl.style.setProperty(
              "--dynamic-views-side-cover-width",
              `${newTargetWidth}px`
            );
            cardEl.style.setProperty(
              "--dynamic-views-side-cover-content-padding",
              `${newPaddingValue}px`
            );
            console.log(
              "[Side Cover Resize - card-renderer]",
              "cardPath:",
              card.path,
              "newCardWidth:",
              newCardWidth,
              "newTargetWidth:",
              newTargetWidth,
              "newPaddingValue:",
              newPaddingValue
            );
          }
        });
        resizeObserver.observe(cardEl);
      }, 100);
      return null;
    })(),
    format === "thumbnail" && position === "top" && (imageArray.length > 0 || card.hasImageAvailable) && (imageArray.length > 0 ? /* @__PURE__ */ h(
      "div",
      {
        className: `card-thumbnail ${isArray && imageArray.length > 1 ? "multi-image" : ""}`,
        onMouseMove: !app.isMobile && isArray && imageArray.length > 1 ? (e) => {
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const section = Math.floor(
            x / rect.width * imageArray.length
          );
          const newIndex = Math.min(section, imageArray.length - 1);
          const imgEl = e.currentTarget.querySelector("img");
          const newSrc = imageArray[newIndex];
          if (imgEl && newSrc) {
            const currentSrc = imgEl.src;
            if (currentSrc !== newSrc) {
              imgEl.src = newSrc;
            }
          }
        } : void 0,
        onMouseLeave: !app.isMobile && isArray && imageArray.length > 1 ? (e) => {
          const imgEl = e.currentTarget.querySelector("img");
          const firstSrc = imageArray[0];
          if (imgEl && firstSrc) {
            imgEl.src = firstSrc;
          }
        } : void 0
      },
      /* @__PURE__ */ h(
        "div",
        {
          className: "image-embed",
          style: { "--cover-image-url": `url("${imageArray[0] || ""}")` },
          onClick: (e) => {
            handleImageZoomClick(
              e,
              card.path,
              app,
              zoomCleanupFns,
              zoomedOriginalParents
            );
          }
        },
        /* @__PURE__ */ h(
          "img",
          {
            src: imageArray[0] || "",
            alt: "",
            onLoad: (e) => {
              const imgEl = e.currentTarget;
              const imageEmbedEl = imgEl.parentElement;
              if (imageEmbedEl) {
                const imageEl = imageEmbedEl.parentElement;
                if (imageEl) {
                  const cardEl = imageEl.closest(".card");
                  if (cardEl) {
                    handleImageLoad(
                      imgEl,
                      imageEmbedEl,
                      cardEl,
                      updateLayoutRef.current
                    );
                  }
                }
              }
            }
          }
        )
      )
    ) : /* @__PURE__ */ h("div", { className: "card-thumbnail-placeholder" })),
    (settings.showTextPreview && card.snippet || format === "thumbnail" && (position === "left" || position === "right") && (imageArray.length > 0 || card.hasImageAvailable)) && /* @__PURE__ */ h("div", { className: "card-content" }, settings.showTextPreview && card.snippet && /* @__PURE__ */ h("div", { className: "card-text-preview" }, card.snippet), format === "thumbnail" && (position === "left" || position === "right") && (imageArray.length > 0 ? /* @__PURE__ */ h(
      "div",
      {
        className: `card-thumbnail ${isArray && imageArray.length > 1 ? "multi-image" : ""}`,
        onMouseMove: !app.isMobile && isArray && imageArray.length > 1 ? (e) => {
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const section = Math.floor(
            x / rect.width * imageArray.length
          );
          const newIndex = Math.min(
            section,
            imageArray.length - 1
          );
          const imgEl = e.currentTarget.querySelector("img");
          const newSrc = imageArray[newIndex];
          if (imgEl && newSrc) {
            const currentSrc = imgEl.src;
            if (currentSrc !== newSrc) {
              imgEl.src = newSrc;
            }
          }
        } : void 0,
        onMouseLeave: !app.isMobile && isArray && imageArray.length > 1 && format === "thumbnail" ? (e) => {
          const imgEl = e.currentTarget.querySelector("img");
          const firstSrc = imageArray[0];
          if (imgEl && firstSrc) {
            imgEl.src = firstSrc;
          }
        } : void 0
      },
      /* @__PURE__ */ h(
        "div",
        {
          className: "image-embed",
          style: {
            "--cover-image-url": `url("${imageArray[0] || ""}")`
          },
          onClick: (e) => {
            handleImageZoomClick(
              e,
              card.path,
              app,
              zoomCleanupFns,
              zoomedOriginalParents
            );
          }
        },
        /* @__PURE__ */ h(
          "img",
          {
            src: imageArray[0] || "",
            alt: "",
            onLoad: (e) => {
              const imgEl = e.currentTarget;
              const imageEmbedEl = imgEl.parentElement;
              if (imageEmbedEl) {
                const imageEl = imageEmbedEl.parentElement;
                if (imageEl) {
                  const cardEl = imageEl.closest(
                    ".card"
                  );
                  if (cardEl) {
                    handleImageLoad(
                      imgEl,
                      imageEmbedEl,
                      cardEl,
                      updateLayoutRef.current
                    );
                  }
                }
              }
            }
          }
        )
      )
    ) : (
      // Always render placeholder when no image - CSS controls visibility
      /* @__PURE__ */ h("div", { className: "card-thumbnail-placeholder" })
    ))),
    format === "thumbnail" && position === "bottom" && (imageArray.length > 0 || card.hasImageAvailable) && (imageArray.length > 0 ? /* @__PURE__ */ h(
      "div",
      {
        className: `card-thumbnail ${isArray && imageArray.length > 1 ? "multi-image" : ""}`,
        onMouseMove: !app.isMobile && isArray && imageArray.length > 1 ? (e) => {
          const rect = e.currentTarget.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const section = Math.floor(
            x / rect.width * imageArray.length
          );
          const newIndex = Math.min(section, imageArray.length - 1);
          const imgEl = e.currentTarget.querySelector("img");
          const newSrc = imageArray[newIndex];
          if (imgEl && newSrc) {
            const currentSrc = imgEl.src;
            if (currentSrc !== newSrc) {
              imgEl.src = newSrc;
            }
          }
        } : void 0,
        onMouseLeave: !app.isMobile && isArray && imageArray.length > 1 ? (e) => {
          const imgEl = e.currentTarget.querySelector("img");
          const firstSrc = imageArray[0];
          if (imgEl && firstSrc) {
            imgEl.src = firstSrc;
          }
        } : void 0
      },
      /* @__PURE__ */ h(
        "div",
        {
          className: "image-embed",
          style: { "--cover-image-url": `url("${imageArray[0] || ""}")` },
          onClick: (e) => {
            handleImageZoomClick(
              e,
              card.path,
              app,
              zoomCleanupFns,
              zoomedOriginalParents
            );
          }
        },
        /* @__PURE__ */ h(
          "img",
          {
            src: imageArray[0] || "",
            alt: "",
            onLoad: (e) => {
              const imgEl = e.currentTarget;
              const imageEmbedEl = imgEl.parentElement;
              if (imageEmbedEl) {
                const imageEl = imageEmbedEl.parentElement;
                if (imageEl) {
                  const cardEl = imageEl.closest(".card");
                  if (cardEl) {
                    handleImageLoad(
                      imgEl,
                      imageEmbedEl,
                      cardEl,
                      updateLayoutRef.current
                    );
                  }
                }
              }
            }
          }
        )
      )
    ) : /* @__PURE__ */ h("div", { className: "card-thumbnail-placeholder" })),
    (() => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const row1HasContent = settings.propertyLabels !== "hide" ? card.propertyName1 !== void 0 || card.propertyName2 !== void 0 : card.property1 !== null || card.property2 !== null;
      const row2HasContent = settings.propertyLabels !== "hide" ? card.propertyName3 !== void 0 || card.propertyName4 !== void 0 : card.property3 !== null || card.property4 !== null;
      const row3HasContent = settings.propertyLabels !== "hide" ? card.propertyName5 !== void 0 || card.propertyName6 !== void 0 : card.property5 !== null || card.property6 !== null;
      const row4HasContent = settings.propertyLabels !== "hide" ? card.propertyName7 !== void 0 || card.propertyName8 !== void 0 : card.property7 !== null || card.property8 !== null;
      const row5HasContent = settings.propertyLabels !== "hide" ? card.propertyName9 !== void 0 || card.propertyName10 !== void 0 : card.property9 !== null || card.property10 !== null;
      const row6HasContent = settings.propertyLabels !== "hide" ? card.propertyName11 !== void 0 || card.propertyName12 !== void 0 : card.property11 !== null || card.property12 !== null;
      const row7HasContent = settings.propertyLabels !== "hide" ? card.propertyName13 !== void 0 || card.propertyName14 !== void 0 : card.property13 !== null || card.property14 !== null;
      if (!row1HasContent && !row2HasContent && !row3HasContent && !row4HasContent && !row5HasContent && !row6HasContent && !row7HasContent)
        return null;
      const row1 = row1HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-1${settings.propertyLayout12SideBySide ? " property-row-sidebyside" : ""}${card.property1 === null && card.property2 !== null || card.property1 !== null && card.property2 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-1" }, card.propertyName1 && renderPropertyContent(
          card.propertyName1,
          card,
          (_a = card.property1) != null ? _a : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-2" }, card.propertyName2 && renderPropertyContent(
          card.propertyName2,
          card,
          (_b = card.property2) != null ? _b : null,
          timeIcon,
          settings,
          app
        ))
      );
      const row2 = row2HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-2${settings.propertyLayout34SideBySide ? " property-row-sidebyside" : ""}${card.property3 === null && card.property4 !== null || card.property3 !== null && card.property4 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-3" }, card.propertyName3 && renderPropertyContent(
          card.propertyName3,
          card,
          (_c = card.property3) != null ? _c : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-4" }, card.propertyName4 && renderPropertyContent(
          card.propertyName4,
          card,
          (_d = card.property4) != null ? _d : null,
          timeIcon,
          settings,
          app
        ))
      );
      const row3 = row3HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-3${settings.propertyLayout56SideBySide ? " property-row-sidebyside" : ""}${card.property5 === null && card.property6 !== null || card.property5 !== null && card.property6 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-5" }, card.propertyName5 && renderPropertyContent(
          card.propertyName5,
          card,
          (_e = card.property5) != null ? _e : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-6" }, card.propertyName6 && renderPropertyContent(
          card.propertyName6,
          card,
          (_f = card.property6) != null ? _f : null,
          timeIcon,
          settings,
          app
        ))
      );
      const row4 = row4HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-4${settings.propertyLayout78SideBySide ? " property-row-sidebyside" : ""}${card.property7 === null && card.property8 !== null || card.property7 !== null && card.property8 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-7" }, card.propertyName7 && renderPropertyContent(
          card.propertyName7,
          card,
          (_g = card.property7) != null ? _g : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-8" }, card.propertyName8 && renderPropertyContent(
          card.propertyName8,
          card,
          (_h = card.property8) != null ? _h : null,
          timeIcon,
          settings,
          app
        ))
      );
      const row5 = row5HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-5${settings.propertyLayout910SideBySide ? " property-row-sidebyside" : ""}${card.property9 === null && card.property10 !== null || card.property9 !== null && card.property10 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-9" }, card.propertyName9 && renderPropertyContent(
          card.propertyName9,
          card,
          (_i = card.property9) != null ? _i : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-10" }, card.propertyName10 && renderPropertyContent(
          card.propertyName10,
          card,
          (_j = card.property10) != null ? _j : null,
          timeIcon,
          settings,
          app
        ))
      );
      const row6 = row6HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-6${settings.propertyLayout1112SideBySide ? " property-row-sidebyside" : ""}${card.property11 === null && card.property12 !== null || card.property11 !== null && card.property12 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-11" }, card.propertyName11 && renderPropertyContent(
          card.propertyName11,
          card,
          (_k = card.property11) != null ? _k : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-12" }, card.propertyName12 && renderPropertyContent(
          card.propertyName12,
          card,
          (_l = card.property12) != null ? _l : null,
          timeIcon,
          settings,
          app
        ))
      );
      const row7 = row7HasContent && /* @__PURE__ */ h(
        "div",
        {
          className: `property-row property-row-7${settings.propertyLayout1314SideBySide ? " property-row-sidebyside" : ""}${card.property13 === null && card.property14 !== null || card.property13 !== null && card.property14 === null ? " property-row-single" : ""}`
        },
        /* @__PURE__ */ h("div", { className: "property-field property-field-13" }, card.propertyName13 && renderPropertyContent(
          card.propertyName13,
          card,
          (_m = card.property13) != null ? _m : null,
          timeIcon,
          settings,
          app
        )),
        /* @__PURE__ */ h("div", { className: "property-field property-field-14" }, card.propertyName14 && renderPropertyContent(
          card.propertyName14,
          card,
          (_n = card.property14) != null ? _n : null,
          timeIcon,
          settings,
          app
        ))
      );
      const topRows = [];
      const bottomRows = [];
      if (row1) {
        if (settings.propertyGroup1Position === "top")
          topRows.push(row1);
        else
          bottomRows.push(row1);
      }
      if (row2) {
        if (settings.propertyGroup2Position === "top")
          topRows.push(row2);
        else
          bottomRows.push(row2);
      }
      if (row3) {
        if (settings.propertyGroup3Position === "top")
          topRows.push(row3);
        else
          bottomRows.push(row3);
      }
      if (row4) {
        if (settings.propertyGroup4Position === "top")
          topRows.push(row4);
        else
          bottomRows.push(row4);
      }
      if (row5) {
        if (settings.propertyGroup5Position === "top")
          topRows.push(row5);
        else
          bottomRows.push(row5);
      }
      if (row6) {
        if (settings.propertyGroup6Position === "top")
          topRows.push(row6);
        else
          bottomRows.push(row6);
      }
      if (row7) {
        if (settings.propertyGroup7Position === "top")
          topRows.push(row7);
        else
          bottomRows.push(row7);
      }
      return /* @__PURE__ */ h(Fragment, null, topRows.length > 0 && /* @__PURE__ */ h("div", { className: "card-properties card-properties-top properties-4field" }, topRows), bottomRows.length > 0 && /* @__PURE__ */ h("div", { className: "card-properties card-properties-bottom properties-4field" }, bottomRows));
    })()
  );
}
function handleArrowKey(e, currentIndex, viewMode, containerRef, onFocusChange) {
  var _a;
  const cards = Array.from(
    ((_a = containerRef.current) == null ? void 0 : _a.querySelectorAll(".card")) || []
  );
  const currentCard = e.currentTarget;
  const actualIndex = cards.indexOf(currentCard);
  if (actualIndex === -1)
    return;
  const currentRect = currentCard.getBoundingClientRect();
  const currentX = currentRect.left + currentRect.width / 2;
  const currentY = currentRect.top + currentRect.height / 2;
  let targetCard = null;
  let minDistance = Infinity;
  if (viewMode === "masonry") {
    cards.forEach((card, idx) => {
      if (idx === actualIndex)
        return;
      const rect = card.getBoundingClientRect();
      const cardX = rect.left + rect.width / 2;
      const cardY = rect.top + rect.height / 2;
      let isValid = false;
      let distance = 0;
      if (e.key === "ArrowDown" && cardY > currentY) {
        if (rect.left !== currentRect.left)
          return;
        const verticalDist = cardY - currentY;
        const horizontalDist = Math.abs(cardX - currentX);
        distance = verticalDist + horizontalDist * 0.5;
        isValid = true;
      } else if (e.key === "ArrowUp" && cardY < currentY) {
        if (rect.left !== currentRect.left)
          return;
        const verticalDist = currentY - cardY;
        const horizontalDist = Math.abs(cardX - currentX);
        distance = verticalDist + horizontalDist * 0.5;
        isValid = true;
      } else if (e.key === "ArrowRight" && cardX > currentX) {
        const horizontalDist = cardX - currentX;
        const verticalDist = Math.abs(cardY - currentY);
        distance = horizontalDist + verticalDist * 0.5;
        isValid = true;
      } else if (e.key === "ArrowLeft" && cardX < currentX) {
        const horizontalDist = currentX - cardX;
        const verticalDist = Math.abs(cardY - currentY);
        distance = horizontalDist + verticalDist * 0.5;
        isValid = true;
      }
      if (isValid && distance < minDistance) {
        minDistance = distance;
        targetCard = card;
      }
    });
  } else {
    let targetIndex = actualIndex;
    if (e.key === "ArrowDown" || e.key === "ArrowRight") {
      targetIndex = actualIndex + 1;
    } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
      targetIndex = actualIndex - 1;
    }
    if (targetIndex >= 0 && targetIndex < cards.length) {
      targetCard = cards[targetIndex];
    }
  }
  if (targetCard) {
    const targetIndex = cards.indexOf(targetCard);
    if (onFocusChange) {
      onFocusChange(targetIndex);
    }
    targetCard.focus();
    targetCard.scrollIntoView({ block: "nearest", behavior: "smooth" });
  }
}

// src/shared/data-transform.ts
init_property();

// src/shared/render-utils.ts
function formatTimestamp(timestamp, settings, isDateOnly = false) {
  const date = new Date(timestamp);
  if (settings.timestampFormat && settings.timestampFormat.trim()) {
    const moment = require_moment();
    return moment(timestamp).format(settings.timestampFormat);
  }
  const yyyy = date.getFullYear();
  const MM = String(date.getMonth() + 1).padStart(2, "0");
  const dd = String(date.getDate()).padStart(2, "0");
  const HH = String(date.getHours()).padStart(2, "0");
  const mm = String(date.getMinutes()).padStart(2, "0");
  if (isDateOnly) {
    return `${yyyy}-${MM}-${dd}`;
  }
  const styleSettings = (init_style_settings(), __toCommonJS(style_settings_exports));
  const now = Date.now();
  const isRecent = now - timestamp < 864e5;
  if (isRecent) {
    if (styleSettings.shouldShowRecentTimeOnly()) {
      return `${HH}:${mm}`;
    }
    return `${yyyy}-${MM}-${dd} ${HH}:${mm}`;
  }
  if (styleSettings.shouldShowOlderDateOnly()) {
    return `${yyyy}-${MM}-${dd}`;
  }
  return `${yyyy}-${MM}-${dd} ${HH}:${mm}`;
}
function getTimestampIcon(propertyName, settings) {
  if (propertyName === "file.ctime" || propertyName === "created time" || settings.createdTimeProperty && propertyName === settings.createdTimeProperty) {
    return "calendar";
  }
  return "clock";
}
function isDateValue(value) {
  return value !== null && typeof value === "object" && "date" in value && value.date instanceof Date && "time" in value && typeof value.time === "boolean";
}
function extractTimestamp(value) {
  if (isDateValue(value)) {
    return {
      timestamp: value.date.getTime(),
      isDateOnly: value.time === false
    };
  }
  return null;
}

// src/shared/data-transform.ts
function stripTagHashes(tags) {
  return tags.map((tag) => tag.replace(/^#/, ""));
}
function handleTimestampPropertyFallback(propertyName, settings, cardData) {
  const isCustomCreatedTime = settings.createdTimeProperty && propertyName === settings.createdTimeProperty;
  const isCustomModifiedTime = settings.modifiedTimeProperty && propertyName === settings.modifiedTimeProperty;
  if (!isCustomCreatedTime && !isCustomModifiedTime) {
    return null;
  }
  if (settings.fallbackToFileMetadata) {
    const timestamp = isCustomCreatedTime ? cardData.ctime : cardData.mtime;
    return formatTimestamp(timestamp, settings);
  } else {
    return "...";
  }
}
function resolveSubtitleToPlainText(subtitleValue, settings, cardData) {
  if (!subtitleValue)
    return void 0;
  if (subtitleValue === "tags") {
    const isYamlOnly = settings.subtitleProperty === "tags" || settings.subtitleProperty === "note.tags";
    const tags = isYamlOnly ? cardData.yamlTags : cardData.tags;
    return tags.length > 0 ? tags.join(", ") : void 0;
  }
  if (subtitleValue.startsWith('{"type":"array"')) {
    try {
      const parsed = JSON.parse(subtitleValue);
      if (parsed.type === "array")
        return parsed.items.join(", ");
    } catch (e) {
    }
  }
  return subtitleValue || void 0;
}
function applySmartTimestamp(props, sortMethod, settings) {
  if (!settings.smartTimestamp) {
    return props;
  }
  const sortingByCtime = sortMethod.includes("ctime");
  const sortingByMtime = sortMethod.includes("mtime");
  if (!sortingByCtime && !sortingByMtime) {
    return props;
  }
  const hasCtimeProperty = props.some(
    (p) => p === "file.ctime" || p === "created time" || settings.createdTimeProperty && p === settings.createdTimeProperty
  );
  const hasMtimeProperty = props.some(
    (p) => p === "file.mtime" || p === "modified time" || settings.modifiedTimeProperty && p === settings.modifiedTimeProperty
  );
  if (hasCtimeProperty && hasMtimeProperty) {
    return props;
  }
  const targetProperty = sortingByCtime ? settings.createdTimeProperty || "file.ctime" : settings.modifiedTimeProperty || "file.mtime";
  const propertiesToReplace = sortingByCtime ? ["file.mtime", "modified time", settings.modifiedTimeProperty].filter(
    Boolean
  ) : ["file.ctime", "created time", settings.createdTimeProperty].filter(
    Boolean
  );
  const result = props.map((prop) => {
    if (propertiesToReplace.includes(prop)) {
      return targetProperty;
    }
    return prop;
  });
  return result;
}
function datacoreResultToCardData(result, dc, settings, sortMethod, isShuffled, snippet, imageUrl, hasImageAvailable) {
  var _a, _b, _c, _d;
  let rawTitle = getFirstDatacorePropertyValue(result, settings.titleProperty);
  if (Array.isArray(rawTitle))
    rawTitle = rawTitle[0];
  const title = dc.coerce.string(rawTitle || result.$name || "");
  const path = result.$path || "";
  const folderPath = path.split("/").slice(0, -1).join("/");
  const yamlTagsRaw = result.value("tags");
  const yamlTags = Array.isArray(yamlTagsRaw) ? yamlTagsRaw : [];
  const tags = result.$tags || [];
  const ctime = ((_b = (_a = result.$ctime) == null ? void 0 : _a.toMillis) == null ? void 0 : _b.call(_a)) || 0;
  const mtime = ((_d = (_c = result.$mtime) == null ? void 0 : _c.toMillis) == null ? void 0 : _d.call(_c)) || 0;
  const cardData = {
    path,
    name: result.$name || "",
    title,
    tags,
    yamlTags,
    ctime,
    mtime,
    folderPath,
    snippet,
    imageUrl,
    hasImageAvailable: hasImageAvailable || false
  };
  let props = [
    settings.propertyDisplay1,
    settings.propertyDisplay2,
    settings.propertyDisplay3,
    settings.propertyDisplay4,
    settings.propertyDisplay5,
    settings.propertyDisplay6,
    settings.propertyDisplay7,
    settings.propertyDisplay8,
    settings.propertyDisplay9,
    settings.propertyDisplay10,
    settings.propertyDisplay11,
    settings.propertyDisplay12,
    settings.propertyDisplay13,
    settings.propertyDisplay14
  ];
  props = applySmartTimestamp(props, sortMethod, settings);
  const seen = /* @__PURE__ */ new Set();
  const effectiveProps = props.map((prop) => {
    if (!prop || prop === "")
      return "";
    if (seen.has(prop))
      return "";
    seen.add(prop);
    return prop;
  });
  for (let i = 0; i < 14; i++) {
    const propName = `propertyName${i + 1}`;
    const propValue = `property${i + 1}`;
    cardData[propName] = effectiveProps[i] || void 0;
    cardData[propValue] = effectiveProps[i] ? resolveDatacoreProperty(
      effectiveProps[i],
      result,
      cardData,
      settings,
      dc
    ) : null;
  }
  if (settings.subtitleProperty) {
    const subtitleProps = settings.subtitleProperty.split(",").map((p) => p.trim()).filter((p) => p);
    for (const prop of subtitleProps) {
      const resolved = resolveDatacoreProperty(
        prop,
        result,
        cardData,
        settings,
        dc
      );
      if (resolved !== null && resolved !== "") {
        cardData.subtitle = resolveSubtitleToPlainText(
          resolved,
          settings,
          cardData
        );
        break;
      }
    }
  }
  if (settings.urlProperty) {
    const urlValue = getFirstDatacorePropertyValue(
      result,
      settings.urlProperty
    );
    if (urlValue !== null && typeof urlValue === "string") {
      const { isValidUri: isValidUri2 } = (init_property(), __toCommonJS(property_exports));
      cardData.urlValue = urlValue;
      cardData.hasValidUrl = isValidUri2(urlValue);
    }
  }
  return cardData;
}
function basesEntryToCardData(app, entry, settings, sortMethod, isShuffled, snippet, imageUrl, hasImageAvailable) {
  const fileName = entry.file.basename || entry.file.name;
  const titleValue = getFirstBasesPropertyValue(
    app,
    entry,
    settings.titleProperty
  );
  const titleData = titleValue == null ? void 0 : titleValue.data;
  const title = titleData != null && titleData !== "" && (typeof titleData === "string" || typeof titleData === "number") ? String(titleData) : fileName;
  const path = entry.file.path;
  const folderPath = path.split("/").slice(0, -1).join("/");
  const yamlTagsValue = entry.getValue("note.tags");
  let yamlTags = [];
  if (yamlTagsValue && yamlTagsValue.data != null) {
    const tagData = yamlTagsValue.data;
    const rawTags = Array.isArray(tagData) ? tagData.map((t) => {
      if (t && typeof t === "object" && "data" in t) {
        return String(t.data);
      }
      return typeof t === "string" || typeof t === "number" ? String(t) : "";
    }).filter((t) => t) : typeof tagData === "string" || typeof tagData === "number" ? [String(tagData)] : [];
    yamlTags = stripTagHashes(rawTags);
  }
  const allTagsValue = entry.getValue("file.tags");
  let tags = [];
  if (allTagsValue && allTagsValue.data != null) {
    const tagData = allTagsValue.data;
    const rawTags = Array.isArray(tagData) ? tagData.map((t) => {
      if (t && typeof t === "object" && "data" in t) {
        return String(t.data);
      }
      return typeof t === "string" || typeof t === "number" ? String(t) : "";
    }).filter((t) => t) : typeof tagData === "string" || typeof tagData === "number" ? [String(tagData)] : [];
    tags = stripTagHashes(rawTags);
  }
  const ctime = entry.file.stat.ctime;
  const mtime = entry.file.stat.mtime;
  const cardData = {
    path,
    name: fileName,
    title,
    tags,
    yamlTags,
    ctime,
    mtime,
    folderPath,
    snippet,
    imageUrl,
    hasImageAvailable: hasImageAvailable || false
  };
  let props = [
    settings.propertyDisplay1,
    settings.propertyDisplay2,
    settings.propertyDisplay3,
    settings.propertyDisplay4,
    settings.propertyDisplay5,
    settings.propertyDisplay6,
    settings.propertyDisplay7,
    settings.propertyDisplay8,
    settings.propertyDisplay9,
    settings.propertyDisplay10,
    settings.propertyDisplay11,
    settings.propertyDisplay12,
    settings.propertyDisplay13,
    settings.propertyDisplay14
  ];
  props = applySmartTimestamp(props, sortMethod, settings);
  const seen = /* @__PURE__ */ new Set();
  const effectiveProps = props.map((prop) => {
    if (!prop || prop === "")
      return "";
    if (seen.has(prop))
      return "";
    seen.add(prop);
    return prop;
  });
  for (let i = 0; i < 14; i++) {
    const propName = `propertyName${i + 1}`;
    const propValue = `property${i + 1}`;
    cardData[propName] = effectiveProps[i] || void 0;
    cardData[propValue] = effectiveProps[i] ? resolveBasesProperty(
      app,
      effectiveProps[i],
      entry,
      cardData,
      settings
    ) : null;
  }
  if (settings.subtitleProperty) {
    const subtitleProps = settings.subtitleProperty.split(",").map((p) => p.trim()).filter((p) => p);
    for (const prop of subtitleProps) {
      const resolved = resolveBasesProperty(
        app,
        prop,
        entry,
        cardData,
        settings
      );
      if (resolved !== null && resolved !== "") {
        cardData.subtitle = resolveSubtitleToPlainText(
          resolved,
          settings,
          cardData
        );
        break;
      }
    }
  }
  if (settings.urlProperty) {
    const urlValue = getFirstBasesPropertyValue(
      app,
      entry,
      settings.urlProperty
    );
    if (urlValue && typeof urlValue === "object" && "data" in urlValue && typeof urlValue.data === "string") {
      const { isValidUri: isValidUri2 } = (init_property(), __toCommonJS(property_exports));
      cardData.urlValue = urlValue.data;
      cardData.hasValidUrl = isValidUri2(urlValue.data);
    }
  }
  return cardData;
}
function transformDatacoreResults(results, dc, settings, sortMethod, isShuffled, snippets, images, hasImageAvailable) {
  return results.filter((p) => p.$path).map(
    (p) => datacoreResultToCardData(
      p,
      dc,
      settings,
      sortMethod,
      isShuffled,
      snippets[p.$path],
      images[p.$path],
      hasImageAvailable[p.$path]
    )
  );
}
function transformBasesEntries(app, entries, settings, sortMethod, isShuffled, snippets, images, hasImageAvailable) {
  return entries.map(
    (entry) => basesEntryToCardData(
      app,
      entry,
      settings,
      sortMethod,
      isShuffled,
      snippets[entry.file.path],
      images[entry.file.path],
      hasImageAvailable[entry.file.path]
    )
  );
}
function resolveBasesProperty(app, propertyName, entry, cardData, settings) {
  if (!propertyName || propertyName === "") {
    return null;
  }
  if (propertyName === "file.path" || propertyName === "file path") {
    const path = cardData.folderPath;
    if (!path || path === "") {
      return null;
    }
    return path;
  }
  if (propertyName === "tags" || propertyName === "note.tags") {
    return cardData.yamlTags.length > 0 ? "tags" : null;
  }
  if (propertyName === "file.tags" || propertyName === "file tags") {
    return cardData.tags.length > 0 ? "tags" : null;
  }
  if (propertyName === "file.ctime" || propertyName === "created time") {
    const formatted = formatTimestamp(cardData.ctime, settings);
    return formatted;
  }
  if (propertyName === "file.mtime" || propertyName === "modified time") {
    const formatted = formatTimestamp(cardData.mtime, settings);
    return formatted;
  }
  const value = getFirstBasesPropertyValue(app, entry, propertyName);
  if (!value) {
    const fallback = handleTimestampPropertyFallback(
      propertyName,
      settings,
      cardData
    );
    if (fallback !== null)
      return fallback;
    return null;
  }
  const timestampData = extractTimestamp(value);
  if (timestampData) {
    const formatted = formatTimestamp(
      timestampData.timestamp,
      settings,
      timestampData.isDateOnly
    );
    return formatted;
  }
  const data = value == null ? void 0 : value.data;
  if (data == null || data === "" || Array.isArray(data) && data.length === 0) {
    const fallback = handleTimestampPropertyFallback(
      propertyName,
      settings,
      cardData
    );
    if (fallback !== null)
      return fallback;
    return "";
  }
  if (typeof data === "string" || typeof data === "number" || typeof data === "boolean") {
    const result = String(data);
    if (typeof data === "string" && result.trim() === "") {
      return "";
    }
    const valueObj = value;
    if (typeof data === "string" && (valueObj.sourcePath !== void 0 || valueObj.display !== void 0)) {
      return `[[${result}]]`;
    }
    return result;
  }
  if (Array.isArray(data)) {
    const stringElements = data.map((item) => {
      if (item && typeof item === "object" && "data" in item) {
        const nestedData = item.data;
        if (nestedData == null || nestedData === "")
          return null;
        if (typeof nestedData === "string" || typeof nestedData === "number" || typeof nestedData === "boolean") {
          return String(nestedData);
        }
        if (typeof nestedData === "object" && nestedData !== null) {
          if ("path" in nestedData) {
            const pathValue = nestedData.path;
            if (typeof pathValue === "string" && pathValue.trim() !== "") {
              return `[[${pathValue}]]`;
            }
          }
          if ("link" in nestedData) {
            const linkValue = nestedData.link;
            if (typeof linkValue === "string" && linkValue.trim() !== "") {
              return `[[${linkValue}]]`;
            }
          }
        }
        return null;
      }
      if (item == null || item === "")
        return null;
      if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
        return String(item);
      }
      if (typeof item === "object") {
        if ("path" in item) {
          const pathValue = item.path;
          if (typeof pathValue === "string" && pathValue.trim() !== "") {
            return `[[${pathValue}]]`;
          }
        }
        if ("link" in item) {
          const linkValue = item.link;
          if (typeof linkValue === "string" && linkValue.trim() !== "") {
            return `[[${linkValue}]]`;
          }
        }
      }
      return null;
    }).filter((s) => s !== null);
    if (stringElements.length === 0) {
      return null;
    }
    return JSON.stringify({ type: "array", items: stringElements });
  }
  if (typeof data === "object" && data !== null) {
    if ("path" in data) {
      const pathValue = data.path;
      if (typeof pathValue === "string" && pathValue.trim() !== "") {
        return `[[${pathValue}]]`;
      }
    }
    if ("link" in data) {
      const linkValue = data.link;
      if (typeof linkValue === "string" && linkValue.trim() !== "") {
        return `[[${linkValue}]]`;
      }
    }
  }
  return null;
}
function resolveDatacoreProperty(propertyName, result, cardData, settings, dc) {
  if (!propertyName || propertyName === "")
    return null;
  if (propertyName === "file.path" || propertyName === "file path") {
    const path = cardData.folderPath;
    if (!path || path === "")
      return null;
    return path;
  }
  if (propertyName === "tags") {
    return cardData.yamlTags.length > 0 ? "tags" : null;
  }
  if (propertyName === "file.tags" || propertyName === "file tags") {
    return cardData.tags.length > 0 ? "tags" : null;
  }
  if (propertyName === "file.ctime" || propertyName === "created time") {
    return formatTimestamp(cardData.ctime, settings);
  }
  if (propertyName === "file.mtime" || propertyName === "modified time") {
    return formatTimestamp(cardData.mtime, settings);
  }
  const rawValue = getFirstDatacorePropertyValue(result, propertyName);
  if (Array.isArray(rawValue)) {
    const firstElement = rawValue[0];
    const timestampData2 = extractTimestamp(firstElement);
    if (timestampData2) {
      return formatTimestamp(
        timestampData2.timestamp,
        settings,
        timestampData2.isDateOnly
      );
    }
    const stringElements = rawValue.map((item) => {
      if (typeof item === "object" && item !== null && "path" in item) {
        const pathValue = item.path;
        if (typeof pathValue === "string" && pathValue.trim() !== "") {
          return pathValue;
        }
      }
      const str = dc.coerce.string(item);
      return str && str.trim() !== "" ? str : null;
    }).filter((s) => s !== null);
    if (stringElements.length === 0) {
      return null;
    }
    return JSON.stringify({ type: "array", items: stringElements });
  }
  const timestampData = extractTimestamp(rawValue);
  if (timestampData) {
    return formatTimestamp(
      timestampData.timestamp,
      settings,
      timestampData.isDateOnly
    );
  }
  if (rawValue === null || rawValue === void 0) {
    const isCustomCreatedTime = settings.createdTimeProperty && propertyName === settings.createdTimeProperty;
    const isCustomModifiedTime = settings.modifiedTimeProperty && propertyName === settings.modifiedTimeProperty;
    if (isCustomCreatedTime || isCustomModifiedTime) {
      if (settings.fallbackToFileMetadata) {
        const timestamp = isCustomCreatedTime ? cardData.ctime : cardData.mtime;
        return formatTimestamp(timestamp, settings);
      } else {
        return "...";
      }
    }
    return null;
  }
  if (typeof rawValue === "object" && rawValue !== null && "path" in rawValue) {
    const pathValue = rawValue.path;
    if (typeof pathValue === "string" && pathValue.trim() !== "") {
      return `[[${pathValue}]]`;
    }
  }
  const value = dc.coerce.string(rawValue);
  if (!value || value.trim() === "") {
    const fallback = handleTimestampPropertyFallback(
      propertyName,
      settings,
      cardData
    );
    if (fallback !== null)
      return fallback;
    return "";
  }
  return value;
}

// src/components/card-view.tsx
function CardView({
  results,
  displayedCount,
  settings,
  viewMode,
  sortMethod,
  isShuffled,
  snippets,
  images,
  hasImageAvailable,
  focusableCardIndex,
  containerRef,
  updateLayoutRef,
  app,
  dc,
  onCardClick,
  onFocusChange
}) {
  const allCards = transformDatacoreResults(
    results,
    dc,
    settings,
    sortMethod,
    isShuffled,
    snippets,
    images,
    hasImageAvailable
  );
  const cards = allCards.slice(0, displayedCount);
  return /* @__PURE__ */ h(
    CardRenderer,
    {
      cards,
      settings,
      viewMode,
      sortMethod,
      isShuffled,
      focusableCardIndex,
      containerRef,
      updateLayoutRef,
      app,
      onCardClick,
      onFocusChange
    }
  );
}

// src/components/masonry-view.tsx
function MasonryView(props) {
  return /* @__PURE__ */ h(CardView, { ...props, viewMode: "masonry" });
}

// src/components/list-view.tsx
init_property();
function ListView({
  results,
  displayedCount,
  settings,
  containerRef,
  app,
  dc,
  onLinkClick
}) {
  return /* @__PURE__ */ h(
    "ul",
    {
      ref: containerRef,
      className: `list-view marker-${settings.listMarker}`,
      style: settings.queryHeight > 0 ? { maxHeight: `${settings.queryHeight}px`, overflowY: "auto" } : {}
    },
    results.slice(0, displayedCount).filter((p) => p.$path).map((p, index) => {
      let rawTitle = getFirstDatacorePropertyValue(
        p,
        settings.titleProperty
      );
      if (Array.isArray(rawTitle))
        rawTitle = rawTitle[0];
      const titleValue = dc.coerce.string(rawTitle || p.$name);
      return /* @__PURE__ */ h("li", { key: p.$path, className: "list-item" }, /* @__PURE__ */ h(
        "a",
        {
          href: p.$path,
          className: "internal-link list-link",
          onClick: (e) => {
            if (!e.metaKey && !e.ctrlKey && !e.shiftKey && p.$path) {
              e.preventDefault();
              if (onLinkClick) {
                onLinkClick(p.$path, false);
              } else {
                void app.workspace.openLinkText(p.$path, "", false);
              }
            }
          },
          onMouseEnter: (e) => {
            if (p.$path) {
              app.workspace.trigger("hover-link", {
                event: e,
                source: "dynamic-views",
                hoverParent: e.currentTarget,
                targetEl: e.currentTarget,
                linktext: p.$path,
                sourcePath: p.$path
              });
            }
          }
        },
        titleValue
      ), (() => {
        const card = datacoreResultToCardData(
          p,
          dc,
          settings,
          "mtime-desc",
          false
        );
        const hasProperties = card.property1 || card.property2 || card.property3 || card.property4;
        if (!hasProperties)
          return null;
        return /* @__PURE__ */ h("span", { className: "list-meta" }, card.property1 === "tags" && p.$tags && p.$tags.length > 0 ? /* @__PURE__ */ h(Fragment, null, p.$tags.map(
          (tag) => /* @__PURE__ */ h(
            "a",
            {
              key: tag,
              href: "#",
              className: "tag",
              onClick: (e) => {
                var _a;
                e.preventDefault();
                const searchPlugin = app.internalPlugins.plugins["global-search"];
                if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
                  searchPlugin.instance.openGlobalSearch(
                    "tag:" + tag
                  );
                }
              }
            },
            tag.replace(/^#/, "")
          )
        )) : card.property1 ? /* @__PURE__ */ h("span", { className: "list-text" }, card.property1) : null, card.property2 === "tags" && p.$tags && p.$tags.length > 0 ? /* @__PURE__ */ h(Fragment, null, p.$tags.map(
          (tag) => /* @__PURE__ */ h(
            "a",
            {
              key: tag,
              href: "#",
              className: "tag",
              onClick: (e) => {
                var _a;
                e.preventDefault();
                const searchPlugin = app.internalPlugins.plugins["global-search"];
                if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
                  searchPlugin.instance.openGlobalSearch(
                    "tag:" + tag
                  );
                }
              }
            },
            tag.replace(/^#/, "")
          )
        )) : card.property2 ? /* @__PURE__ */ h("span", { className: "list-text" }, card.property2) : null, card.property3 === "tags" && p.$tags && p.$tags.length > 0 ? /* @__PURE__ */ h(Fragment, null, p.$tags.map(
          (tag) => /* @__PURE__ */ h(
            "a",
            {
              key: tag,
              href: "#",
              className: "tag",
              onClick: (e) => {
                var _a;
                e.preventDefault();
                const searchPlugin = app.internalPlugins.plugins["global-search"];
                if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
                  searchPlugin.instance.openGlobalSearch(
                    "tag:" + tag
                  );
                }
              }
            },
            tag.replace(/^#/, "")
          )
        )) : card.property3 ? /* @__PURE__ */ h("span", { className: "list-text" }, card.property3) : null, card.property4 === "tags" && p.$tags && p.$tags.length > 0 ? /* @__PURE__ */ h(Fragment, null, p.$tags.map(
          (tag) => /* @__PURE__ */ h(
            "a",
            {
              key: tag,
              href: "#",
              className: "tag",
              onClick: (e) => {
                var _a;
                e.preventDefault();
                const searchPlugin = app.internalPlugins.plugins["global-search"];
                if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
                  searchPlugin.instance.openGlobalSearch(
                    "tag:" + tag
                  );
                }
              }
            },
            tag.replace(/^#/, "")
          )
        )) : card.property4 ? /* @__PURE__ */ h("span", { className: "list-text" }, card.property4) : null);
      })());
    })
  );
}

// src/components/settings.tsx
init_property();
function Settings({
  dc,
  app,
  settings,
  onSettingsChange,
  menuRef
}) {
  const allProperties = getAllVaultProperties(app);
  return /* @__PURE__ */ h("div", { ref: menuRef, className: "settings-dropdown-menu" }, /* @__PURE__ */ h("div", { className: "setting-item" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Card size"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Minimum width of cards in pixels")), /* @__PURE__ */ h("div", { style: { display: "flex", alignItems: "center", gap: "8px" } }, /* @__PURE__ */ h(
    "input",
    {
      type: "range",
      min: "50",
      max: "800",
      step: "10",
      value: settings.cardSize,
      "aria-label": String(settings.cardSize),
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ cardSize: parseInt(evt.target.value) });
      },
      style: { flex: 1 }
    }
  ))), /* @__PURE__ */ h("div", { className: "setting-item setting-item-toggle" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Show title"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Display note title on cards")), /* @__PURE__ */ h(
    "div",
    {
      className: `checkbox-container ${settings.showTitle ? "is-enabled" : ""}`,
      onClick: () => onSettingsChange({ showTitle: !settings.showTitle }),
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSettingsChange({ showTitle: !settings.showTitle });
        }
      },
      tabIndex: 0,
      role: "checkbox",
      "aria-checked": settings.showTitle
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Title property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show as card title")), /* @__PURE__ */ h(
    "input",
    {
      type: "text",
      value: settings.titleProperty,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ titleProperty: evt.target.value });
      },
      placeholder: "Comma-separated if multiple",
      className: "setting-text-input"
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-toggle" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Show text preview"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Display note excerpts")), /* @__PURE__ */ h(
    "div",
    {
      className: `checkbox-container ${settings.showTextPreview ? "is-enabled" : ""}`,
      onClick: () => onSettingsChange({ showTextPreview: !settings.showTextPreview }),
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSettingsChange({ showTextPreview: !settings.showTextPreview });
        }
      },
      tabIndex: 0,
      role: "checkbox",
      "aria-checked": settings.showTextPreview
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Text preview property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show as text preview")), /* @__PURE__ */ h(
    "input",
    {
      type: "text",
      value: settings.descriptionProperty,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ descriptionProperty: evt.target.value });
      },
      placeholder: "Comma-separated if multiple",
      className: "setting-text-input"
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-toggle" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Use note content if text preview property missing or empty"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Fall back to note content when text preview property is not set or empty")), /* @__PURE__ */ h(
    "div",
    {
      className: `checkbox-container ${settings.fallbackToContent ? "is-enabled" : ""}`,
      onClick: () => onSettingsChange({ fallbackToContent: !settings.fallbackToContent }),
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSettingsChange({
            fallbackToContent: !settings.fallbackToContent
          });
        }
      },
      tabIndex: 0,
      role: "checkbox",
      "aria-checked": settings.fallbackToContent
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-dropdown" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Image format"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Display first image embed in note (wikilink or markdown format), or first value of image property")), /* @__PURE__ */ h(
    "select",
    {
      value: (() => {
        const imageFormatParts = settings.imageFormat.split("-");
        return settings.imageFormat === "none" ? "none" : imageFormatParts[0];
      })(),
      onChange: (e) => {
        const evt = e;
        const newFormat = evt.target.value;
        if (newFormat === "none") {
          onSettingsChange({ imageFormat: "none" });
        } else {
          const currentPosition = settings.imageFormat === "none" ? "right" : settings.imageFormat.split("-")[1] || "right";
          onSettingsChange({
            imageFormat: `${newFormat}-${currentPosition}`
          });
        }
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "thumbnail" }, "Thumbnail"),
    /* @__PURE__ */ h("option", { value: "cover" }, "Cover"),
    /* @__PURE__ */ h("option", { value: "none" }, "None")
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-dropdown" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Image position"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Position of the image within the card")), /* @__PURE__ */ h(
    "select",
    {
      value: (() => {
        const position = settings.imageFormat.split("-")[1];
        return position || "right";
      })(),
      onChange: (e) => {
        const evt = e;
        const currentFormat = settings.imageFormat.split("-")[0];
        onSettingsChange({
          imageFormat: `${currentFormat}-${evt.target.value}`
        });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "left" }, "Left"),
    /* @__PURE__ */ h("option", { value: "right" }, "Right"),
    /* @__PURE__ */ h("option", { value: "top" }, "Top"),
    /* @__PURE__ */ h("option", { value: "bottom" }, "Bottom")
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Image property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show as image")), /* @__PURE__ */ h(
    "input",
    {
      type: "text",
      value: settings.imageProperty,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ imageProperty: evt.target.value });
      },
      placeholder: "Comma-separated if multiple",
      className: "setting-text-input"
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-dropdown" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Show image embeds"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Control when in-note image embeds are shown alongside image property values")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.fallbackToEmbeds,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({
          fallbackToEmbeds: evt.target.value
        });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "always" }, "Always"),
    /* @__PURE__ */ h("option", { value: "if-empty" }, "If property missing or empty"),
    /* @__PURE__ */ h("option", { value: "never" }, "Never")
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-dropdown" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Image fit"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "How cover images are displayed (crop fills container, contain shows full image)")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.coverFitMode,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({
          coverFitMode: evt.target.value
        });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "crop" }, "Crop"),
    /* @__PURE__ */ h("option", { value: "contain" }, "Contain")
  )), /* @__PURE__ */ h("div", { className: "setting-item" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Image ratio"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Aspect ratio of images")), /* @__PURE__ */ h("div", { style: { display: "flex", alignItems: "center", gap: "8px" } }, /* @__PURE__ */ h(
    "input",
    {
      type: "range",
      min: "0.25",
      max: "2.5",
      step: "0.05",
      value: settings.imageAspectRatio,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({
          imageAspectRatio: parseFloat(evt.target.value)
        });
      },
      style: { flex: 1 }
    }
  ), /* @__PURE__ */ h("span", { style: { minWidth: "40px" } }, settings.imageAspectRatio.toFixed(2)))), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "First property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show in first position")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.propertyDisplay1,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ propertyDisplay1: evt.target.value });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "" }, "None"),
    allProperties.map(
      (prop) => /* @__PURE__ */ h("option", { key: prop, value: prop }, prop)
    )
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Second property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show in second position")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.propertyDisplay2,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ propertyDisplay2: evt.target.value });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "" }, "None"),
    allProperties.map(
      (prop) => /* @__PURE__ */ h("option", { key: prop, value: prop }, prop)
    )
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-toggle" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Pair first and second properties"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Display first two properties horizontally")), /* @__PURE__ */ h(
    "div",
    {
      className: `checkbox-container ${settings.propertyLayout12SideBySide ? "is-enabled" : ""}`,
      onClick: () => onSettingsChange({
        propertyLayout12SideBySide: !settings.propertyLayout12SideBySide
      }),
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSettingsChange({
            propertyLayout12SideBySide: !settings.propertyLayout12SideBySide
          });
        }
      },
      tabIndex: 0,
      role: "checkbox",
      "aria-checked": settings.propertyLayout12SideBySide
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Third property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show in third position")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.propertyDisplay3,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ propertyDisplay3: evt.target.value });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "" }, "None"),
    allProperties.map(
      (prop) => /* @__PURE__ */ h("option", { key: prop, value: prop }, prop)
    )
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Fourth property"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Property to show in fourth position")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.propertyDisplay4,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({ propertyDisplay4: evt.target.value });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "" }, "None"),
    allProperties.map(
      (prop) => /* @__PURE__ */ h("option", { key: prop, value: prop }, prop)
    )
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-toggle" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Pair third and fourth properties"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Display third and fourth properties horizontally")), /* @__PURE__ */ h(
    "div",
    {
      className: `checkbox-container ${settings.propertyLayout34SideBySide ? "is-enabled" : ""}`,
      onClick: () => onSettingsChange({
        propertyLayout34SideBySide: !settings.propertyLayout34SideBySide
      }),
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSettingsChange({
            propertyLayout34SideBySide: !settings.propertyLayout34SideBySide
          });
        }
      },
      tabIndex: 0,
      role: "checkbox",
      "aria-checked": settings.propertyLayout34SideBySide
    }
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-dropdown" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "Show property labels"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Display labels for property values")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.propertyLabels,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({
          propertyLabels: evt.target.value
        });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "inline" }, "Inline"),
    /* @__PURE__ */ h("option", { value: "above" }, "On top"),
    /* @__PURE__ */ h("option", { value: "hide" }, "Hide")
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "List marker"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Marker style for list view")), /* @__PURE__ */ h(
    "select",
    {
      value: settings.listMarker,
      onChange: (e) => {
        const evt = e;
        onSettingsChange({
          listMarker: evt.target.value
        });
      },
      className: "dropdown"
    },
    /* @__PURE__ */ h("option", { value: "bullet" }, "Bullet"),
    /* @__PURE__ */ h("option", { value: "number" }, "Number"),
    /* @__PURE__ */ h("option", { value: "none" }, "None")
  )), /* @__PURE__ */ h("div", { className: "setting-item setting-item-text" }, /* @__PURE__ */ h("div", { className: "setting-item-info" }, /* @__PURE__ */ h("label", null, "View height"), /* @__PURE__ */ h("div", { className: "setting-desc" }, "Maximum height of results area in pixels (0 for unlimited)")), /* @__PURE__ */ h("div", { style: { display: "flex", alignItems: "center", gap: "8px" } }, /* @__PURE__ */ h(
    "button",
    {
      className: "clickable-icon",
      "aria-label": "Restore default",
      onClick: () => onSettingsChange({ queryHeight: 0 })
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        className: "lucide lucide-rotate-ccw"
      },
      /* @__PURE__ */ h("path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }),
      /* @__PURE__ */ h("path", { d: "M3 3v5h5" })
    )
  ), /* @__PURE__ */ h(
    "input",
    {
      type: "number",
      min: "0",
      placeholder: "500",
      value: settings.queryHeight,
      onChange: (e) => {
        const evt = e;
        const val = parseInt(evt.target.value);
        if (!isNaN(val) && val >= 0) {
          onSettingsChange({ queryHeight: val });
        }
      },
      style: { width: "80px" }
    }
  ))));
}

// src/utils/dropdown-position.ts
function positionDropdown(buttonElement, menuElement) {
  const buttonRect = buttonElement.getBoundingClientRect();
  let top = buttonRect.bottom + 4;
  let left = buttonRect.left;
  const menuRect = menuElement.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const EDGE_PADDING = 8;
  if (left + menuRect.width > viewportWidth - EDGE_PADDING) {
    left = Math.max(
      EDGE_PADDING,
      viewportWidth - menuRect.width - EDGE_PADDING
    );
  }
  if (top + menuRect.height > viewportHeight - EDGE_PADDING) {
    const topPosition = buttonRect.top - menuRect.height - 4;
    if (topPosition >= EDGE_PADDING) {
      top = topPosition;
    } else {
      top = EDGE_PADDING;
    }
  }
  menuElement.style.top = `${top}px`;
  menuElement.style.left = `${left}px`;
}
function setupClickOutside(containerElement, onClickOutside) {
  const handleClick = (event) => {
    if (!containerElement.contains(event.target)) {
      onClickOutside();
    }
  };
  setTimeout(() => {
    document.addEventListener("click", handleClick);
  }, 0);
  return () => {
    document.removeEventListener("click", handleClick);
  };
}

// src/components/toolbar.tsx
function Toolbar({
  dc,
  app,
  viewMode,
  showViewDropdown,
  onToggleViewDropdown,
  onSetViewCard,
  onSetViewMasonry,
  onSetViewList,
  sortMethod,
  isShuffled,
  showSortDropdown,
  onToggleSortDropdown,
  onSetSortNameAsc,
  onSetSortNameDesc,
  onSetSortMtimeDesc,
  onSetSortMtimeAsc,
  onSetSortCtimeDesc,
  onSetSortCtimeAsc,
  searchQuery,
  onSearchChange,
  onSearchFocus,
  onClearSearch,
  settings,
  onShuffle,
  onOpenRandom,
  showQueryEditor,
  draftQuery,
  onToggleCode,
  onDraftQueryChange,
  onApplyQuery,
  onClearQuery,
  totalCount,
  displayedCount,
  resultLimit,
  showLimitDropdown,
  onToggleLimitDropdown,
  onResultLimitChange,
  onResetLimit,
  copyMenuItem,
  onCreateNote,
  isPinned,
  widthMode,
  queryHeight,
  onTogglePin,
  onToggleWidth,
  onToggleSettings,
  showSettings,
  onSettingsChange
}) {
  const viewButtonRef = dc.useRef(null);
  const viewMenuRef = dc.useRef(null);
  const sortButtonRef = dc.useRef(null);
  const sortMenuRef = dc.useRef(null);
  const limitWrapperRef = dc.useRef(null);
  const limitMenuRef = dc.useRef(null);
  const queryButtonRef = dc.useRef(null);
  const queryMenuRef = dc.useRef(null);
  const settingsButtonRef = dc.useRef(null);
  const settingsMenuRef = dc.useRef(null);
  const settingsWrapperRef = dc.useRef(null);
  dc.useEffect(() => {
    if (showViewDropdown && viewButtonRef.current && viewMenuRef.current) {
      positionDropdown(viewButtonRef.current, viewMenuRef.current);
      return setupClickOutside(viewMenuRef.current, onToggleViewDropdown);
    }
  }, [showViewDropdown, onToggleViewDropdown]);
  dc.useEffect(() => {
    if (showSortDropdown && sortButtonRef.current && sortMenuRef.current) {
      positionDropdown(sortButtonRef.current, sortMenuRef.current);
      return setupClickOutside(sortMenuRef.current, onToggleSortDropdown);
    }
  }, [showSortDropdown, onToggleSortDropdown]);
  dc.useEffect(() => {
    if (showLimitDropdown && limitWrapperRef.current && limitMenuRef.current) {
      positionDropdown(limitWrapperRef.current, limitMenuRef.current);
      return setupClickOutside(limitMenuRef.current, onToggleLimitDropdown);
    }
  }, [showLimitDropdown, onToggleLimitDropdown]);
  dc.useEffect(() => {
    if (showQueryEditor && queryButtonRef.current && queryMenuRef.current) {
      positionDropdown(queryButtonRef.current, queryMenuRef.current);
      return setupClickOutside(queryMenuRef.current, onToggleCode);
    }
  }, [showQueryEditor, onToggleCode]);
  dc.useEffect(() => {
    if (showSettings && settingsButtonRef.current && settingsMenuRef.current) {
      positionDropdown(settingsButtonRef.current, settingsMenuRef.current);
      const settingsWrapper = settingsButtonRef.current.closest(
        ".settings-dropdown-wrapper"
      );
      if (settingsWrapper) {
        return setupClickOutside(
          settingsWrapper,
          onToggleSettings
        );
      }
    }
  }, [showSettings, onToggleSettings]);
  dc.useEffect(() => {
    const handleResize = () => {
      if (showViewDropdown && viewButtonRef.current && viewMenuRef.current) {
        positionDropdown(viewButtonRef.current, viewMenuRef.current);
      }
      if (showSortDropdown && sortButtonRef.current && sortMenuRef.current) {
        positionDropdown(sortButtonRef.current, sortMenuRef.current);
      }
      if (showLimitDropdown && limitWrapperRef.current && limitMenuRef.current) {
        positionDropdown(limitWrapperRef.current, limitMenuRef.current);
      }
      if (showQueryEditor && queryButtonRef.current && queryMenuRef.current) {
        positionDropdown(queryButtonRef.current, queryMenuRef.current);
      }
      if (showSettings && settingsButtonRef.current && settingsMenuRef.current) {
        positionDropdown(settingsButtonRef.current, settingsMenuRef.current);
      }
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [
    showViewDropdown,
    showSortDropdown,
    showLimitDropdown,
    showQueryEditor,
    showSettings
  ]);
  return /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("div", { className: "bottom-controls" }, /* @__PURE__ */ h("div", { className: "view-controls-wrapper" }, /* @__PURE__ */ h("div", { className: "view-dropdown-wrapper" }, /* @__PURE__ */ h(
    "button",
    {
      ref: viewButtonRef,
      className: "view-dropdown-btn",
      onClick: onToggleViewDropdown,
      "aria-label": "Switch view",
      tabIndex: 0
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      viewMode === "list" ? /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("line", { x1: "8", y1: "6", x2: "21", y2: "6" }), /* @__PURE__ */ h("line", { x1: "8", y1: "12", x2: "21", y2: "12" }), /* @__PURE__ */ h("line", { x1: "8", y1: "18", x2: "21", y2: "18" }), /* @__PURE__ */ h("line", { x1: "3", y1: "6", x2: "3.01", y2: "6" }), /* @__PURE__ */ h("line", { x1: "3", y1: "12", x2: "3.01", y2: "12" }), /* @__PURE__ */ h("line", { x1: "3", y1: "18", x2: "3.01", y2: "18" })) : viewMode === "card" ? /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("path", { d: "M12 3v18" }), /* @__PURE__ */ h("path", { d: "M3 12h18" }), /* @__PURE__ */ h("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" })) : /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }), /* @__PURE__ */ h("path", { d: "M3 15h12" }), /* @__PURE__ */ h("path", { d: "M15 3v18" }))
    ),
    /* @__PURE__ */ h(
      "svg",
      {
        className: "chevron",
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m6 9 6 6 6-6" })
    )
  ), showViewDropdown ? /* @__PURE__ */ h("div", { ref: viewMenuRef, className: "view-dropdown-menu" }, /* @__PURE__ */ h(
    "div",
    {
      className: "view-option",
      onClick: onSetViewCard,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetViewCard();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M12 3v18" }),
      /* @__PURE__ */ h("path", { d: "M3 12h18" }),
      /* @__PURE__ */ h("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" })
    ),
    /* @__PURE__ */ h("span", null, "Grid")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "view-option",
      onClick: onSetViewMasonry,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetViewMasonry();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }),
      /* @__PURE__ */ h("path", { d: "M3 15h12" }),
      /* @__PURE__ */ h("path", { d: "M15 3v18" })
    ),
    /* @__PURE__ */ h("span", null, "Masonry")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "view-option",
      onClick: onSetViewList,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetViewList();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("line", { x1: "8", y1: "6", x2: "21", y2: "6" }),
      /* @__PURE__ */ h("line", { x1: "8", y1: "12", x2: "21", y2: "12" }),
      /* @__PURE__ */ h("line", { x1: "8", y1: "18", x2: "21", y2: "18" }),
      /* @__PURE__ */ h("line", { x1: "3", y1: "6", x2: "3.01", y2: "6" }),
      /* @__PURE__ */ h("line", { x1: "3", y1: "12", x2: "3.01", y2: "12" }),
      /* @__PURE__ */ h("line", { x1: "3", y1: "18", x2: "3.01", y2: "18" })
    ),
    /* @__PURE__ */ h("span", null, "List")
  )) : null), /* @__PURE__ */ h("div", { className: "sort-dropdown-wrapper" }, /* @__PURE__ */ h(
    "button",
    {
      ref: sortButtonRef,
      className: "sort-dropdown-btn",
      onClick: onToggleSortDropdown,
      "aria-label": "Change sort order",
      tabIndex: 0
    },
    isShuffled ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m3 8 4-4 4 4" }),
      /* @__PURE__ */ h("path", { d: "M7 4v16" }),
      /* @__PURE__ */ h("path", { d: "M11 12h4" }),
      /* @__PURE__ */ h("path", { d: "M11 16h7" }),
      /* @__PURE__ */ h("path", { d: "M11 20h10" })
    ) : /* @__PURE__ */ h(Fragment, null, sortMethod === "name-asc" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m3 16 4 4 4-4" }),
      /* @__PURE__ */ h("path", { d: "M7 20V4" }),
      /* @__PURE__ */ h("path", { d: "M20 8h-5" }),
      /* @__PURE__ */ h("path", { d: "M15 10V6.5a2.5 2.5 0 0 1 5 0V10" }),
      /* @__PURE__ */ h("path", { d: "M15 14h5l-5 6h5" })
    ) : sortMethod === "name-desc" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m3 8 4-4 4 4" }),
      /* @__PURE__ */ h("path", { d: "M7 4v16" }),
      /* @__PURE__ */ h("path", { d: "M15 4h5l-5 6h5" }),
      /* @__PURE__ */ h("path", { d: "M15 20v-3.5a2.5 2.5 0 0 1 5 0V20" }),
      /* @__PURE__ */ h("path", { d: "M20 20h-5" })
    ) : sortMethod === "mtime-desc" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M12.338 21.994A10 10 0 1 1 21.925 13.227" }),
      /* @__PURE__ */ h("path", { d: "M12 6v6l2 1" }),
      /* @__PURE__ */ h("path", { d: "m14 18 4-4 4 4" }),
      /* @__PURE__ */ h("path", { d: "M18 14v8" })
    ) : sortMethod === "mtime-asc" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M13.228 21.925A10 10 0 1 1 21.994 12.338" }),
      /* @__PURE__ */ h("path", { d: "M12 6v6l1.562.781" }),
      /* @__PURE__ */ h("path", { d: "m14 18 4 4 4-4" }),
      /* @__PURE__ */ h("path", { d: "M18 22v-8" })
    ) : sortMethod === "ctime-desc" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M8 2v4" }),
      /* @__PURE__ */ h("path", { d: "M16 2v4" }),
      /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }),
      /* @__PURE__ */ h("path", { d: "M3 10h18" }),
      /* @__PURE__ */ h("path", { d: "M12 14 8 18" }),
      /* @__PURE__ */ h("path", { d: "M12 14 16 18" })
    ) : sortMethod === "ctime-asc" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M8 2v4" }),
      /* @__PURE__ */ h("path", { d: "M16 2v4" }),
      /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }),
      /* @__PURE__ */ h("path", { d: "M3 10h18" }),
      /* @__PURE__ */ h("path", { d: "M12 18 8 14" }),
      /* @__PURE__ */ h("path", { d: "M12 18 16 14" })
    ) : null),
    /* @__PURE__ */ h(
      "svg",
      {
        className: "chevron",
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m6 9 6 6 6-6" })
    )
  ), showSortDropdown ? /* @__PURE__ */ h("div", { ref: sortMenuRef, className: "sort-dropdown-menu" }, /* @__PURE__ */ h(
    "div",
    {
      className: "sort-option",
      onClick: onSetSortNameAsc,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetSortNameAsc();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m3 16 4 4 4-4" }),
      /* @__PURE__ */ h("path", { d: "M7 20V4" }),
      /* @__PURE__ */ h("path", { d: "M20 8h-5" }),
      /* @__PURE__ */ h("path", { d: "M15 10V6.5a2.5 2.5 0 0 1 5 0V10" }),
      /* @__PURE__ */ h("path", { d: "M15 14h5l-5 6h5" })
    ),
    /* @__PURE__ */ h("span", null, "File name (A to Z)")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "sort-option",
      onClick: onSetSortNameDesc,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetSortNameDesc();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "m3 8 4-4 4 4" }),
      /* @__PURE__ */ h("path", { d: "M7 4v16" }),
      /* @__PURE__ */ h("path", { d: "M15 4h5l-5 6h5" }),
      /* @__PURE__ */ h("path", { d: "M15 20v-3.5a2.5 2.5 0 0 1 5 0V20" }),
      /* @__PURE__ */ h("path", { d: "M20 20h-5" })
    ),
    /* @__PURE__ */ h("span", null, "File name (Z to A)")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "sort-option",
      onClick: onSetSortMtimeDesc,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetSortMtimeDesc();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M12.338 21.994A10 10 0 1 1 21.925 13.227" }),
      /* @__PURE__ */ h("path", { d: "M12 6v6l2 1" }),
      /* @__PURE__ */ h("path", { d: "m14 18 4-4 4 4" }),
      /* @__PURE__ */ h("path", { d: "M18 14v8" })
    ),
    /* @__PURE__ */ h("span", null, "Modified time (new to old)")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "sort-option",
      onClick: onSetSortMtimeAsc,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetSortMtimeAsc();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M13.228 21.925A10 10 0 1 1 21.994 12.338" }),
      /* @__PURE__ */ h("path", { d: "M12 6v6l1.562.781" }),
      /* @__PURE__ */ h("path", { d: "m14 18 4 4 4-4" }),
      /* @__PURE__ */ h("path", { d: "M18 22v-8" })
    ),
    /* @__PURE__ */ h("span", null, "Modified time (old to new)")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "sort-option",
      onClick: onSetSortCtimeDesc,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetSortCtimeDesc();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M8 2v4" }),
      /* @__PURE__ */ h("path", { d: "M16 2v4" }),
      /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }),
      /* @__PURE__ */ h("path", { d: "M3 10h18" }),
      /* @__PURE__ */ h("path", { d: "M12 14 8 18" }),
      /* @__PURE__ */ h("path", { d: "M12 14 16 18" })
    ),
    /* @__PURE__ */ h("span", null, "Created time (new to old)")
  ), /* @__PURE__ */ h(
    "div",
    {
      className: "sort-option",
      onClick: onSetSortCtimeAsc,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onSetSortCtimeAsc();
        }
      },
      tabIndex: 0,
      role: "menuitem"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M8 2v4" }),
      /* @__PURE__ */ h("path", { d: "M16 2v4" }),
      /* @__PURE__ */ h("rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }),
      /* @__PURE__ */ h("path", { d: "M3 10h18" }),
      /* @__PURE__ */ h("path", { d: "M12 18 8 14" }),
      /* @__PURE__ */ h("path", { d: "M12 18 16 14" })
    ),
    /* @__PURE__ */ h("span", null, "Created time (old to new)")
  )) : null)), /* @__PURE__ */ h("div", { className: "search-controls" }, /* @__PURE__ */ h("div", { className: "search-input-container" }, /* @__PURE__ */ h(
    "svg",
    {
      className: "search-input-loupe-icon",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    /* @__PURE__ */ h("circle", { cx: "11", cy: "11", r: "8" }),
    /* @__PURE__ */ h("path", { d: "m21 21-4.35-4.35" })
  ), /* @__PURE__ */ h(
    "input",
    {
      type: "text",
      placeholder: "Filter...",
      value: searchQuery,
      onChange: (e) => {
        const evt = e;
        onSearchChange(evt.target.value);
      },
      onFocus: onSearchFocus,
      className: "search-input desktop-search"
    }
  ), searchQuery ? /* @__PURE__ */ h(
    "svg",
    {
      className: "search-input-clear-button",
      "aria-label": "Clear search",
      onClick: onClearSearch,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onClearSearch();
        }
      },
      tabIndex: 0,
      role: "button",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 16 16"
    },
    /* @__PURE__ */ h("circle", { cx: "8", cy: "8", r: "7", fill: "currentColor" }),
    /* @__PURE__ */ h(
      "line",
      {
        x1: "5",
        y1: "5",
        x2: "11",
        y2: "11",
        stroke: "white",
        strokeWidth: "1.5",
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ h(
      "line",
      {
        x1: "11",
        y1: "5",
        x2: "5",
        y2: "11",
        stroke: "white",
        strokeWidth: "1.5",
        strokeLinecap: "round"
      }
    )
  ) : null)), /* @__PURE__ */ h(
    "div",
    {
      ref: limitWrapperRef,
      className: `results-count-wrapper${showLimitDropdown ? " active" : ""}`,
      onClick: onToggleLimitDropdown,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onToggleLimitDropdown();
        }
      },
      tabIndex: 0,
      role: "button",
      "aria-expanded": showLimitDropdown
    },
    /* @__PURE__ */ h(
      "span",
      {
        className: `results-count${(() => {
          const limit = parseInt(resultLimit);
          return limit > 0 && totalCount > limit ? " limited" : "";
        })()}`
      },
      (() => {
        const limit = parseInt(resultLimit);
        if (limit > 0 && totalCount > limit) {
          return `${limit.toLocaleString()} result${limit === 1 ? "" : "s"}`;
        }
        return `${totalCount.toLocaleString()} result${totalCount === 1 ? "" : "s"}`;
      })()
    ),
    /* @__PURE__ */ h(
      "svg",
      {
        className: "results-count-chevron",
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("polyline", { points: "6 9 12 15 18 9" })
    ),
    showLimitDropdown ? /* @__PURE__ */ h("div", { ref: limitMenuRef, className: "limit-dropdown-menu" }, /* @__PURE__ */ h(
      "div",
      {
        className: "limit-dropdown-label",
        onClick: (e) => {
          const evt = e;
          evt.stopPropagation();
        }
      },
      "Limit number of results"
    ), /* @__PURE__ */ h(
      "input",
      {
        type: "text",
        inputMode: "numeric",
        className: "limit-dropdown-input",
        placeholder: "e.g., 10",
        value: resultLimit,
        onKeyDown: (e) => {
          const evt = e;
          if ([8, 9, 13, 27, 37, 38, 39, 40, 46].includes(evt.keyCode)) {
            return;
          }
          if ((evt.ctrlKey || evt.metaKey) && [65, 67, 86, 88].includes(evt.keyCode)) {
            return;
          }
          if (evt.key < "0" || evt.key > "9" || evt.key === "0" && resultLimit === "") {
            evt.preventDefault();
          }
        },
        onChange: (e) => {
          const evt = e;
          const val = evt.target.value;
          if (val === "" || /^[1-9]\d*$/.test(val)) {
            onResultLimitChange(val);
          }
        }
      }
    ), /* @__PURE__ */ h(
      "div",
      {
        className: `limit-reset-button${!(resultLimit.trim() && parseInt(resultLimit) > 0) ? " disabled" : ""}`,
        onClick: (e) => {
          const evt = e;
          evt.stopPropagation();
          if (resultLimit.trim() && parseInt(resultLimit) > 0) {
            onResetLimit();
          } else {
            onToggleLimitDropdown();
          }
        },
        onKeyDown: (e) => {
          const evt = e;
          if (evt.key === "Enter" || evt.key === " ") {
            evt.preventDefault();
            evt.stopPropagation();
            if (resultLimit.trim() && parseInt(resultLimit) > 0) {
              onResetLimit();
            } else {
              onToggleLimitDropdown();
            }
          }
        },
        tabIndex: 0,
        role: "menuitem"
      },
      /* @__PURE__ */ h("div", { className: "limit-reset-button-icon" }, /* @__PURE__ */ h(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        },
        /* @__PURE__ */ h("path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }),
        /* @__PURE__ */ h("path", { d: "M3 3v5h5" })
      )),
      /* @__PURE__ */ h("div", { className: "limit-reset-button-text" }, resultLimit.trim() && parseInt(resultLimit) > 0 ? `Show all (${totalCount.toLocaleString()})` : "Show all")
    ), copyMenuItem) : null
  ), /* @__PURE__ */ h(
    "button",
    {
      className: "create-note-button",
      tabIndex: 0,
      onClick: (e) => onCreateNote(e),
      "aria-label": "Create new note"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ h("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
    )
  ), /* @__PURE__ */ h("div", { className: "meta-controls" }, /* @__PURE__ */ h(
    "button",
    {
      className: "shuffle-btn",
      onClick: onShuffle,
      "aria-label": "Shuffle",
      tabIndex: 0
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.7-1.1 2-1.7 3.3-1.7H22" }),
      /* @__PURE__ */ h("path", { d: "m18 2 4 4-4 4" }),
      /* @__PURE__ */ h("path", { d: "M2 6h1.9c1.5 0 2.9.9 3.6 2.2" }),
      /* @__PURE__ */ h("path", { d: "M22 18h-5.9c-1.3 0-2.6-.7-3.3-1.8l-.5-.8" }),
      /* @__PURE__ */ h("path", { d: "m18 14 4 4-4 4" })
    )
  ), /* @__PURE__ */ h(
    "button",
    {
      className: "open-random-btn",
      onClick: (e) => onOpenRandom(e),
      "aria-label": "Open random file",
      tabIndex: 0
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M19 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3Z" }),
      /* @__PURE__ */ h("path", { d: "M17 16C17 16.5523 16.5523 17 16 17C15.4477 17 15 16.5523 15 16C15 15.4477 15.4477 15 16 15C16.5523 15 17 15.4477 17 16Z" }),
      /* @__PURE__ */ h("path", { d: "M13 12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12C11 11.4477 11.4477 11 12 11C12.5523 11 13 11.4477 13 12Z" }),
      /* @__PURE__ */ h("path", { d: "M9 8C9 8.55228 8.55228 9 8 9C7.44772 9 7 8.55228 7 8C7 7.44772 7.44772 7 8 7C8.55228 7 9 7.44772 9 8Z" })
    )
  ), /* @__PURE__ */ h("div", { className: "query-dropdown-wrapper" }, /* @__PURE__ */ h(
    "button",
    {
      ref: queryButtonRef,
      className: "query-toggle-btn",
      onClick: onToggleCode,
      "aria-label": showQueryEditor ? "Hide query" : "Edit query",
      tabIndex: 0
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        className: "lucide lucide-code-xml-icon lucide-code-xml"
      },
      /* @__PURE__ */ h("path", { d: "m18 16 4-4-4-4" }),
      /* @__PURE__ */ h("path", { d: "m6 8-4 4 4 4" }),
      /* @__PURE__ */ h("path", { d: "m14.5 4-5 16" })
    )
  ), showQueryEditor ? /* @__PURE__ */ h("div", { ref: queryMenuRef, className: "query-dropdown-menu" }, /* @__PURE__ */ h(
    "textarea",
    {
      value: draftQuery,
      onChange: (e) => {
        const evt = e;
        onDraftQueryChange(evt.target.value);
        evt.target.style.height = "auto";
        evt.target.style.height = evt.target.scrollHeight + "px";
      },
      className: "query-input",
      placeholder: '#tag\npath("path/to/folder")\nkey = "value"',
      ref: (el) => {
        if (el) {
          el.style.height = "auto";
          el.style.height = el.scrollHeight + "px";
        }
      }
    }
  ), /* @__PURE__ */ h("div", { className: "query-footer" }, /* @__PURE__ */ h("div", { className: "query-tip" }, /* @__PURE__ */ h(
    "a",
    {
      href: "https://deepwiki.com/blacksmithgu/datacore/4.1-query-language",
      target: "_blank",
      rel: "noopener noreferrer"
    },
    "Datacore Query Language reference"
  )), /* @__PURE__ */ h(
    "button",
    {
      className: "query-btn query-apply-btn",
      tabIndex: 0,
      onClick: onApplyQuery
    },
    "Apply"
  ), /* @__PURE__ */ h(
    "button",
    {
      className: "query-btn query-clear-btn",
      tabIndex: 0,
      onClick: onClearQuery
    },
    "Clear"
  ))) : null), queryHeight === 0 ? /* @__PURE__ */ h(
    "button",
    {
      className: "pin-btn",
      onClick: onTogglePin,
      "aria-label": isPinned ? "Unpin toolbar" : "Pin toolbar",
      tabIndex: 0
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      isPinned ? /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("path", { d: "M12 17v5" }), /* @__PURE__ */ h("path", { d: "M15 9.34V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H7.89" }), /* @__PURE__ */ h("path", { d: "m2 2 20 20" }), /* @__PURE__ */ h("path", { d: "M9 9v1.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h11" })) : /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("line", { x1: "12", y1: "17", x2: "12", y2: "22" }), /* @__PURE__ */ h("path", { d: "M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z" }))
    )
  ) : null, /* @__PURE__ */ h("div", { ref: settingsWrapperRef, className: "settings-dropdown-wrapper" }, /* @__PURE__ */ h(
    "button",
    {
      ref: settingsButtonRef,
      className: "settings-btn",
      onClick: onToggleSettings,
      "aria-label": "Settings",
      tabIndex: 0
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" }),
      /* @__PURE__ */ h("circle", { cx: "12", cy: "12", r: "3" })
    )
  ), showSettings ? /* @__PURE__ */ h(
    Settings,
    {
      dc,
      app,
      settings,
      onSettingsChange,
      menuRef: settingsMenuRef
    }
  ) : null), /* @__PURE__ */ h(
    "button",
    {
      className: "width-toggle-btn",
      onClick: onToggleWidth,
      "aria-label": widthMode === "max" ? "Shrink width" : "Expand width",
      tabIndex: 0
    },
    widthMode === "max" ? /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M8 3v3a2 2 0 0 1-2 2H3" }),
      /* @__PURE__ */ h("path", { d: "M21 8h-3a2 2 0 0 1-2-2V3" }),
      /* @__PURE__ */ h("path", { d: "M3 16h3a2 2 0 0 1 2 2v3" }),
      /* @__PURE__ */ h("path", { d: "M16 21v-3a2 2 0 0 1 2-2h3" })
    ) : /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("path", { d: "M8 3H5a2 2 0 0 0-2 2v3" }),
      /* @__PURE__ */ h("path", { d: "M21 8V5a2 2 0 0 0-2-2h-3" }),
      /* @__PURE__ */ h("path", { d: "M3 16v3a2 2 0 0 0 2 2h3" }),
      /* @__PURE__ */ h("path", { d: "M16 21h3a2 2 0 0 0 2-2v-3" })
    )
  ))), /* @__PURE__ */ h("div", { className: "search-controls-compact" }, /* @__PURE__ */ h("div", { className: "search-input-container" }, /* @__PURE__ */ h(
    "svg",
    {
      className: "search-input-loupe-icon",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    /* @__PURE__ */ h("circle", { cx: "11", cy: "11", r: "8" }),
    /* @__PURE__ */ h("path", { d: "m21 21-4.35-4.35" })
  ), /* @__PURE__ */ h(
    "input",
    {
      type: "text",
      placeholder: "Filter...",
      value: searchQuery,
      onChange: (e) => {
        const evt = e;
        onSearchChange(evt.target.value);
      },
      onFocus: onSearchFocus,
      className: "search-input desktop-search"
    }
  ), searchQuery ? /* @__PURE__ */ h(
    "svg",
    {
      className: "search-input-clear-button",
      "aria-label": "Clear search",
      onClick: onClearSearch,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onClearSearch();
        }
      },
      tabIndex: 0,
      role: "button",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 16 16"
    },
    /* @__PURE__ */ h("circle", { cx: "8", cy: "8", r: "7", fill: "currentColor" }),
    /* @__PURE__ */ h(
      "line",
      {
        x1: "5",
        y1: "5",
        x2: "11",
        y2: "11",
        stroke: "white",
        strokeWidth: "1.5",
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ h(
      "line",
      {
        x1: "11",
        y1: "5",
        x2: "5",
        y2: "11",
        stroke: "white",
        strokeWidth: "1.5",
        strokeLinecap: "round"
      }
    )
  ) : null), /* @__PURE__ */ h("div", { className: "compact-bottom-row" }, /* @__PURE__ */ h(
    "div",
    {
      className: `results-count-wrapper-compact${showLimitDropdown ? " active" : ""}`,
      onClick: onToggleLimitDropdown,
      onKeyDown: (e) => {
        const evt = e;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          onToggleLimitDropdown();
        }
      },
      tabIndex: 0,
      role: "button",
      "aria-expanded": showLimitDropdown
    },
    /* @__PURE__ */ h(
      "span",
      {
        className: `results-count${(() => {
          const limit = parseInt(resultLimit);
          return limit > 0 && totalCount > limit ? " limited" : "";
        })()}`
      },
      (() => {
        const limit = parseInt(resultLimit);
        if (limit > 0 && totalCount > limit) {
          return `${limit.toLocaleString()} result${limit === 1 ? "" : "s"}`;
        }
        return `${totalCount.toLocaleString()} result${totalCount === 1 ? "" : "s"}`;
      })()
    ),
    /* @__PURE__ */ h(
      "svg",
      {
        className: "results-count-chevron",
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("polyline", { points: "6 9 12 15 18 9" })
    ),
    showLimitDropdown ? /* @__PURE__ */ h("div", { className: "limit-dropdown-menu" }, /* @__PURE__ */ h(
      "div",
      {
        className: "limit-dropdown-label",
        onClick: (e) => {
          const evt = e;
          evt.stopPropagation();
        }
      },
      "Limit number of results"
    ), /* @__PURE__ */ h(
      "input",
      {
        type: "text",
        inputMode: "numeric",
        className: "limit-dropdown-input",
        placeholder: "e.g., 10",
        value: resultLimit,
        onKeyDown: (e) => {
          const evt = e;
          if ([8, 9, 13, 27, 37, 38, 39, 40, 46].includes(evt.keyCode)) {
            return;
          }
          if ((evt.ctrlKey || evt.metaKey) && [65, 67, 86, 88].includes(evt.keyCode)) {
            return;
          }
          if (evt.key < "0" || evt.key > "9" || evt.key === "0" && resultLimit === "") {
            evt.preventDefault();
          }
        },
        onChange: (e) => {
          const evt = e;
          const val = evt.target.value;
          if (val === "" || /^[1-9]\d*$/.test(val)) {
            onResultLimitChange(val);
          }
        }
      }
    ), /* @__PURE__ */ h(
      "div",
      {
        className: `limit-reset-button${!(resultLimit.trim() && parseInt(resultLimit) > 0) ? " disabled" : ""}`,
        onClick: (e) => {
          const evt = e;
          evt.stopPropagation();
          if (resultLimit.trim() && parseInt(resultLimit) > 0) {
            onResetLimit();
          } else {
            onToggleLimitDropdown();
          }
        },
        onKeyDown: (e) => {
          const evt = e;
          if (evt.key === "Enter" || evt.key === " ") {
            evt.preventDefault();
            evt.stopPropagation();
            if (resultLimit.trim() && parseInt(resultLimit) > 0) {
              onResetLimit();
            } else {
              onToggleLimitDropdown();
            }
          }
        },
        tabIndex: 0,
        role: "menuitem"
      },
      /* @__PURE__ */ h("div", { className: "limit-reset-button-icon" }, /* @__PURE__ */ h(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        },
        /* @__PURE__ */ h("path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }),
        /* @__PURE__ */ h("path", { d: "M3 3v5h5" })
      )),
      /* @__PURE__ */ h("div", { className: "limit-reset-button-text" }, resultLimit.trim() && parseInt(resultLimit) > 0 ? `Show all (${totalCount.toLocaleString()})` : "Show all")
    ), copyMenuItem) : null
  ), /* @__PURE__ */ h(
    "button",
    {
      className: "create-note-button-compact",
      tabIndex: 0,
      onClick: (e) => onCreateNote(e),
      "aria-label": "Create new note"
    },
    /* @__PURE__ */ h(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ h("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ h("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
    )
  ))));
}

// src/utils/file.ts
var import_obsidian4 = require("obsidian");
function getFileCtime(file) {
  var _a;
  if (!((_a = file == null ? void 0 : file.stat) == null ? void 0 : _a.ctime))
    return null;
  return file.stat.ctime;
}
function getCurrentFile(app) {
  return app.workspace.getActiveFile();
}
function getAvailablePath(app, folderPath, baseName) {
  const name = baseName.replace(/\.md$/, "");
  let filePath = folderPath ? `${folderPath}/${name}.md` : `${name}.md`;
  filePath = (0, import_obsidian4.normalizePath)(filePath);
  let counter = 1;
  while (app.vault.getFileByPath(filePath)) {
    const unnormalizedPath = folderPath ? `${folderPath}/${name} ${counter}.md` : `${name} ${counter}.md`;
    filePath = (0, import_obsidian4.normalizePath)(unnormalizedPath);
    counter++;
  }
  return filePath;
}

// src/utils/query-sync.ts
function hasPageSelector(query) {
  return /@page\b/i.test(query.trim());
}
function ensurePageSelector(query) {
  const trimmed = query.trim();
  if (!trimmed || hasPageSelector(trimmed)) {
    return trimmed;
  }
  return `@page and (${trimmed})`;
}
function findQueryInBlock(content) {
  const pattern = /\/\/\s*+\s*DQL QUERY START\s*+\s*\n([\s\S]*?)\n\s*\/\/\s*+\s*DQL QUERY END\s*+/;
  const match = content.match(pattern);
  if (!match) {
    return null;
  }
  return {
    query: match[1].trim(),
    fullMatch: match[0],
    startIndex: match.index,
    endIndex: match.index + match[0].length
  };
}
function updateQueryInBlock(content, newQuery) {
  const queryMatch = findQueryInBlock(content);
  if (!queryMatch) {
    console.warn("Could not find DQL QUERY markers");
    return content;
  }
  const { startIndex, endIndex } = queryMatch;
  const replacement = `// \u2013\u2013\u2013\u2013\u2013 DQL QUERY START \u2013\u2013\u2013\u2013\u2013
${newQuery}
// \u2013\u2013\u2013\u2013\u2013 DQL QUERY END \u2013\u2013\u2013\u2013\u2013`;
  return content.substring(0, startIndex) + replacement + content.substring(endIndex);
}

// src/utils/image.ts
var import_obsidian5 = require("obsidian");
var VALID_IMAGE_EXTENSIONS = [
  "avif",
  "bmp",
  "gif",
  "jpeg",
  "jpg",
  "png",
  "svg",
  "webp"
];
function isExternalUrl(url) {
  return /^https?:\/\//i.test(url);
}
function hasValidImageExtension(path) {
  return /\.(avif|bmp|gif|jpe?g|png|svg|webp)$/i.test(path);
}
function validateImageUrl(url) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    setTimeout(() => resolve(false), 5e3);
    img.src = url;
  });
}
function stripWikilinkSyntax(path) {
  if (!path)
    return "";
  const wikilinkMatch = path.match(/^!?\[\[([^\]|]+)(?:\|[^\]]*)?\]\]$/);
  return wikilinkMatch ? wikilinkMatch[1].trim() : path;
}
async function processImagePaths(imagePaths) {
  const internalPaths = [];
  const externalUrls = [];
  for (const imgPath of imagePaths) {
    const cleanPath = stripWikilinkSyntax(imgPath);
    if (cleanPath.length === 0)
      continue;
    if (isExternalUrl(cleanPath)) {
      if (hasValidImageExtension(cleanPath) || !cleanPath.includes(".")) {
        const isValid = await validateImageUrl(cleanPath);
        if (isValid) {
          externalUrls.push(cleanPath);
        }
      }
    } else {
      if (hasValidImageExtension(cleanPath)) {
        internalPaths.push(cleanPath);
      }
    }
  }
  return { internalPaths, externalUrls };
}
function resolveInternalImagePaths(internalPaths, sourcePath, app) {
  const resourcePaths = [];
  for (const propPath of internalPaths) {
    const imageFile = app.metadataCache.getFirstLinkpathDest(
      propPath,
      sourcePath
    );
    if (imageFile && VALID_IMAGE_EXTENSIONS.includes(imageFile.extension)) {
      const resourcePath = app.vault.getResourcePath(imageFile);
      resourcePaths.push(resourcePath);
    }
  }
  return resourcePaths;
}
async function extractEmbedImages(file, app) {
  const metadata = app.metadataCache.getFileCache(file);
  if (!(metadata == null ? void 0 : metadata.embeds))
    return [];
  const bodyResourcePaths = [];
  const bodyExternalUrls = [];
  for (const embed of metadata.embeds) {
    const embedLink = embed.link;
    if (isExternalUrl(embedLink)) {
      if (hasValidImageExtension(embedLink) || !embedLink.includes(".")) {
        bodyExternalUrls.push(embedLink);
      }
    } else {
      const targetFile = app.metadataCache.getFirstLinkpathDest(
        embedLink,
        file.path
      );
      if (targetFile && VALID_IMAGE_EXTENSIONS.includes(targetFile.extension)) {
        const resourcePath = app.vault.getResourcePath(targetFile);
        bodyResourcePaths.push(resourcePath);
      }
    }
  }
  for (const externalUrl of bodyExternalUrls) {
    const isValid = await validateImageUrl(externalUrl);
    if (isValid) {
      bodyResourcePaths.push(externalUrl);
    }
  }
  return bodyResourcePaths;
}

// src/utils/preview.ts
var markdownPatterns = [
  /`([^`]+)`/g,
  // Inline code
  /\*\*\*((?:(?!\*\*\*).)+)\*\*\*/g,
  // Bold + italic asterisks
  /___((?:(?!___).)+)___/g,
  // Bold + italic underscores
  /\*\*((?:(?!\*\*).)+)\*\*/g,
  // Bold asterisks
  /__((?:(?!__).)+)__/g,
  // Bold underscores
  /\*((?:(?!\*).)+)\*/g,
  // Italic asterisks
  /_((?:(?!_).)+)_/g,
  // Italic underscores
  /~~((?:(?!~~).)+)~~/g,
  // Strikethrough (after code blocks processed)
  /==((?:(?!==).)+)==/g,
  // Highlight
  /\[([^\]]+)\]\([^)]+\)/g,
  // Links
  /!\[\[[^\]]+\]\]/g,
  // Embedded wikilinks (images, etc.)
  /\[\[[^\]|]+\|[^\]]+\]\]/g,
  // Wikilinks with display
  /\[\[[^\]]+\]\]/g,
  // Wikilinks
  /#[a-zA-Z0-9_\-/]+/g,
  // Tags
  /^[-*+]\s*\[[ xX]\]\s+/gm,
  // Task list markers (bullet-style)
  /^(\d+\.\s*)\[[ xX]\]\s+/gm,
  // Task list markers (numbered with dot) - preserves number
  /^(\d+\)\s*)\[[ xX]\]\s+/gm,
  // Task list markers (numbered with paren) - preserves number
  /^[-*+]\s+/gm,
  // Bullet list markers
  /^#{1,6}\s+.+$/gm,
  // Heading lines (full removal)
  /^\s*(?:[-_*])\s*(?:[-_*])\s*(?:[-_*])[\s\-_*]*$/gm,
  // Horizontal rules
  /^\s*\|.*\|.*$/gm,
  // Tables
  /\^\[[^\]]*?]/g,
  // Inline footnotes
  /\[\^[^\]]+]/g,
  // Footnote markers
  /^\s*\[\^[^\]]+]:.*$/gm,
  // Footnote details
  /<([a-z][a-z0-9]*)\b[^>]*>(.*?)<\/\1>/gi,
  // HTML tag pairs
  /<[^>]+>/g
  // Remaining HTML tags
];
function protectEscapedChars(text) {
  const map = /* @__PURE__ */ new Map();
  let counter = 0;
  const result = text.replace(/\\(.)/g, (match, char) => {
    const placeholder = `\xA7\xA7ESCAPED${counter}\xA7\xA7`;
    map.set(placeholder, char);
    counter++;
    return placeholder;
  });
  return { text: result, map };
}
function restoreEscapedChars(text, map) {
  let result = text;
  map.forEach((char, placeholder) => {
    result = result.split(placeholder).join(char);
  });
  return result;
}
function removeCodeBlocks(text) {
  let result = text;
  let changed = true;
  while (changed) {
    changed = false;
    const openMatch = result.match(/^([`~]{3,})/m);
    if (!openMatch)
      break;
    const fenceChar = openMatch[1][0];
    const fenceLength = openMatch[1].length;
    const openIndex = openMatch.index;
    const escapedChar = fenceChar.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const closePattern = new RegExp(
      `^${escapedChar}{${fenceLength}}\\s*$`,
      "m"
    );
    const afterOpen = result.substring(openIndex + openMatch[1].length);
    const closeMatch = afterOpen.match(closePattern);
    if (closeMatch) {
      const closeIndex = openIndex + openMatch[1].length + closeMatch.index;
      const blockEnd = closeIndex + closeMatch[0].length;
      result = result.substring(0, openIndex) + result.substring(blockEnd);
      changed = true;
    } else {
      const lineEnd = result.indexOf("\n", openIndex);
      if (lineEnd === -1) {
        result = result.substring(0, openIndex);
      } else {
        result = result.substring(0, openIndex) + result.substring(lineEnd + 1);
      }
      changed = true;
    }
  }
  return result;
}
function stripMarkdownSyntax(text) {
  if (!text || text.trim().length === 0)
    return "";
  text = text.replace(/^>\s*\[![\w-]+\][+-]?.*$/gm, "");
  text = text.replace(/^>\s?/gm, "");
  const { text: protectedText, map: escapedCharsMap } = protectEscapedChars(text);
  let result = removeCodeBlocks(protectedText);
  markdownPatterns.forEach((pattern) => {
    result = result.replace(pattern, (match, ...groups) => {
      if (match.match(/<[a-z][a-z0-9]*\b[^>]*>.*?<\//i)) {
        return groups[1] || "";
      }
      if (groups.length > 0 && groups[0] !== void 0) {
        for (let i = 0; i < groups.length - 2; i++) {
          if (typeof groups[i] === "string") {
            return groups[i];
          }
        }
      }
      return "";
    });
  });
  result = restoreEscapedChars(result, escapedCharsMap);
  return result;
}
function sanitizeForPreview(content, omitFirstLine = false, filename, titleValue) {
  const cleaned = content.replace(/^---[\s\S]*?---/, "").trim();
  let stripped = stripMarkdownSyntax(cleaned);
  const firstLineEnd = stripped.indexOf("\n");
  const firstLine = (firstLineEnd !== -1 ? stripped.substring(0, firstLineEnd) : stripped).trim();
  if (omitFirstLine || filename && firstLine === filename || titleValue && firstLine === titleValue) {
    stripped = firstLineEnd !== -1 ? stripped.substring(firstLineEnd + 1).trim() : "";
  }
  const normalized = stripped.replace(/\^[a-zA-Z0-9-]+/g, "").split(/\s+/).filter((word) => word).join(" ").trim().replace(/\.{2,}/g, (match) => match.replace(/\./g, "\u2024"));
  const wasTruncated = normalized.length > 500;
  let preview = normalized.substring(0, 500);
  if (wasTruncated) {
    preview += "\u2026";
  }
  return preview;
}
async function loadFilePreview(file, app, propertyValue, settings, fileName, titleValue) {
  const hasValidDesc = propertyValue != null && (typeof propertyValue === "string" || typeof propertyValue === "number") && String(propertyValue).trim().length > 0;
  if (hasValidDesc) {
    return String(propertyValue).trim();
  }
  if (settings.fallbackToContent) {
    const content = await app.vault.cachedRead(file);
    return sanitizeForPreview(
      content,
      settings.omitFirstLine,
      fileName,
      titleValue
    );
  }
  return "";
}

// src/shared/content-loader.ts
async function loadImageForEntry(path, file, app, imagePropertyValues, fallbackToEmbeds, imageCache, hasImageCache) {
  if (path in imageCache) {
    return;
  }
  try {
    const { internalPaths, externalUrls } = await processImagePaths(
      imagePropertyValues
    );
    let validImages = [
      ...resolveInternalImagePaths(internalPaths, path, app),
      ...externalUrls
      // External URLs already validated by processImagePaths
    ];
    if (fallbackToEmbeds === "always") {
      const embedImages = await extractEmbedImages(file, app);
      validImages = [...validImages, ...embedImages];
    } else if (fallbackToEmbeds === "if-empty") {
      if (validImages.length === 0) {
        validImages = await extractEmbedImages(file, app);
      }
    } else if (fallbackToEmbeds === "never") {
    }
    if (validImages.length > 0) {
      imageCache[path] = validImages.length > 1 ? validImages : validImages[0];
      hasImageCache[path] = true;
    }
  } catch (error) {
    console.error(`Failed to load image for ${path}:`, error);
  }
}
async function loadImagesForEntries(entries, fallbackToEmbeds, app, imageCache, hasImageCache) {
  await Promise.all(
    entries.map(async (entry) => {
      await loadImageForEntry(
        entry.path,
        entry.file,
        app,
        entry.imagePropertyValues,
        fallbackToEmbeds,
        imageCache,
        hasImageCache
      );
    })
  );
}
async function loadSnippetForEntry(path, file, app, descriptionData, fallbackToContent, omitFirstLine, snippetCache, fileName, titleString) {
  if (path in snippetCache) {
    return;
  }
  try {
    if (file.extension === "md") {
      snippetCache[path] = await loadFilePreview(
        file,
        app,
        descriptionData,
        {
          fallbackToContent,
          omitFirstLine
        },
        fileName,
        titleString
      );
    } else {
      snippetCache[path] = "";
    }
  } catch (error) {
    console.error(`Failed to load snippet for ${path}:`, error);
    snippetCache[path] = "";
  }
}
async function loadSnippetsForEntries(entries, fallbackToContent, omitFirstLine, app, snippetCache) {
  await Promise.all(
    entries.map(async (entry) => {
      await loadSnippetForEntry(
        entry.path,
        entry.file,
        app,
        entry.descriptionData,
        fallbackToContent,
        omitFirstLine,
        snippetCache,
        entry.fileName,
        entry.titleString
      );
    })
  );
}

// src/components/view.tsx
init_property();
init_style_settings();

// src/utils/masonry-layout.ts
function calculateMasonryLayout(params) {
  const { cards, containerWidth, cardSize, minColumns, gap } = params;
  const columns = Math.max(
    minColumns,
    Math.floor((containerWidth + gap) / (cardSize + gap))
  );
  const cardWidth = (containerWidth - gap * (columns - 1)) / columns;
  const columnHeights = new Array(columns).fill(0);
  const positions = [];
  cards.forEach((card) => {
    const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));
    const left = shortestColumn * (cardWidth + gap);
    const top = columnHeights[shortestColumn];
    positions.push({ left, top });
    const cardHeight = card.offsetHeight;
    columnHeights[shortestColumn] += cardHeight + gap;
  });
  const containerHeight = Math.max(...columnHeights);
  return {
    positions,
    columnHeights,
    containerHeight,
    cardWidth,
    columns
  };
}
function applyMasonryLayout(container, cards, result) {
  container.classList.add("masonry-container");
  container.style.setProperty(
    "--masonry-height",
    `${result.containerHeight}px`
  );
  cards.forEach((card, index) => {
    const pos = result.positions[index];
    card.classList.add("masonry-positioned");
    card.style.setProperty("--masonry-width", `${result.cardWidth}px`);
    card.style.setProperty("--masonry-left", `${pos.left}px`);
    card.style.setProperty("--masonry-top", `${pos.top}px`);
  });
}

// src/components/view.tsx
function View({
  plugin,
  app,
  dc,
  USER_QUERY = ""
}) {
  const currentFile = dc.useMemo(() => {
    const file = getCurrentFile(app);
    return file;
  }, [app]);
  const currentFilePath = currentFile == null ? void 0 : currentFile.path;
  const ctime = getFileCtime(currentFile);
  const persistenceManager = plugin.persistenceManager;
  const markdownPatterns2 = dc.useMemo(
    () => [
      /```[\s\S]*?```/g,
      // Code blocks
      /%%[\s\S]*?%%/g,
      // Obsidian comments
      /`[^`]+`/g,
      // Inline code
      /!\[.*?\]\([^)]+\)/g,
      // Images
      /!\[\[.*?\]\]/g,
      // Wiki embeds
      /#[\w\-/]+(?=\s|$)/g,
      // Tags
      /\*\*\*((?:(?!\*\*\*).)+)\*\*\*/g,
      // Bold italic
      /\*\*((?:(?!\*\*).)+)\*\*/g,
      // Bold
      /\*((?:(?!\*).)+)\*/g,
      // Italic
      /__((?:(?!__).)+)__/g,
      // Bold underscores
      /_((?:(?!_).)+)_/g,
      // Italic underscores
      /~~((?:(?!~~).)+)~~/g,
      // Strikethrough
      /==((?:(?!==).)+)==/g,
      // Highlight
      /\[([^\]]+)\]\([^)]+\)/g,
      // Links
      /\[\[[^\]|]+\|([^\]]+)\]\]/g,
      // Wiki links with display
      /\[\[([^\]]+)\]\]/g,
      // Wiki links
      /^[-*+]\s+/gm,
      // Bullet list markers
      /^#{1,6}\s+.+$/gm,
      // Heading lines (full removal)
      /^\s*(?:[-_*])\s*(?:[-_*])\s*(?:[-_*])[\s\-_*]*$/gm,
      // Horizontal rules
      /^\s*\|.*\|.*$/gm,
      // Tables
      /\^\[[^\]]*?]/g,
      // Inline footnotes
      /\[\^[^\]]+]/g,
      // Footnote references
      /^\s*\[\^[^\]]+]:.*$/gm,
      // Footnote definitions
      /<([a-z][a-z0-9]*)\b[^>]*>(.*?)<\/\1>/gi,
      // HTML tag pairs
      /<[^>]+>/g
      // Remaining HTML tags
    ],
    []
  );
  const stripMarkdownSyntax2 = dc.useCallback(
    (text) => {
      if (!text || text.trim().length === 0)
        return "";
      text = text.replace(/^>\s*\[![\w-]+\][+-]?.*$/gm, "");
      text = text.replace(/^>\s?/gm, "");
      let result = text;
      markdownPatterns2.forEach((pattern) => {
        result = result.replace(
          pattern,
          (match, ...groups) => {
            if (match.match(/<[a-z][a-z0-9]*\b[^>]*>.*?<\//i)) {
              return groups[1] || "";
            }
            if (groups.length > 0 && groups[0] !== void 0) {
              for (let i = 0; i < groups.length - 2; i++) {
                if (groups[i] !== void 0) {
                  return groups[i];
                }
              }
            }
            return "";
          }
        );
      });
      return result;
    },
    [markdownPatterns2]
  );
  const getPersistedSettings = dc.useCallback(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    if (!ctime || !persistenceManager)
      return DEFAULT_SETTINGS;
    const globalSettings = persistenceManager.getGlobalSettings();
    const defaultViewSettings = persistenceManager.getDefaultViewSettings();
    const viewSettings = persistenceManager.getViewSettings(ctime);
    const baseSettings = { ...globalSettings };
    baseSettings.titleProperty = (_a = viewSettings.titleProperty) != null ? _a : defaultViewSettings.titleProperty;
    baseSettings.descriptionProperty = (_b = viewSettings.descriptionProperty) != null ? _b : defaultViewSettings.descriptionProperty;
    baseSettings.imageProperty = (_c = viewSettings.imageProperty) != null ? _c : defaultViewSettings.imageProperty;
    baseSettings.propertyDisplay1 = (_d = viewSettings.propertyDisplay1) != null ? _d : defaultViewSettings.propertyDisplay1;
    baseSettings.propertyDisplay2 = (_e = viewSettings.propertyDisplay2) != null ? _e : defaultViewSettings.propertyDisplay2;
    baseSettings.propertyDisplay3 = (_f = viewSettings.propertyDisplay3) != null ? _f : defaultViewSettings.propertyDisplay3;
    baseSettings.propertyDisplay4 = (_g = viewSettings.propertyDisplay4) != null ? _g : defaultViewSettings.propertyDisplay4;
    baseSettings.propertyLayout12SideBySide = (_h = viewSettings.propertyLayout12SideBySide) != null ? _h : defaultViewSettings.propertyLayout12SideBySide;
    baseSettings.propertyLayout34SideBySide = (_i = viewSettings.propertyLayout34SideBySide) != null ? _i : defaultViewSettings.propertyLayout34SideBySide;
    baseSettings.showTextPreview = (_j = viewSettings.showTextPreview) != null ? _j : defaultViewSettings.showTextPreview;
    baseSettings.fallbackToContent = (_k = viewSettings.fallbackToContent) != null ? _k : defaultViewSettings.fallbackToContent;
    baseSettings.fallbackToEmbeds = (_l = viewSettings.fallbackToEmbeds) != null ? _l : defaultViewSettings.fallbackToEmbeds;
    baseSettings.queryHeight = (_m = viewSettings.queryHeight) != null ? _m : defaultViewSettings.queryHeight;
    baseSettings.listMarker = (_n = viewSettings.listMarker) != null ? _n : defaultViewSettings.listMarker;
    return baseSettings;
  }, [ctime, persistenceManager]);
  const getFilePersistedValue = dc.useCallback(
    (key, defaultValue) => {
      var _a;
      if (!ctime || !persistenceManager)
        return defaultValue;
      const state = persistenceManager.getUIState(ctime);
      return (_a = state[key]) != null ? _a : defaultValue;
    },
    [ctime, persistenceManager]
  );
  const [sortMethod, setSortMethod] = dc.useState(
    getFilePersistedValue("sortMethod", "mtime-desc")
  );
  const [searchQuery, setSearchQuery] = dc.useState(
    getFilePersistedValue("searchQuery", "")
  );
  const [viewMode, setViewMode] = dc.useState(
    getFilePersistedValue("viewMode", "card")
  );
  const [widthMode, setWidthMode] = dc.useState(
    getFilePersistedValue("widthMode", "normal")
  );
  const [resultLimit, setResultLimit] = dc.useState(
    getFilePersistedValue("resultLimit", "")
  );
  const cleanQuery = (USER_QUERY || "").split("\n").filter(
    (line) => !line.includes("QUERY START") && !line.includes("QUERY END")
  ).join("\n").trim();
  const [_query, setQuery] = dc.useState(cleanQuery);
  const [draftQuery, setDraftQuery] = dc.useState(cleanQuery);
  const [appliedQuery, setAppliedQuery] = dc.useState(cleanQuery);
  const [isShuffled, setIsShuffled] = dc.useState(false);
  const [shuffledOrder, setShuffledOrder] = dc.useState([]);
  const [showQueryEditor, setShowQueryEditor] = dc.useState(false);
  const [showLimitDropdown, setShowLimitDropdown] = dc.useState(false);
  const [showSettings, setShowSettings] = dc.useState(false);
  const [showSortDropdown, setShowSortDropdown] = dc.useState(false);
  const [showViewDropdown, setShowViewDropdown] = dc.useState(false);
  const [isPinned, setIsPinned] = dc.useState(false);
  const [queryError, setQueryError] = dc.useState(null);
  const [displayedCount, setDisplayedCount] = dc.useState(
    app.isMobile ? 25 : 50
  );
  const [focusableCardIndex, setFocusableCardIndex] = dc.useState(0);
  const [isResultsScrolled, setIsResultsScrolled] = dc.useState(false);
  const [isScrolledToBottom, setIsScrolledToBottom] = dc.useState(true);
  const [settings, setSettings] = dc.useState(getPersistedSettings());
  const explorerRef = dc.useRef(null);
  const toolbarRef = dc.useRef(null);
  const containerRef = dc.useRef(null);
  const updateLayoutRef = dc.useRef(null);
  const loadMoreRef = dc.useRef(null);
  const isLoadingRef = dc.useRef(false);
  const columnCountRef = dc.useRef(null);
  const displayedCountRef = dc.useRef(displayedCount);
  const sortedLengthRef = dc.useRef(0);
  const settingsTimeoutRef = dc.useRef(
    null
  );
  const isSyncing = dc.useRef(false);
  const [stickyTop, setStickyTop] = dc.useState(0);
  const [toolbarDimensions, setToolbarDimensions] = dc.useState({
    width: 0,
    height: 0,
    left: 0
  });
  dc.useEffect(() => {
    if (ctime && persistenceManager) {
      void persistenceManager.setUIState(ctime, { sortMethod });
    }
  }, [sortMethod, ctime, persistenceManager]);
  dc.useEffect(() => {
    if (ctime && persistenceManager) {
      void persistenceManager.setUIState(ctime, { viewMode });
    }
  }, [viewMode, ctime, persistenceManager]);
  dc.useEffect(() => {
    if (ctime && persistenceManager) {
      void persistenceManager.setUIState(ctime, { widthMode });
    }
  }, [widthMode, ctime, persistenceManager]);
  dc.useEffect(() => {
    if (ctime && persistenceManager) {
      void persistenceManager.setUIState(ctime, { searchQuery });
    }
  }, [searchQuery, ctime, persistenceManager]);
  dc.useEffect(() => {
    if (ctime && persistenceManager) {
      void persistenceManager.setUIState(ctime, { resultLimit });
    }
  }, [resultLimit, ctime, persistenceManager]);
  dc.useEffect(() => {
    if (settingsTimeoutRef.current) {
      clearTimeout(settingsTimeoutRef.current);
    }
    settingsTimeoutRef.current = setTimeout(() => {
      if (ctime && persistenceManager) {
        const viewSettings = {
          titleProperty: settings.titleProperty,
          descriptionProperty: settings.descriptionProperty,
          imageProperty: settings.imageProperty,
          propertyDisplay1: settings.propertyDisplay1,
          propertyDisplay2: settings.propertyDisplay2,
          propertyDisplay3: settings.propertyDisplay3,
          propertyDisplay4: settings.propertyDisplay4,
          propertyLayout12SideBySide: settings.propertyLayout12SideBySide,
          propertyLayout34SideBySide: settings.propertyLayout34SideBySide,
          propertyLabels: settings.propertyLabels,
          showTitle: settings.showTitle,
          showTextPreview: settings.showTextPreview,
          fallbackToContent: settings.fallbackToContent,
          fallbackToEmbeds: settings.fallbackToEmbeds,
          imageFormat: settings.imageFormat,
          coverFitMode: settings.coverFitMode,
          imageAspectRatio: settings.imageAspectRatio,
          queryHeight: settings.queryHeight,
          listMarker: settings.listMarker,
          cardSize: settings.cardSize
        };
        void persistenceManager.setViewSettings(ctime, viewSettings);
      }
    }, 300);
  }, [settings, ctime, persistenceManager]);
  dc.useEffect(() => {
    if (isPinned && toolbarRef.current) {
      const scrollContainer = toolbarRef.current.closest(
        ".markdown-preview-view, .markdown-reading-view, .markdown-source-view"
      );
      if (!scrollContainer) {
        setStickyTop(0);
        return;
      }
      const updateStickyTop = () => {
        const containerRect = scrollContainer.getBoundingClientRect();
        const headerHeight = containerRect.top;
        setStickyTop(Math.max(0, headerHeight));
        if (toolbarRef.current && explorerRef.current) {
          const explorerRect = explorerRef.current.getBoundingClientRect();
          setToolbarDimensions({
            width: explorerRect.width,
            height: toolbarRef.current.offsetHeight,
            left: explorerRect.left
          });
        }
      };
      updateStickyTop();
      window.addEventListener("resize", updateStickyTop);
      scrollContainer.addEventListener("scroll", updateStickyTop);
      return () => {
        window.removeEventListener("resize", updateStickyTop);
        scrollContainer.removeEventListener("scroll", updateStickyTop);
      };
    }
  }, [isPinned]);
  const validatedQuery = dc.useMemo(() => {
    const q = appliedQuery.trim();
    if (!q || q.length === 0) {
      setQueryError(null);
      return "@page";
    }
    setQueryError(null);
    return ensurePageSelector(q);
  }, [appliedQuery]);
  const [_indexRevision, setIndexRevision] = dc.useState(0);
  dc.useEffect(() => {
    var _a;
    const core = (_a = window.datacore) == null ? void 0 : _a.core;
    if (!core) {
      return;
    }
    const updateRef = core.on("update", (revision) => {
      setIndexRevision(revision);
    });
    const initialRevision = core.revision || 0;
    setIndexRevision(initialRevision);
    return () => {
      core.offref(updateRef);
    };
  }, [app, dc]);
  let pages = [];
  try {
    pages = dc.useQuery(validatedQuery) || [];
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Query error";
    setQueryError(errorMessage);
    pages = [];
  }
  const parsedSearchTerms = dc.useMemo(() => {
    if (!(searchQuery == null ? void 0 : searchQuery.trim()))
      return null;
    const terms = searchQuery.toLowerCase().trim().split(/\s+/);
    const positiveTerms = terms.filter((t) => !t.startsWith("-"));
    const negativeTerms = terms.filter((t) => t.startsWith("-")).map((t) => t.slice(1));
    return {
      posTagTerms: positiveTerms.filter((t) => t.startsWith("#")),
      posNameTerms: positiveTerms.filter((t) => !t.startsWith("#")),
      negTagTerms: negativeTerms.filter((t) => t.startsWith("#")),
      negNameTerms: negativeTerms.filter((t) => !t.startsWith("#"))
    };
  }, [searchQuery]);
  const { sorted, totalCount } = dc.useMemo(() => {
    const pagesArray = Array.isArray(pages) ? [...pages] : [];
    let filtered = currentFilePath ? pagesArray.filter((p) => p.$path !== currentFilePath) : pagesArray;
    if (parsedSearchTerms) {
      const { posTagTerms, posNameTerms, negTagTerms, negNameTerms } = parsedSearchTerms;
      filtered = filtered.filter((p) => {
        const fileName = (p.$name || "").toLowerCase();
        const fileTags = (p.$tags || []).map((t) => t.toLowerCase());
        const posNameMatch = posNameTerms.every(
          (term) => fileName.includes(term)
        );
        const posTagMatch = posTagTerms.every(
          (term) => fileTags.some((fileTag) => fileTag === term)
        );
        const negNameMatch = negNameTerms.some(
          (term) => fileName.includes(term)
        );
        const negTagMatch = negTagTerms.some(
          (term) => fileTags.some((fileTag) => fileTag === term)
        );
        return posNameMatch && posTagMatch && !negNameMatch && !negTagMatch;
      });
    }
    let sorted2;
    if (isShuffled) {
      sorted2 = filtered.sort((a, b) => {
        const indexA = shuffledOrder.indexOf(a.$path);
        const indexB = shuffledOrder.indexOf(b.$path);
        return indexA - indexB;
      });
    } else {
      switch (sortMethod) {
        case "name-asc":
          sorted2 = filtered.sort(
            (a, b) => (a.$name || "").localeCompare(b.$name || "")
          );
          break;
        case "name-desc":
          sorted2 = filtered.sort(
            (a, b) => (b.$name || "").localeCompare(a.$name || "")
          );
          break;
        case "mtime-asc":
          sorted2 = filtered.sort(
            (a, b) => {
              var _a, _b;
              return (((_a = a.$mtime) == null ? void 0 : _a.toMillis()) || 0) - (((_b = b.$mtime) == null ? void 0 : _b.toMillis()) || 0);
            }
          );
          break;
        case "mtime-desc":
          sorted2 = filtered.sort(
            (a, b) => {
              var _a, _b;
              return (((_a = b.$mtime) == null ? void 0 : _a.toMillis()) || 0) - (((_b = a.$mtime) == null ? void 0 : _b.toMillis()) || 0);
            }
          );
          break;
        case "ctime-asc":
          sorted2 = filtered.sort(
            (a, b) => {
              var _a, _b;
              return (((_a = a.$ctime) == null ? void 0 : _a.toMillis()) || 0) - (((_b = b.$ctime) == null ? void 0 : _b.toMillis()) || 0);
            }
          );
          break;
        case "ctime-desc":
          sorted2 = filtered.sort(
            (a, b) => {
              var _a, _b;
              return (((_a = b.$ctime) == null ? void 0 : _a.toMillis()) || 0) - (((_b = a.$ctime) == null ? void 0 : _b.toMillis()) || 0);
            }
          );
          break;
        default:
          sorted2 = filtered.sort(
            (a, b) => {
              var _a, _b;
              return (((_a = b.$mtime) == null ? void 0 : _a.toMillis()) || 0) - (((_b = a.$mtime) == null ? void 0 : _b.toMillis()) || 0);
            }
          );
      }
    }
    const totalCount2 = sorted2.length;
    const limit = parseInt(resultLimit);
    if (limit > 0 && sorted2.length > limit) {
      return { sorted: sorted2.slice(0, limit), totalCount: totalCount2 };
    }
    return { sorted: sorted2, totalCount: totalCount2 };
  }, [
    pages,
    sortMethod,
    parsedSearchTerms,
    isShuffled,
    shuffledOrder,
    resultLimit,
    currentFilePath
  ]);
  const [snippets, setSnippets] = dc.useState({});
  const [images, setImages] = dc.useState({});
  const [hasImageAvailable, setHasImageAvailable] = dc.useState({});
  dc.useEffect(() => {
    if (!settings.showTextPreview && settings.imageFormat === "none") {
      setSnippets({});
      setImages({});
      setHasImageAvailable({});
      return;
    }
    const loadSnippets = async () => {
      const newSnippets = {};
      const newImages = {};
      const newHasImageAvailable = {};
      if (settings.showTextPreview) {
        const snippetEntries = sorted.slice(0, displayedCount).map((p) => {
          try {
            const file = app.vault.getAbstractFileByPath(p.$path);
            if (!(file instanceof import_obsidian6.TFile)) {
              newSnippets[p.$path] = "(File not found)";
              return null;
            }
            const descFromProp = getFirstDatacorePropertyValue(
              p,
              settings.descriptionProperty
            );
            const descAsString = typeof descFromProp === "string" || typeof descFromProp === "number" ? String(descFromProp) : null;
            let titleValue = p.value(settings.titleProperty);
            if (Array.isArray(titleValue))
              titleValue = titleValue[0];
            const titleString = titleValue ? dc.coerce.string(titleValue) : void 0;
            return {
              path: p.$path,
              file,
              descriptionData: descAsString,
              fileName: p.$name,
              titleString
            };
          } catch (e) {
            console.error(
              "Error reading file:",
              p.$path,
              e instanceof Error ? e.message : e
            );
            newSnippets[p.$path] = "(Error reading file)";
            return null;
          }
        }).filter((e) => e !== null);
        await loadSnippetsForEntries(
          snippetEntries,
          settings.fallbackToContent,
          settings.omitFirstLine,
          app,
          newSnippets
        );
      }
      if (settings.imageFormat !== "none") {
        const imageEntries = sorted.slice(0, displayedCount).map((p) => {
          try {
            const file = app.vault.getAbstractFileByPath(p.$path);
            if (!(file instanceof import_obsidian6.TFile))
              return null;
            const imagePropertyValues = getAllDatacoreImagePropertyValues(
              p,
              settings.imageProperty
            );
            return {
              path: p.$path,
              file,
              imagePropertyValues
            };
          } catch (e) {
            console.error(
              "Error reading file:",
              p.$path,
              e instanceof Error ? e.message : e
            );
            return null;
          }
        }).filter((e) => e !== null);
        await loadImagesForEntries(
          imageEntries,
          settings.fallbackToEmbeds,
          app,
          newImages,
          newHasImageAvailable
        );
      }
      setSnippets(newSnippets);
      setImages(newImages);
      setHasImageAvailable(newHasImageAvailable);
    };
    void loadSnippets();
  }, [
    sorted,
    displayedCount,
    stripMarkdownSyntax2,
    settings.showTextPreview,
    settings.imageFormat,
    settings,
    app,
    dc
  ]);
  dc.useEffect(() => {
    if (viewMode !== "masonry") {
      const container = containerRef.current;
      if (container) {
        const cards = container.querySelectorAll(".card");
        cards.forEach((card) => {
          card.classList.remove("masonry-positioned");
          card.style.removeProperty("--masonry-width");
          card.style.removeProperty("--masonry-left");
          card.style.removeProperty("--masonry-top");
        });
        container.classList.remove("masonry-container");
        container.style.removeProperty("--masonry-height");
      }
      updateLayoutRef.current = null;
      return;
    }
    const updateLayout = () => {
      const container = containerRef.current;
      if (!container)
        return;
      const cards = Array.from(
        container.querySelectorAll(".card")
      );
      if (cards.length === 0)
        return;
      const containerWidth = container.clientWidth;
      if (containerWidth < 100)
        return;
      const cardSize = settings.cardSize;
      const minColumns = getMinMasonryColumns();
      const gap = getCardSpacing();
      const result = calculateMasonryLayout({
        cards,
        containerWidth,
        cardSize,
        minColumns,
        gap
      });
      applyMasonryLayout(container, cards, result);
      columnCountRef.current = result.columns;
    };
    updateLayoutRef.current = updateLayout;
    updateLayout();
    const mutationObserver = new MutationObserver(() => {
      updateLayout();
    });
    if (containerRef.current) {
      mutationObserver.observe(containerRef.current, {
        childList: true
      });
    }
    let resizeTimeout = null;
    const handleResize = () => {
      if (resizeTimeout)
        clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(updateLayout, 100);
    };
    window.addEventListener("resize", handleResize);
    return () => {
      if (resizeTimeout)
        clearTimeout(resizeTimeout);
      mutationObserver.disconnect();
      window.removeEventListener("resize", handleResize);
    };
  }, [viewMode, settings.cardSize, dc]);
  dc.useEffect(() => {
    if (viewMode !== "card")
      return;
    const container = containerRef.current;
    if (!container)
      return;
    const updateGrid = () => {
      const containerWidth = container.clientWidth;
      const cardSize = settings.cardSize;
      const minColumns = getMinGridColumns();
      const gap = getCardSpacing();
      const cols = Math.max(
        minColumns,
        Math.floor((containerWidth + gap) / (cardSize + gap))
      );
      container.style.setProperty("--grid-columns", String(cols));
      const imageAspectRatio = plugin.persistenceManager.getGlobalSettings().imageAspectRatio;
      container.style.setProperty(
        "--dynamic-views-image-aspect-ratio",
        String(imageAspectRatio)
      );
    };
    updateGrid();
    const resizeObserver = new ResizeObserver(updateGrid);
    resizeObserver.observe(container);
    return () => {
      resizeObserver.disconnect();
    };
  }, [viewMode, settings.cardSize, dc]);
  dc.useEffect(() => {
    displayedCountRef.current = displayedCount;
  }, [displayedCount, dc]);
  dc.useEffect(() => {
    sortedLengthRef.current = sorted.length;
  }, [sorted.length, dc]);
  dc.useEffect(() => {
    const container = containerRef.current;
    if (!container || settings.queryHeight === 0) {
      setIsResultsScrolled(false);
      setIsScrolledToBottom(true);
      return;
    }
    const handleScroll = () => {
      setIsResultsScrolled(container.scrollTop > 10);
      const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 1;
      setIsScrolledToBottom(isAtBottom);
    };
    handleScroll();
    container.addEventListener("scroll", handleScroll);
    return () => container.removeEventListener("scroll", handleScroll);
  }, [settings.queryHeight, displayedCount, sorted.length, viewMode]);
  dc.useEffect(() => {
    if (!containerRef.current) {
      return;
    }
    const DESKTOP_VIEWPORT_MULTIPLIER = 2;
    const MOBILE_VIEWPORT_MULTIPLIER = Math.max(
      1,
      DESKTOP_VIEWPORT_MULTIPLIER * 0.5
    );
    let element = containerRef.current;
    let scrollableElement = null;
    while (element && !scrollableElement) {
      const style = window.getComputedStyle(element);
      const overflowY = style.overflowY;
      const hasOverflow = overflowY === "auto" || overflowY === "scroll";
      if (hasOverflow && element.scrollHeight > element.clientHeight) {
        scrollableElement = element;
      }
      element = element.parentElement;
    }
    if (!scrollableElement) {
      scrollableElement = window;
    } else {
    }
    const loadMoreItems = (trigger = "unknown") => {
      if (isLoadingRef.current) {
        return false;
      }
      if (!containerRef.current) {
        return false;
      }
      const currentCount = displayedCountRef.current;
      const totalLength = sortedLengthRef.current;
      if (totalLength !== null && currentCount >= totalLength) {
        return false;
      }
      let scrollTop, editorHeight, scrollHeight;
      if (scrollableElement === window) {
        scrollTop = window.scrollY || document.documentElement.scrollTop;
        editorHeight = window.innerHeight;
        scrollHeight = document.documentElement.scrollHeight;
      } else if (scrollableElement instanceof HTMLElement) {
        scrollTop = scrollableElement.scrollTop;
        editorHeight = scrollableElement.clientHeight;
        scrollHeight = scrollableElement.scrollHeight;
      } else {
        return false;
      }
      const distanceFromBottom = scrollHeight - (scrollTop + editorHeight);
      const threshold = editorHeight * (app.isMobile ? MOBILE_VIEWPORT_MULTIPLIER : DESKTOP_VIEWPORT_MULTIPLIER);
      if (distanceFromBottom > threshold) {
        return false;
      }
      isLoadingRef.current = true;
      const currentCols = columnCountRef.current || 2;
      const rowsPerColumn = 10;
      const batchSize = Math.min(
        currentCols * rowsPerColumn,
        7 * rowsPerColumn
      );
      const newCount = Math.min(currentCount + batchSize, totalLength);
      displayedCountRef.current = newCount;
      setDisplayedCount(newCount);
      return true;
    };
    const resizeObserver = new ResizeObserver(() => {
      isLoadingRef.current = false;
    });
    resizeObserver.observe(containerRef.current);
    const initialCheckTimeout = setTimeout(() => {
      loadMoreItems("initial-check");
    }, 300);
    const handleWindowResize = () => {
      loadMoreItems("window.resize");
    };
    window.addEventListener("resize", handleWindowResize);
    let scrollTimer = null;
    const handleScroll = () => {
      if (scrollTimer) {
        return;
      }
      loadMoreItems("scroll");
      scrollTimer = setTimeout(() => {
        scrollTimer = null;
      }, 100);
    };
    scrollableElement.addEventListener("scroll", handleScroll, {
      passive: true
    });
    return () => {
      resizeObserver.disconnect();
      window.removeEventListener("resize", handleWindowResize);
      scrollableElement.removeEventListener("scroll", handleScroll);
      if (scrollTimer)
        clearTimeout(scrollTimer);
      clearTimeout(initialCheckTimeout);
    };
  }, []);
  dc.useEffect(() => {
    const newCleanQuery = (USER_QUERY || "").split("\n").filter(
      (line) => !line.includes("QUERY START") && !line.includes("QUERY END")
    ).join("\n").trim();
    if (newCleanQuery !== appliedQuery) {
      setQuery(newCleanQuery);
      setDraftQuery(newCleanQuery);
      setAppliedQuery(newCleanQuery);
    }
  }, [USER_QUERY]);
  const handleTogglePin = dc.useCallback(() => {
    setIsPinned(!isPinned);
  }, [isPinned]);
  const handleToggleWidth = dc.useCallback(() => {
    const modes = ["normal", "wide", "max"];
    const currentIndex = modes.indexOf(widthMode);
    const nextMode = modes[(currentIndex + 1) % modes.length];
    setWidthMode(nextMode);
    const sections = document.querySelectorAll(
      ".markdown-source-view, .markdown-preview-view, .markdown-reading-view"
    );
    sections.forEach((section) => {
      if (section.querySelector(".dynamic-views")) {
        section.classList.remove("dc-wide", "dc-max");
        if (nextMode === "wide") {
          section.classList.add("dc-wide");
        } else if (nextMode === "max") {
          section.classList.add("dc-max");
        }
      }
    });
  }, [widthMode]);
  const handleToggleSettings = dc.useCallback(() => {
    setShowSettings((prev) => !prev);
    if (!showSettings) {
      setShowViewDropdown(false);
      setShowSortDropdown(false);
      setShowLimitDropdown(false);
      setShowQueryEditor(false);
    }
  }, [showSettings]);
  const handleToggleViewDropdown = dc.useCallback(() => {
    setShowViewDropdown(!showViewDropdown);
    if (!showViewDropdown) {
      setShowSortDropdown(false);
      setShowLimitDropdown(false);
      setShowQueryEditor(false);
      setShowSettings(false);
    }
  }, [showViewDropdown]);
  const handleToggleSortDropdown = dc.useCallback(() => {
    setShowSortDropdown(!showSortDropdown);
    if (!showSortDropdown) {
      setShowViewDropdown(false);
      setShowLimitDropdown(false);
      setShowQueryEditor(false);
      setShowSettings(false);
    }
  }, [showSortDropdown]);
  const handleToggleLimitDropdown = dc.useCallback(() => {
    setShowLimitDropdown(!showLimitDropdown);
    if (!showLimitDropdown) {
      setShowViewDropdown(false);
      setShowSortDropdown(false);
      setShowQueryEditor(false);
      setShowSettings(false);
    }
  }, [showLimitDropdown]);
  const handleSetViewMode = dc.useCallback((mode) => {
    setViewMode(mode);
    setShowViewDropdown(false);
    setIsShuffled(false);
  }, []);
  const handleSetSortMethod = dc.useCallback((method) => {
    setSortMethod(method);
    setShowSortDropdown(false);
    setIsShuffled(false);
  }, []);
  const handleSearchChange = dc.useCallback(
    (query) => {
      setSearchQuery(query);
      setDisplayedCount(app.isMobile ? 25 : 50);
    },
    [app.isMobile]
  );
  const handleSearchFocus = dc.useCallback(() => {
    setShowViewDropdown(false);
    setShowSortDropdown(false);
    setShowLimitDropdown(false);
  }, []);
  const handleClearSearch = dc.useCallback(() => {
    setSearchQuery("");
  }, []);
  const handleShuffle = dc.useCallback(() => {
    const container = containerRef.current;
    if (!container)
      return;
    if (viewMode === "masonry") {
      const cards = Array.from(
        container.querySelectorAll(".card")
      );
      const shuffled2 = [...cards];
      for (let i = shuffled2.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled2[i], shuffled2[j]] = [shuffled2[j], shuffled2[i]];
      }
      shuffled2.forEach((card) => container.appendChild(card));
      if (updateLayoutRef.current) {
        updateLayoutRef.current();
      }
      setShowSortDropdown(false);
      return;
    }
    const paths = sorted.map((p) => p.$path);
    const shuffled = [...paths];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    setShuffledOrder(shuffled);
    setIsShuffled(true);
    setShowSortDropdown(false);
  }, [sorted, viewMode]);
  const handleOpenRandom = dc.useCallback(
    (event) => {
      if (sorted.length === 0)
        return;
      const randomIndex = Math.floor(Math.random() * sorted.length);
      const randomPath = sorted[randomIndex].$path;
      const file = app.vault.getAbstractFileByPath(randomPath);
      if (file instanceof import_obsidian6.TFile) {
        const newLeaf = import_obsidian6.Keymap.isModEvent(event);
        void app.workspace.getLeaf(newLeaf).openFile(file);
      }
    },
    [sorted, app]
  );
  const handleToggleCode = dc.useCallback(() => {
    setShowQueryEditor(!showQueryEditor);
    if (!showQueryEditor) {
      setShowViewDropdown(false);
      setShowSortDropdown(false);
      setShowLimitDropdown(false);
      setShowSettings(false);
    }
  }, [showQueryEditor]);
  const handleDraftQueryChange = dc.useCallback((query) => {
    setDraftQuery(query);
  }, []);
  const syncQueryToCodeBlock = dc.useCallback(
    async (queryToSave) => {
      if (isSyncing.current || !currentFile)
        return;
      isSyncing.current = true;
      try {
        const currentContent = await app.vault.read(currentFile);
        const currentQueryMatch = findQueryInBlock(currentContent);
        const currentQuery = (currentQueryMatch == null ? void 0 : currentQueryMatch.query) || "";
        if (currentQuery !== queryToSave) {
          await app.vault.process(currentFile, (content) => {
            return updateQueryInBlock(content, queryToSave);
          });
        }
      } catch (error) {
        console.error("Failed to sync query to code block:", error);
      } finally {
        isSyncing.current = false;
      }
    },
    [currentFile, app]
  );
  const handleApplyQuery = dc.useCallback(() => {
    void (async () => {
      const processedQuery = ensurePageSelector(draftQuery.trim());
      setDraftQuery(processedQuery);
      setAppliedQuery(processedQuery);
      setQuery(processedQuery);
      setShowQueryEditor(false);
      if (currentFile) {
        try {
          await syncQueryToCodeBlock(processedQuery);
        } catch (error) {
          console.error("Failed to sync query to code block:", error);
        }
      }
    })();
  }, [draftQuery, currentFile, syncQueryToCodeBlock]);
  const handleClearQuery = dc.useCallback(() => {
    void (async () => {
      setDraftQuery("");
      setAppliedQuery("");
      setQuery("");
      if (currentFile) {
        try {
          await syncQueryToCodeBlock("");
        } catch (error) {
          console.error("Failed to sync cleared query to code block:", error);
        }
      }
    })();
  }, [currentFile, syncQueryToCodeBlock]);
  const handleResultLimitChange = dc.useCallback((limit) => {
    setResultLimit(limit);
  }, []);
  const handleResetLimit = dc.useCallback(() => {
    setResultLimit("");
    setShowLimitDropdown(false);
  }, []);
  const handleCreateNote = dc.useCallback(
    (event) => {
      void (async () => {
        var _a;
        const folderPath = ((_a = currentFile == null ? void 0 : currentFile.parent) == null ? void 0 : _a.path) || "";
        const filePath = getAvailablePath(app, folderPath, "Untitled");
        const file = await app.vault.create(filePath, "");
        const newLeaf = import_obsidian6.Keymap.isModEvent(event);
        void app.workspace.getLeaf(newLeaf).openFile(file);
      })();
    },
    [app, currentFile]
  );
  const handleCardClick = dc.useCallback(
    (path, newLeaf) => {
      const file = app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian6.TFile) {
        if (settings.openFileAction === "card") {
          void app.workspace.getLeaf(newLeaf).openFile(file);
        } else if (settings.openFileAction === "title") {
        }
      }
    },
    [app, settings.openFileAction]
  );
  const handleCopyToClipboard = dc.useCallback(
    (e) => {
      e.stopPropagation();
      const limit = parseInt(resultLimit);
      const count = limit > 0 && totalCount > limit ? limit : totalCount;
      const text = `Copied ${count} result${count === 1 ? "" : "s"} to clipboard`;
      const links = sorted.slice(0, limit > 0 ? limit : sorted.length).map((p) => `[[${p.$name}]]`).join("\n");
      void navigator.clipboard.writeText(links);
      console.log(text);
    },
    [resultLimit, totalCount, sorted]
  );
  const handleSettingsChange = dc.useCallback(
    (newSettings) => {
      setSettings((prev) => ({ ...prev, ...newSettings }));
    },
    []
  );
  const copyMenuItem = dc.useMemo(
    () => /* @__PURE__ */ h(
      "div",
      {
        className: "bases-toolbar-menu-item",
        onClick: handleCopyToClipboard,
        onKeyDown: (e) => {
          const evt = e;
          if (evt.key === "Enter" || evt.key === " ") {
            evt.preventDefault();
            handleCopyToClipboard(evt);
          }
        },
        tabIndex: 0,
        role: "menuitem"
      },
      /* @__PURE__ */ h("div", { className: "bases-toolbar-menu-item-info" }, /* @__PURE__ */ h("div", { className: "bases-toolbar-menu-item-info-icon" }, /* @__PURE__ */ h(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "svg-icon lucide-copy"
        },
        /* @__PURE__ */ h("rect", { x: "8", y: "8", width: "14", height: "14", rx: "2", ry: "2" }),
        /* @__PURE__ */ h("path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" })
      )), /* @__PURE__ */ h("div", { className: "bases-toolbar-menu-item-name" }, "Copy to clipboard"))
    ),
    [handleCopyToClipboard]
  );
  const renderView = () => {
    const commonProps = {
      results: sorted,
      displayedCount: Math.min(displayedCount, sorted.length),
      settings,
      viewMode,
      sortMethod,
      isShuffled,
      snippets,
      images,
      hasImageAvailable,
      focusableCardIndex,
      containerRef,
      updateLayoutRef,
      app,
      dc,
      onCardClick: handleCardClick,
      onFocusChange: setFocusableCardIndex
    };
    if (viewMode === "list") {
      return /* @__PURE__ */ h(ListView, { ...commonProps });
    } else if (viewMode === "masonry") {
      return /* @__PURE__ */ h(MasonryView, { ...commonProps });
    } else {
      return /* @__PURE__ */ h(CardView, { ...commonProps, viewMode: "card" });
    }
  };
  const widthClass = widthMode === "max" ? "max-width" : widthMode === "wide" ? "wide-width" : "";
  return /* @__PURE__ */ h("div", { ref: explorerRef, className: `dynamic-views ${widthClass}` }, /* @__PURE__ */ h(
    "div",
    {
      ref: toolbarRef,
      className: `controls-wrapper${isPinned ? " pinned" : ""}${isResultsScrolled ? " scrolled" : ""}`,
      style: isPinned ? {
        position: "fixed",
        top: `${stickyTop}px`,
        width: `${toolbarDimensions.width}px`,
        left: `${toolbarDimensions.left}px`
      } : {}
    },
    /* @__PURE__ */ h(
      Toolbar,
      {
        dc,
        app,
        viewMode,
        showViewDropdown,
        onToggleViewDropdown: handleToggleViewDropdown,
        onSetViewCard: () => handleSetViewMode("card"),
        onSetViewMasonry: () => handleSetViewMode("masonry"),
        onSetViewList: () => handleSetViewMode("list"),
        sortMethod,
        isShuffled,
        showSortDropdown,
        onToggleSortDropdown: handleToggleSortDropdown,
        onSetSortNameAsc: () => handleSetSortMethod("name-asc"),
        onSetSortNameDesc: () => handleSetSortMethod("name-desc"),
        onSetSortMtimeDesc: () => handleSetSortMethod("mtime-desc"),
        onSetSortMtimeAsc: () => handleSetSortMethod("mtime-asc"),
        onSetSortCtimeDesc: () => handleSetSortMethod("ctime-desc"),
        onSetSortCtimeAsc: () => handleSetSortMethod("ctime-asc"),
        searchQuery,
        onSearchChange: handleSearchChange,
        onSearchFocus: handleSearchFocus,
        onClearSearch: handleClearSearch,
        settings,
        onShuffle: handleShuffle,
        onOpenRandom: handleOpenRandom,
        showQueryEditor,
        draftQuery,
        onToggleCode: handleToggleCode,
        onDraftQueryChange: handleDraftQueryChange,
        onApplyQuery: handleApplyQuery,
        onClearQuery: handleClearQuery,
        totalCount,
        displayedCount: Math.min(displayedCount, sorted.length),
        resultLimit,
        showLimitDropdown,
        onToggleLimitDropdown: handleToggleLimitDropdown,
        onResultLimitChange: handleResultLimitChange,
        onResetLimit: handleResetLimit,
        copyMenuItem,
        onCreateNote: handleCreateNote,
        isPinned,
        widthMode,
        queryHeight: settings.queryHeight,
        onTogglePin: handleTogglePin,
        onToggleWidth: handleToggleWidth,
        onToggleSettings: handleToggleSettings,
        showSettings,
        onSettingsChange: handleSettingsChange
      }
    )
  ), queryError && /* @__PURE__ */ h("div", { className: "query-error" }, queryError), /* @__PURE__ */ h(
    "div",
    {
      className: `results-container${settings.queryHeight > 0 && !isScrolledToBottom ? " with-fade" : ""}`,
      style: settings.queryHeight > 0 ? { maxHeight: `${settings.queryHeight}px`, overflowY: "auto" } : {}
    },
    renderView()
  ), /* @__PURE__ */ h("div", { ref: loadMoreRef, style: { height: "1px", width: "100%" } }));
}

// src/jsx-runtime.ts
var datacoreH = null;
var datacoreFragment = null;
function setDatacorePreact(preact) {
  datacoreH = preact.h;
  datacoreFragment = preact.Fragment;
}
function h2(type, props, ...children) {
  if (!datacoreH) {
    throw new Error(
      "Datacore Preact not initialized. Call setDatacorePreact(dc.preact) before rendering components."
    );
  }
  return datacoreH(type, props, ...children);
}
function Fragment2(props) {
  if (!datacoreFragment) {
    throw new Error("Datacore Preact not initialized.");
  }
  return datacoreFragment(props);
}
if (typeof globalThis !== "undefined") {
  globalThis.h = h2;
  globalThis.Fragment = Fragment2;
}

// src/bases/card-view.ts
var import_obsidian8 = require("obsidian");

// src/shared/settings-schema.ts
var _pluginInstance = null;
function setPluginInstance(plugin) {
  _pluginInstance = plugin;
}
function getBasesViewOptions() {
  return [
    {
      type: "slider",
      displayName: "Card size",
      key: "cardSize",
      min: 50,
      max: 800,
      step: 10,
      default: DEFAULT_VIEW_SETTINGS.cardSize
    },
    {
      type: "group",
      displayName: "Title",
      items: [
        {
          type: "toggle",
          displayName: "Show title",
          key: "showTitle",
          default: DEFAULT_VIEW_SETTINGS.showTitle
        },
        {
          type: "text",
          displayName: "Title property",
          key: "titleProperty",
          placeholder: "Comma-separated if multiple",
          default: DEFAULT_VIEW_SETTINGS.titleProperty
        }
      ]
    },
    {
      type: "group",
      displayName: "Text preview",
      items: [
        {
          type: "toggle",
          displayName: "Show text preview",
          key: "showTextPreview",
          default: DEFAULT_VIEW_SETTINGS.showTextPreview
        },
        {
          type: "text",
          displayName: "Text preview property",
          key: "descriptionProperty",
          placeholder: "Comma-separated if multiple",
          default: DEFAULT_VIEW_SETTINGS.descriptionProperty
        },
        {
          type: "toggle",
          displayName: "Use note content if text preview property missing or empty",
          key: "fallbackToContent",
          default: DEFAULT_VIEW_SETTINGS.fallbackToContent
        }
      ]
    },
    {
      type: "group",
      displayName: "Image",
      items: [
        {
          type: "dropdown",
          displayName: "Image format",
          key: "imageFormat",
          options: {
            thumbnail: "Thumbnail",
            cover: "Cover",
            none: "No image"
          },
          default: "thumbnail"
        },
        {
          type: "dropdown",
          displayName: "Image position",
          key: "imagePosition",
          options: {
            left: "Left",
            right: "Right",
            top: "Top",
            bottom: "Bottom"
          },
          default: "right"
        },
        {
          type: "text",
          displayName: "Image property",
          key: "imageProperty",
          placeholder: "Comma-separated if multiple",
          default: DEFAULT_VIEW_SETTINGS.imageProperty
        },
        {
          type: "dropdown",
          displayName: "Show image embeds",
          key: "fallbackToEmbeds",
          options: {
            always: "Always",
            "if-empty": "If image property missing or empty",
            never: "Never"
          },
          default: "always"
        },
        {
          type: "dropdown",
          displayName: "Image fit",
          key: "coverFitMode",
          options: {
            crop: "Crop",
            contain: "Contain"
          },
          default: "crop"
        },
        {
          type: "slider",
          displayName: "Image ratio",
          key: "imageAspectRatio",
          min: 0.25,
          max: 2.5,
          step: 0.05,
          default: DEFAULT_VIEW_SETTINGS.imageAspectRatio
        }
      ]
    },
    {
      type: "group",
      displayName: "Properties",
      items: [
        {
          type: "text",
          displayName: "Subtitle property",
          key: "subtitleProperty",
          placeholder: "Comma-separated if multiple",
          default: ""
        },
        {
          type: "text",
          displayName: "URL property",
          key: "urlProperty",
          placeholder: "Comma-separated if multiple",
          default: ""
        },
        {
          type: "dropdown",
          displayName: "Show property labels",
          key: "propertyLabels",
          options: {
            inline: "Inline",
            above: "On top",
            hide: "Hide"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyLabels
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 1",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay1",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay2",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout12SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout12SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup1Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup1Position
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 2",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay3",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay4",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout34SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout34SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup2Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup2Position
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 3",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay5",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay6",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout56SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout56SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup3Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup3Position
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 4",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay7",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay8",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout78SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout78SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup4Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup4Position
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 5",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay9",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay10",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout910SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout910SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup5Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup5Position
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 6",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay11",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay12",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout1112SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout1112SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup6Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup6Position
        }
      ]
    },
    {
      type: "group",
      displayName: "Property group 7",
      items: [
        {
          type: "property",
          displayName: "First property",
          key: "propertyDisplay13",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "property",
          displayName: "Second property",
          key: "propertyDisplay14",
          placeholder: "Select property",
          default: ""
        },
        {
          type: "toggle",
          displayName: "Show side-by-side",
          key: "propertyLayout1314SideBySide",
          default: DEFAULT_VIEW_SETTINGS.propertyLayout1314SideBySide
        },
        {
          type: "dropdown",
          displayName: "Position",
          key: "propertyGroup7Position",
          options: {
            top: "Top",
            bottom: "Bottom"
          },
          default: DEFAULT_VIEW_SETTINGS.propertyGroup7Position
        }
      ]
    }
  ];
}
function getMasonryViewOptions() {
  return getBasesViewOptions();
}
function readBasesSettings(config, globalSettings, defaultViewSettings) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const titlePropertyValue = config.get("titleProperty");
  const descriptionPropertyValue = config.get("descriptionProperty");
  const imagePropertyValue = config.get("imageProperty");
  const urlPropertyValue = config.get("urlProperty");
  return {
    titleProperty: typeof titlePropertyValue === "string" ? titlePropertyValue : defaultViewSettings.titleProperty,
    descriptionProperty: typeof descriptionPropertyValue === "string" ? descriptionPropertyValue : defaultViewSettings.descriptionProperty,
    imageProperty: typeof imagePropertyValue === "string" ? imagePropertyValue : defaultViewSettings.imageProperty,
    urlProperty: typeof urlPropertyValue === "string" ? urlPropertyValue : defaultViewSettings.urlProperty,
    omitFirstLine: globalSettings.omitFirstLine,
    // From global settings
    showTitle: Boolean(
      (_a = config.get("showTitle")) != null ? _a : defaultViewSettings.showTitle
    ),
    subtitleProperty: (() => {
      const value = config.get("subtitleProperty");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    showTextPreview: Boolean(
      (_b = config.get("showTextPreview")) != null ? _b : defaultViewSettings.showTextPreview
    ),
    fallbackToContent: Boolean(
      (_c = config.get("fallbackToContent")) != null ? _c : defaultViewSettings.fallbackToContent
    ),
    fallbackToEmbeds: (() => {
      const value = config.get("fallbackToEmbeds");
      return value === "always" || value === "if-empty" || value === "never" ? value : defaultViewSettings.fallbackToEmbeds;
    })(),
    propertyDisplay1: (() => {
      const value = config.get("propertyDisplay1");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay2: (() => {
      const value = config.get("propertyDisplay2");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay3: (() => {
      const value = config.get("propertyDisplay3");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay4: (() => {
      const value = config.get("propertyDisplay4");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyLayout12SideBySide: Boolean(
      (_d = config.get("propertyLayout12SideBySide")) != null ? _d : defaultViewSettings.propertyLayout12SideBySide
    ),
    propertyLayout34SideBySide: Boolean(
      (_e = config.get("propertyLayout34SideBySide")) != null ? _e : defaultViewSettings.propertyLayout34SideBySide
    ),
    propertyDisplay5: (() => {
      const value = config.get("propertyDisplay5");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay6: (() => {
      const value = config.get("propertyDisplay6");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyLayout56SideBySide: Boolean(
      (_f = config.get("propertyLayout56SideBySide")) != null ? _f : defaultViewSettings.propertyLayout56SideBySide
    ),
    propertyDisplay7: (() => {
      const value = config.get("propertyDisplay7");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay8: (() => {
      const value = config.get("propertyDisplay8");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyLayout78SideBySide: Boolean(
      (_g = config.get("propertyLayout78SideBySide")) != null ? _g : defaultViewSettings.propertyLayout78SideBySide
    ),
    propertyDisplay9: (() => {
      const value = config.get("propertyDisplay9");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay10: (() => {
      const value = config.get("propertyDisplay10");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyLayout910SideBySide: Boolean(
      (_h = config.get("propertyLayout910SideBySide")) != null ? _h : defaultViewSettings.propertyLayout910SideBySide
    ),
    propertyDisplay11: (() => {
      const value = config.get("propertyDisplay11");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay12: (() => {
      const value = config.get("propertyDisplay12");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyLayout1112SideBySide: Boolean(
      (_i = config.get("propertyLayout1112SideBySide")) != null ? _i : defaultViewSettings.propertyLayout1112SideBySide
    ),
    propertyDisplay13: (() => {
      const value = config.get("propertyDisplay13");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyDisplay14: (() => {
      const value = config.get("propertyDisplay14");
      if (value !== void 0 && value !== null) {
        return typeof value === "string" ? value : "";
      }
      return "";
    })(),
    propertyLayout1314SideBySide: Boolean(
      (_j = config.get("propertyLayout1314SideBySide")) != null ? _j : defaultViewSettings.propertyLayout1314SideBySide
    ),
    propertyGroup1Position: (() => {
      const value = config.get("propertyGroup1Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup1Position;
    })(),
    propertyGroup2Position: (() => {
      const value = config.get("propertyGroup2Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup2Position;
    })(),
    propertyGroup3Position: (() => {
      const value = config.get("propertyGroup3Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup3Position;
    })(),
    propertyGroup4Position: (() => {
      const value = config.get("propertyGroup4Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup4Position;
    })(),
    propertyGroup5Position: (() => {
      const value = config.get("propertyGroup5Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup5Position;
    })(),
    propertyGroup6Position: (() => {
      const value = config.get("propertyGroup6Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup6Position;
    })(),
    propertyGroup7Position: (() => {
      const value = config.get("propertyGroup7Position");
      return value === "top" || value === "bottom" ? value : defaultViewSettings.propertyGroup7Position;
    })(),
    propertyLabels: (() => {
      const value = config.get("propertyLabels");
      return value === "hide" || value === "inline" || value === "above" ? value : defaultViewSettings.propertyLabels;
    })(),
    imageFormat: (() => {
      const value = config.get("imageFormat");
      return value === "thumbnail-left" || value === "thumbnail-right" || value === "thumbnail-top" || value === "thumbnail-bottom" || value === "cover-left" || value === "cover-right" || value === "cover-top" || value === "cover-bottom" || value === "none" ? value : defaultViewSettings.imageFormat;
    })(),
    coverFitMode: (() => {
      const value = config.get("coverFitMode");
      return value === "crop" || value === "contain" ? value : defaultViewSettings.coverFitMode;
    })(),
    timestampFormat: globalSettings.timestampFormat,
    // From global settings
    listMarker: (() => {
      const value = config.get("listMarker");
      return typeof value === "string" ? value : DEFAULT_SETTINGS.listMarker;
    })(),
    randomizeAction: (() => {
      const value = config.get("randomizeAction");
      return typeof value === "string" ? value : DEFAULT_SETTINGS.randomizeAction;
    })(),
    thumbnailCacheSize: globalSettings.thumbnailCacheSize,
    // From global settings
    queryHeight: 0,
    // Not configurable in Bases
    openFileAction: globalSettings.openFileAction,
    // From global settings
    openRandomInNewPane: globalSettings.openRandomInNewPane,
    // From global settings
    showShuffleInRibbon: globalSettings.showShuffleInRibbon,
    // From global settings
    showRandomInRibbon: globalSettings.showRandomInRibbon,
    // From global settings
    smartTimestamp: globalSettings.smartTimestamp,
    // From global settings
    createdTimeProperty: globalSettings.createdTimeProperty,
    // From global settings
    modifiedTimeProperty: globalSettings.modifiedTimeProperty,
    // From global settings
    fallbackToFileMetadata: globalSettings.fallbackToFileMetadata,
    // From global settings
    cardSize: (() => {
      const value = config.get("cardSize");
      return typeof value === "number" ? value : defaultViewSettings.cardSize;
    })(),
    imageAspectRatio: (() => {
      const value = config.get("imageAspectRatio");
      return typeof value === "number" ? value : defaultViewSettings.imageAspectRatio;
    })()
  };
}

// src/bases/card-view.ts
init_property();
init_style_settings();

// src/bases/shared-renderer.ts
var import_obsidian7 = require("obsidian");

// src/shared/scroll-gradient-manager.ts
function updateElementScrollGradient(element) {
  const isScrollable = element.scrollWidth > element.clientWidth;
  if (!isScrollable) {
    element.removeClass("scroll-gradient-left");
    element.removeClass("scroll-gradient-right");
    element.removeClass("scroll-gradient-both");
    return;
  }
  const scrollLeft = element.scrollLeft;
  const scrollWidth = element.scrollWidth;
  const clientWidth = element.clientWidth;
  const atStart = scrollLeft <= SCROLL_TOLERANCE;
  const atEnd = scrollLeft + clientWidth >= scrollWidth - SCROLL_TOLERANCE;
  element.removeClass("scroll-gradient-left");
  element.removeClass("scroll-gradient-right");
  element.removeClass("scroll-gradient-both");
  if (atStart && !atEnd) {
    element.addClass("scroll-gradient-right");
  } else if (atEnd && !atStart) {
    element.addClass("scroll-gradient-left");
  } else if (!atStart && !atEnd) {
    element.addClass("scroll-gradient-both");
  }
}
function updateScrollGradient(element) {
  const wrapper = element.querySelector(
    ".property-content-wrapper"
  );
  const content = element.querySelector(".property-content");
  if (!wrapper || !content) {
    return;
  }
  const isScrollable = content.scrollWidth > wrapper.clientWidth;
  if (!isScrollable) {
    wrapper.removeClass("scroll-gradient-left");
    wrapper.removeClass("scroll-gradient-right");
    wrapper.removeClass("scroll-gradient-both");
    element.removeClass("is-scrollable");
    return;
  }
  element.addClass("is-scrollable");
  updateElementScrollGradient(wrapper);
}
function setupScrollGradients(container, updateGradientFn) {
  const scrollables = container.querySelectorAll(".property-field");
  scrollables.forEach((el) => {
    const element = el;
    const wrapper = element.querySelector(
      ".property-content-wrapper"
    );
    if (!wrapper)
      return;
    requestAnimationFrame(() => {
      updateGradientFn(element);
    });
    wrapper.addEventListener("scroll", () => {
      updateGradientFn(element);
    });
  });
}

// src/bases/shared-renderer.ts
init_style_settings();
init_property();
var SharedCardRenderer = class {
  constructor(app, plugin, updateLayoutRef) {
    this.app = app;
    this.plugin = plugin;
    this.updateLayoutRef = updateLayoutRef;
    this.propertyObservers = [];
    this.zoomCleanupFns = /* @__PURE__ */ new Map();
    this.zoomedOriginalParents = /* @__PURE__ */ new Map();
  }
  /**
   * Cleanup observers and zoom state when renderer is destroyed
   */
  cleanup() {
    this.propertyObservers.forEach((obs) => obs.disconnect());
    this.propertyObservers = [];
    this.zoomCleanupFns.forEach((cleanup, embedEl) => {
      embedEl.classList.remove("is-zoomed");
      const originalParent = this.zoomedOriginalParents.get(embedEl);
      if (originalParent && embedEl.parentElement !== originalParent) {
        originalParent.appendChild(embedEl);
      }
      cleanup();
    });
    this.zoomCleanupFns.clear();
    this.zoomedOriginalParents.clear();
  }
  /**
   * Render text with link detection
   * Uses parseLink utility for comprehensive link detection
   */
  renderTextWithLinks(container, text) {
    const segments = findLinksInText(text);
    for (const segment of segments) {
      if (segment.type === "text") {
        container.createSpan({ text: segment.content });
      } else {
        this.renderLink(container, segment.link);
      }
    }
  }
  renderLink(container, link) {
    if (link.type === "internal") {
      if (link.isEmbed) {
        const embed = container.createSpan({ cls: "internal-embed" });
        embed.dataset.src = link.url;
        embed.setText(link.caption);
        embed.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const newLeaf = e.metaKey || e.ctrlKey;
          void this.app.workspace.openLinkText(link.url, "", newLeaf);
        });
        return;
      }
      const el2 = container.createEl("a", {
        cls: "internal-link",
        text: link.caption,
        href: link.url
      });
      el2.dataset.href = link.url;
      el2.draggable = true;
      el2.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const newLeaf = e.metaKey || e.ctrlKey;
        void this.app.workspace.openLinkText(link.url, "", newLeaf);
      });
      el2.addEventListener("dragstart", (e) => {
        const file = this.app.metadataCache.getFirstLinkpathDest(link.url, "");
        if (!(file instanceof import_obsidian7.TFile))
          return;
        const dragData = this.app.dragManager.dragFile(e, file);
        this.app.dragManager.onDragStart(e, dragData);
      });
      return;
    }
    if (link.isEmbed) {
      const img = container.createEl("img", {
        cls: "external-embed",
        attr: { src: link.url, alt: link.caption }
      });
      img.addEventListener("click", (e) => {
        e.stopPropagation();
      });
      return;
    }
    const el = container.createEl("a", {
      cls: "external-link",
      text: link.caption,
      href: link.url
    });
    if (link.isWebUrl) {
      el.target = "_blank";
      el.rel = "noopener noreferrer";
    }
    el.addEventListener("click", (e) => {
      e.stopPropagation();
    });
    el.addEventListener("dragstart", (e) => {
      var _a, _b;
      (_a = e.dataTransfer) == null ? void 0 : _a.clearData();
      const dragText = link.caption === link.url ? link.url : `[${link.caption}](${link.url})`;
      (_b = e.dataTransfer) == null ? void 0 : _b.setData("text/plain", dragText);
    });
  }
  /**
   * Renders a complete card with all sub-components
   * @param container - Container to append card to
   * @param card - Card data
   * @param entry - Bases entry
   * @param settings - View settings
   * @param hoverParent - Parent object for hover-link event
   */
  renderCard(container, card, entry, settings, hoverParent) {
    const cardEl = container.createDiv("card");
    const imageFormat = settings.imageFormat;
    let format = "none";
    let position = "right";
    if (imageFormat.startsWith("thumbnail-")) {
      format = "thumbnail";
      position = imageFormat.split("-")[1];
    } else if (imageFormat.startsWith("cover-")) {
      format = "cover";
      position = imageFormat.split("-")[1];
    }
    if (format === "cover") {
      cardEl.classList.add("image-format-cover");
    } else if (format === "thumbnail") {
      cardEl.classList.add("image-format-thumbnail");
    }
    if (format === "thumbnail") {
      cardEl.classList.add(`card-thumbnail-${position}`);
    } else if (format === "cover") {
      cardEl.classList.add(`card-cover-${position}`);
    }
    if (format === "cover") {
      cardEl.classList.add(`card-cover-${settings.coverFitMode}`);
    }
    cardEl.setAttribute("data-path", card.path);
    if (settings.openFileAction === "card") {
      cardEl.setAttribute("draggable", "true");
    }
    cardEl.classList.toggle(
      "clickable-card",
      settings.openFileAction === "card"
    );
    cardEl.addEventListener("click", (e) => {
      if (settings.openFileAction === "card") {
        const target = e.target;
        const isLink = target.tagName === "A" || target.closest("a");
        const isTag = target.classList.contains("tag") || target.closest(".tag");
        const isPathSegment = target.classList.contains("path-segment") || target.closest(".path-segment");
        const isImage = target.tagName === "IMG";
        if (!isLink && !isTag && !isPathSegment && !isImage) {
          const newLeaf = e.metaKey || e.ctrlKey;
          const file = this.app.vault.getAbstractFileByPath(card.path);
          if (file instanceof import_obsidian7.TFile) {
            void this.app.workspace.getLeaf(newLeaf).openFile(file);
          }
        }
      }
    });
    cardEl.addEventListener("mouseover", (e) => {
      this.app.workspace.trigger("hover-link", {
        event: e,
        source: "dynamic-views",
        hoverParent,
        targetEl: cardEl,
        linktext: card.path
      });
    });
    cardEl.addEventListener("contextmenu", (e) => {
      e.stopPropagation();
      e.preventDefault();
      const menu = new import_obsidian7.Menu();
      this.app.workspace.trigger(
        "file-menu",
        menu,
        entry.file,
        "file-explorer"
      );
      menu.showAtMouseEvent(e);
    });
    const handleDrag = (e) => {
      const file = this.app.vault.getAbstractFileByPath(card.path);
      if (!(file instanceof import_obsidian7.TFile))
        return;
      const dragData = this.app.dragManager.dragFile(e, file);
      this.app.dragManager.onDragStart(e, dragData);
    };
    if (settings.showTitle || card.hasValidUrl) {
      const containerEl = cardEl.createDiv(
        card.hasValidUrl ? "card-title-container" : "card-title"
      );
      if (settings.showTitle) {
        const titleEl = card.hasValidUrl ? containerEl.createDiv("card-title") : containerEl;
        if (settings.openFileAction === "title") {
          const link = titleEl.createEl("a", {
            cls: "internal-link",
            text: card.title,
            attr: {
              "data-href": card.path,
              href: card.path,
              draggable: "true"
            }
          });
          link.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const newLeaf = e.metaKey || e.ctrlKey;
            void this.app.workspace.openLinkText(card.path, "", newLeaf);
          });
          link.addEventListener("dragstart", handleDrag);
        } else {
          titleEl.appendText(card.title);
        }
        if (document.body.classList.contains(
          "dynamic-views-title-overflow-scroll"
        )) {
          requestAnimationFrame(() => {
            updateElementScrollGradient(titleEl);
          });
          titleEl.addEventListener("scroll", () => {
            updateElementScrollGradient(titleEl);
          });
        }
      }
      if (card.hasValidUrl && card.urlValue) {
        const iconEl = containerEl.createDiv(
          "card-title-url-icon text-icon-button svg-icon"
        );
        iconEl.setAttribute("title", "Open URL");
        (0, import_obsidian7.setIcon)(iconEl, "square-arrow-out-up-right");
        iconEl.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          window.open(card.urlValue, "_blank", "noopener,noreferrer");
        });
      }
    }
    if (settings.subtitleProperty && card.subtitle) {
      const subtitleEl = cardEl.createDiv("card-subtitle");
      this.renderPropertyContent(
        subtitleEl,
        settings.subtitleProperty,
        card.subtitle,
        card,
        entry,
        { ...settings, propertyLabels: "hide" }
      );
      if (document.body.classList.contains(
        "dynamic-views-subtitle-overflow-scroll"
      )) {
        requestAnimationFrame(() => {
          updateElementScrollGradient(subtitleEl);
        });
        subtitleEl.addEventListener("scroll", () => {
          updateElementScrollGradient(subtitleEl);
        });
      }
      const subtitleWrapper = subtitleEl.querySelector(
        ".property-content-wrapper"
      );
      if (subtitleWrapper) {
        requestAnimationFrame(() => {
          updateElementScrollGradient(subtitleWrapper);
        });
        subtitleWrapper.addEventListener("scroll", () => {
          updateElementScrollGradient(subtitleWrapper);
        });
      }
    }
    if (settings.openFileAction === "card") {
      cardEl.addEventListener("dragstart", handleDrag);
    }
    const rawUrls = card.imageUrl ? Array.isArray(card.imageUrl) ? card.imageUrl : [card.imageUrl] : [];
    if (rawUrls.length > 1) {
      console.log(
        "// [Debug] Raw URLs from card.imageUrl:",
        rawUrls.length,
        "items"
      );
      rawUrls.forEach((url, i) => {
        console.log(`//   [${i}]:`, url);
      });
    }
    const imageUrls = Array.from(
      new Set(
        rawUrls.filter(
          (url) => url && typeof url === "string" && url.trim().length > 0
        )
      )
    );
    const hasImage = format !== "none" && imageUrls.length > 0;
    const hasImageAvailable = format !== "none" && card.hasImageAvailable;
    if (format === "cover") {
      const coverWrapper = cardEl.createDiv(
        hasImage ? "card-cover-wrapper" : "card-cover-wrapper card-cover-wrapper-placeholder"
      );
      if (hasImage) {
        const shouldShowCarousel = (position === "top" || position === "bottom") && imageUrls.length >= 2;
        if (shouldShowCarousel) {
          const carouselEl = coverWrapper.createDiv(
            "card-cover card-cover-carousel"
          );
          this.renderCarousel(
            carouselEl,
            imageUrls,
            format,
            position,
            settings
          );
        } else {
          const imageEl = coverWrapper.createDiv("card-cover");
          this.renderImage(
            imageEl,
            imageUrls,
            format,
            position,
            settings,
            cardEl
          );
        }
      } else {
        coverWrapper.createDiv("card-cover-placeholder");
      }
      if (format === "cover" && (position === "left" || position === "right")) {
        const aspectRatio = typeof settings.imageAspectRatio === "string" ? parseFloat(settings.imageAspectRatio) : settings.imageAspectRatio || 1;
        const wrapperRatio = aspectRatio / (aspectRatio + 1);
        const elementSpacing = 8;
        cardEl.style.setProperty(
          "--dynamic-views-wrapper-ratio",
          wrapperRatio.toString()
        );
        const updateWrapperDimensions = () => {
          const cardWidth = cardEl.offsetWidth;
          const targetWidth = Math.floor(wrapperRatio * cardWidth);
          const paddingValue = targetWidth + elementSpacing;
          cardEl.style.setProperty(
            "--dynamic-views-side-cover-width",
            `${targetWidth}px`
          );
          cardEl.style.setProperty(
            "--dynamic-views-side-cover-content-padding",
            `${paddingValue}px`
          );
          return { cardWidth, targetWidth, paddingValue };
        };
        requestAnimationFrame(() => {
          const {
            cardWidth: _cardWidth,
            targetWidth,
            paddingValue
          } = updateWrapperDimensions();
          const cardComputed = getComputedStyle(cardEl);
          console.log(
            "[CSS Variable Check]",
            "cardEl classes:",
            cardEl.className,
            "--side-cover-width on card style:",
            cardEl.style.getPropertyValue("--dynamic-views-side-cover-width"),
            "card computed --side-cover-width:",
            cardComputed.getPropertyValue("--dynamic-views-side-cover-width")
          );
          const computedStyle = cardComputed;
          console.log(
            "[Side Cover Debug - shared-renderer]",
            "position:",
            position,
            "aspectRatio:",
            aspectRatio,
            "wrapperRatio:",
            wrapperRatio,
            "cardOffsetWidth:",
            cardEl.offsetWidth,
            "cardClientWidth:",
            cardEl.clientWidth,
            "padding:",
            computedStyle.padding,
            "targetWidth:",
            targetWidth,
            "paddingValue:",
            paddingValue
          );
          setTimeout(() => {
            const wrapper = cardEl.querySelector(
              ".card-cover-wrapper"
            );
            const cover = cardEl.querySelector(".card-cover");
            const img = cardEl.querySelector(".card-cover img");
            if (wrapper && cover && img) {
              const wrapperComputed = getComputedStyle(wrapper);
              console.log(
                "[Wrapper CSS Debug]",
                "wrapper classes:",
                wrapper.className,
                "wrapper.style.width:",
                wrapper.style.width,
                "wrapper parent is card:",
                wrapper.parentElement === cardEl,
                "wrapper CSS width value:",
                wrapperComputed.getPropertyValue("width"),
                "wrapper resolves variable:",
                wrapperComputed.getPropertyValue(
                  "--dynamic-views-side-cover-width"
                )
              );
              console.log(
                "[Side Cover Rendered]",
                "position:",
                position,
                "wrapperWidth:",
                wrapper.offsetWidth,
                "wrapperComputedWidth:",
                wrapperComputed.width,
                "coverWidth:",
                cover.offsetWidth,
                "coverComputedWidth:",
                getComputedStyle(cover).width,
                "imgWidth:",
                img.offsetWidth,
                "imgComputedWidth:",
                getComputedStyle(img).width
              );
            }
          }, 200);
          const resizeObserver = new ResizeObserver((entries) => {
            for (const entry2 of entries) {
              const target = entry2.target;
              const newCardWidth = target.offsetWidth;
              if (newCardWidth === 0) {
                console.log("[Side Cover Resize] Skipped - cardWidth is 0");
                continue;
              }
              const newTargetWidth = Math.floor(wrapperRatio * newCardWidth);
              const newPaddingValue = newTargetWidth + elementSpacing;
              cardEl.style.setProperty(
                "--dynamic-views-side-cover-width",
                `${newTargetWidth}px`
              );
              cardEl.style.setProperty(
                "--dynamic-views-side-cover-content-padding",
                `${newPaddingValue}px`
              );
              console.log(
                "[Side Cover Resize]",
                "newCardWidth:",
                newCardWidth,
                "newTargetWidth:",
                newTargetWidth,
                "newPaddingValue:",
                newPaddingValue
              );
            }
          });
          resizeObserver.observe(cardEl);
        });
      }
    }
    if (format === "thumbnail" && position === "top" && (hasImage || hasImageAvailable)) {
      if (hasImage) {
        const imageEl = cardEl.createDiv("card-thumbnail");
        this.renderImage(
          imageEl,
          imageUrls,
          format,
          position,
          settings,
          cardEl
        );
      } else {
        cardEl.createDiv("card-thumbnail-placeholder");
      }
    }
    const hasTextPreview = settings.showTextPreview && card.snippet;
    const hasThumbnailInContent = format === "thumbnail" && (position === "left" || position === "right") && (hasImage || hasImageAvailable);
    if (hasTextPreview || hasThumbnailInContent) {
      const contentContainer = cardEl.createDiv("card-content");
      if (hasTextPreview) {
        contentContainer.createDiv({
          cls: "card-text-preview",
          text: card.snippet
        });
      }
      if (hasThumbnailInContent && format === "thumbnail") {
        if (hasImage) {
          const imageEl = contentContainer.createDiv("card-thumbnail");
          this.renderImage(
            imageEl,
            imageUrls,
            format,
            position,
            settings,
            cardEl
          );
        } else {
          contentContainer.createDiv("card-thumbnail-placeholder");
        }
      }
    }
    if (format === "thumbnail" && position === "bottom" && (hasImage || hasImageAvailable)) {
      if (hasImage) {
        const imageEl = cardEl.createDiv("card-thumbnail");
        this.renderImage(
          imageEl,
          imageUrls,
          format,
          position,
          settings,
          cardEl
        );
      } else {
        cardEl.createDiv("card-thumbnail-placeholder");
      }
    }
    this.renderProperties(cardEl, card, entry, settings);
  }
  /**
   * Renders carousel for covers with multiple images
   */
  renderCarousel(carouselEl, imageUrls, format, position, settings) {
    let currentSlide = 0;
    console.log("// CAROUSEL INIT:", {
      totalSlides: imageUrls.length,
      urls: imageUrls
    });
    const slidesContainer = carouselEl.createDiv("carousel-slides");
    const slideElements = imageUrls.map((url, index) => {
      const slideEl = slidesContainer.createDiv("carousel-slide");
      if (index === 0) {
        slideEl.addClass("is-active");
      }
      const imageEmbedContainer = slideEl.createDiv("image-embed");
      if (index === 0) {
        const indicator = imageEmbedContainer.createDiv("carousel-indicator");
        (0, import_obsidian7.setIcon)(indicator, "lucide-images");
      }
      const imgEl = imageEmbedContainer.createEl("img", {
        attr: { src: url, alt: "" }
      });
      imageEmbedContainer.style.setProperty(
        "--cover-image-url",
        `url("${url}")`
      );
      const cardEl = carouselEl.closest(".card");
      if (cardEl && index === 0) {
        setupImageLoadHandler(
          imgEl,
          imageEmbedContainer,
          cardEl,
          this.updateLayoutRef.current || void 0
        );
      }
      return slideEl;
    });
    const updateSlide = (newIndex, direction) => {
      const oldSlide = slideElements[currentSlide];
      const newSlide = slideElements[newIndex];
      console.log("// CAROUSEL TRANSITION:", {
        from: currentSlide,
        to: newIndex,
        direction,
        oldClasses: oldSlide.className,
        newClasses: newSlide.className
      });
      newSlide.removeClass("is-active", "slide-left", "slide-right");
      newSlide.addClass(direction === "next" ? "slide-right" : "slide-left");
      console.log("// After positioning new slide:", newSlide.className);
      void newSlide.offsetHeight;
      oldSlide.removeClass("is-active", "slide-left", "slide-right");
      oldSlide.addClass(direction === "next" ? "slide-left" : "slide-right");
      newSlide.addClass("is-active");
      setTimeout(() => {
        newSlide.removeClass("slide-left", "slide-right");
      }, 310);
      console.log("// After transition:", {
        oldClasses: oldSlide.className,
        newClasses: newSlide.className
      });
      currentSlide = newIndex;
    };
    const leftArrow = carouselEl.createDiv("carousel-nav-left");
    (0, import_obsidian7.setIcon)(leftArrow, "lucide-chevron-left");
    const rightArrow = carouselEl.createDiv("carousel-nav-right");
    (0, import_obsidian7.setIcon)(rightArrow, "lucide-chevron-right");
    leftArrow.addEventListener("click", (e) => {
      e.stopPropagation();
      const newIndex = currentSlide === 0 ? imageUrls.length - 1 : currentSlide - 1;
      const direction = currentSlide === 0 ? "next" : "prev";
      updateSlide(newIndex, direction);
    });
    rightArrow.addEventListener("click", (e) => {
      e.stopPropagation();
      const newIndex = currentSlide === imageUrls.length - 1 ? 0 : currentSlide + 1;
      const direction = currentSlide === imageUrls.length - 1 ? "prev" : "next";
      updateSlide(newIndex, direction);
    });
  }
  /**
   * Renders image (cover or thumbnail) with all necessary handlers
   */
  renderImage(imageEl, imageUrls, format, position, settings, cardEl) {
    const imageEmbedContainer = imageEl.createDiv("image-embed");
    imageEmbedContainer.addEventListener("click", (e) => {
      handleImageZoomClick(
        e,
        cardEl.getAttribute("data-path") || "",
        this.app,
        this.zoomCleanupFns,
        this.zoomedOriginalParents
      );
    });
    const imgEl = imageEmbedContainer.createEl("img", {
      attr: { src: imageUrls[0], alt: "" }
    });
    imageEmbedContainer.style.setProperty(
      "--cover-image-url",
      `url("${imageUrls[0]}")`
    );
    if (cardEl) {
      setupImageLoadHandler(
        imgEl,
        imageEmbedContainer,
        cardEl,
        this.updateLayoutRef.current || void 0
      );
    }
  }
  /**
   * Renders property fields for a card
   */
  renderProperties(cardEl, card, entry, settings) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const props = [
      settings.propertyDisplay1,
      settings.propertyDisplay2,
      settings.propertyDisplay3,
      settings.propertyDisplay4,
      settings.propertyDisplay5,
      settings.propertyDisplay6,
      settings.propertyDisplay7,
      settings.propertyDisplay8,
      settings.propertyDisplay9,
      settings.propertyDisplay10,
      settings.propertyDisplay11,
      settings.propertyDisplay12,
      settings.propertyDisplay13,
      settings.propertyDisplay14
    ];
    const seen = /* @__PURE__ */ new Set();
    const effectiveProps = props.map((prop) => {
      if (!prop || prop === "")
        return "";
      if (seen.has(prop))
        return "";
      seen.add(prop);
      return prop;
    });
    const values = effectiveProps.map(
      (prop) => prop ? resolveBasesProperty(this.app, prop, entry, card, settings) : null
    );
    const row1HasContent = settings.propertyLabels !== "hide" ? effectiveProps[0] !== "" || effectiveProps[1] !== "" : values[0] !== null || values[1] !== null;
    const row2HasContent = settings.propertyLabels !== "hide" ? effectiveProps[2] !== "" || effectiveProps[3] !== "" : values[2] !== null || values[3] !== null;
    const row3HasContent = settings.propertyLabels !== "hide" ? effectiveProps[4] !== "" || effectiveProps[5] !== "" : values[4] !== null || values[5] !== null;
    const row4HasContent = settings.propertyLabels !== "hide" ? effectiveProps[6] !== "" || effectiveProps[7] !== "" : values[6] !== null || values[7] !== null;
    const row5HasContent = settings.propertyLabels !== "hide" ? effectiveProps[8] !== "" || effectiveProps[9] !== "" : values[8] !== null || values[9] !== null;
    const row6HasContent = settings.propertyLabels !== "hide" ? effectiveProps[10] !== "" || effectiveProps[11] !== "" : values[10] !== null || values[11] !== null;
    const row7HasContent = settings.propertyLabels !== "hide" ? effectiveProps[12] !== "" || effectiveProps[13] !== "" : values[12] !== null || values[13] !== null;
    if (!row1HasContent && !row2HasContent && !row3HasContent && !row4HasContent && !row5HasContent && !row6HasContent && !row7HasContent)
      return;
    const row1IsTop = row1HasContent && settings.propertyGroup1Position === "top";
    const row2IsTop = row2HasContent && settings.propertyGroup2Position === "top";
    const row3IsTop = row3HasContent && settings.propertyGroup3Position === "top";
    const row4IsTop = row4HasContent && settings.propertyGroup4Position === "top";
    const row5IsTop = row5HasContent && settings.propertyGroup5Position === "top";
    const row6IsTop = row6HasContent && settings.propertyGroup6Position === "top";
    const row7IsTop = row7HasContent && settings.propertyGroup7Position === "top";
    const hasTopRows = row1IsTop || row2IsTop || row3IsTop || row4IsTop || row5IsTop || row6IsTop || row7IsTop;
    const hasBottomRows = row1HasContent && !row1IsTop || row2HasContent && !row2IsTop || row3HasContent && !row3IsTop || row4HasContent && !row4IsTop || row5HasContent && !row5IsTop || row6HasContent && !row6IsTop || row7HasContent && !row7IsTop;
    const topPropertiesEl = hasTopRows ? cardEl.createDiv(
      "card-properties card-properties-top properties-4field"
    ) : null;
    const bottomPropertiesEl = hasBottomRows ? cardEl.createDiv(
      "card-properties card-properties-bottom properties-4field"
    ) : null;
    const getContainer = (rowNum) => {
      const positions = [
        row1IsTop,
        row2IsTop,
        row3IsTop,
        row4IsTop,
        row5IsTop,
        row6IsTop,
        row7IsTop
      ];
      const isTop = positions[rowNum - 1];
      return isTop ? topPropertiesEl : bottomPropertiesEl;
    };
    if (row1HasContent) {
      const row1El = getContainer(1).createDiv("property-row property-row-1");
      if (settings.propertyLayout12SideBySide) {
        row1El.addClass("property-row-sidebyside");
      }
      const field1El = row1El.createDiv("property-field property-field-1");
      if (effectiveProps[0])
        this.renderPropertyContent(
          field1El,
          effectiveProps[0],
          values[0],
          card,
          entry,
          settings
        );
      const field2El = row1El.createDiv("property-field property-field-2");
      if (effectiveProps[1])
        this.renderPropertyContent(
          field2El,
          effectiveProps[1],
          values[1],
          card,
          entry,
          settings
        );
      const has1 = field1El.children.length > 0 || ((_a = field1El.textContent) == null ? void 0 : _a.trim().length) > 0;
      const has2 = field2El.children.length > 0 || ((_b = field2El.textContent) == null ? void 0 : _b.trim().length) > 0;
      const prop1Set = effectiveProps[0] !== "";
      const prop2Set = effectiveProps[1] !== "";
      if (!has1 && !has2) {
        row1El.remove();
      } else if (has1 && !has2) {
        if (prop2Set) {
          const shouldHide = values[1] === null && shouldHideMissingProperties() || values[1] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field2El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has1 && has2) {
        if (prop1Set) {
          const shouldHide = values[0] === null && shouldHideMissingProperties() || values[0] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field1El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (row2HasContent) {
      const row2El = getContainer(2).createDiv("property-row property-row-2");
      if (settings.propertyLayout34SideBySide) {
        row2El.addClass("property-row-sidebyside");
      }
      const field3El = row2El.createDiv("property-field property-field-3");
      if (effectiveProps[2])
        this.renderPropertyContent(
          field3El,
          effectiveProps[2],
          values[2],
          card,
          entry,
          settings
        );
      const field4El = row2El.createDiv("property-field property-field-4");
      if (effectiveProps[3])
        this.renderPropertyContent(
          field4El,
          effectiveProps[3],
          values[3],
          card,
          entry,
          settings
        );
      const has3 = field3El.children.length > 0 || ((_c = field3El.textContent) == null ? void 0 : _c.trim().length) > 0;
      const has4 = field4El.children.length > 0 || ((_d = field4El.textContent) == null ? void 0 : _d.trim().length) > 0;
      const prop3Set = effectiveProps[2] !== "";
      const prop4Set = effectiveProps[3] !== "";
      if (!has3 && !has4) {
        row2El.remove();
      } else if (has3 && !has4) {
        if (prop4Set) {
          const shouldHide = values[3] === null && shouldHideMissingProperties() || values[3] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field4El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has3 && has4) {
        if (prop3Set) {
          const shouldHide = values[2] === null && shouldHideMissingProperties() || values[2] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field3El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (row3HasContent) {
      const row3El = getContainer(3).createDiv("property-row property-row-3");
      if (settings.propertyLayout56SideBySide) {
        row3El.addClass("property-row-sidebyside");
      }
      const field5El = row3El.createDiv("property-field property-field-5");
      if (effectiveProps[4])
        this.renderPropertyContent(
          field5El,
          effectiveProps[4],
          values[4],
          card,
          entry,
          settings
        );
      const field6El = row3El.createDiv("property-field property-field-6");
      if (effectiveProps[5])
        this.renderPropertyContent(
          field6El,
          effectiveProps[5],
          values[5],
          card,
          entry,
          settings
        );
      const has5 = field5El.children.length > 0 || ((_e = field5El.textContent) == null ? void 0 : _e.trim().length) > 0;
      const has6 = field6El.children.length > 0 || ((_f = field6El.textContent) == null ? void 0 : _f.trim().length) > 0;
      const prop5Set = effectiveProps[4] !== "";
      const prop6Set = effectiveProps[5] !== "";
      if (!has5 && !has6) {
        row3El.remove();
      } else if (has5 && !has6) {
        if (prop6Set) {
          const shouldHide = values[5] === null && shouldHideMissingProperties() || values[5] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field6El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has5 && has6) {
        if (prop5Set) {
          const shouldHide = values[4] === null && shouldHideMissingProperties() || values[4] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field5El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (row4HasContent) {
      const row4El = getContainer(4).createDiv("property-row property-row-4");
      if (settings.propertyLayout78SideBySide) {
        row4El.addClass("property-row-sidebyside");
      }
      const field7El = row4El.createDiv("property-field property-field-7");
      if (effectiveProps[6])
        this.renderPropertyContent(
          field7El,
          effectiveProps[6],
          values[6],
          card,
          entry,
          settings
        );
      const field8El = row4El.createDiv("property-field property-field-8");
      if (effectiveProps[7])
        this.renderPropertyContent(
          field8El,
          effectiveProps[7],
          values[7],
          card,
          entry,
          settings
        );
      const has7 = field7El.children.length > 0 || ((_g = field7El.textContent) == null ? void 0 : _g.trim().length) > 0;
      const has8 = field8El.children.length > 0 || ((_h = field8El.textContent) == null ? void 0 : _h.trim().length) > 0;
      const prop7Set = effectiveProps[6] !== "";
      const prop8Set = effectiveProps[7] !== "";
      if (!has7 && !has8) {
        row4El.remove();
      } else if (has7 && !has8) {
        if (prop8Set) {
          const shouldHide = values[7] === null && shouldHideMissingProperties() || values[7] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field8El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has7 && has8) {
        if (prop7Set) {
          const shouldHide = values[6] === null && shouldHideMissingProperties() || values[6] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field7El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (row5HasContent) {
      const row5El = getContainer(5).createDiv("property-row property-row-5");
      if (settings.propertyLayout910SideBySide) {
        row5El.addClass("property-row-sidebyside");
      }
      const field9El = row5El.createDiv("property-field property-field-9");
      if (effectiveProps[8])
        this.renderPropertyContent(
          field9El,
          effectiveProps[8],
          values[8],
          card,
          entry,
          settings
        );
      const field10El = row5El.createDiv("property-field property-field-10");
      if (effectiveProps[9])
        this.renderPropertyContent(
          field10El,
          effectiveProps[9],
          values[9],
          card,
          entry,
          settings
        );
      const has9 = field9El.children.length > 0 || ((_i = field9El.textContent) == null ? void 0 : _i.trim().length) > 0;
      const has10 = field10El.children.length > 0 || ((_j = field10El.textContent) == null ? void 0 : _j.trim().length) > 0;
      const prop9Set = effectiveProps[8] !== "";
      const prop10Set = effectiveProps[9] !== "";
      if (!has9 && !has10) {
        row5El.remove();
      } else if (has9 && !has10) {
        if (prop10Set) {
          const shouldHide = values[9] === null && shouldHideMissingProperties() || values[9] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field10El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has9 && has10) {
        if (prop9Set) {
          const shouldHide = values[8] === null && shouldHideMissingProperties() || values[8] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field9El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (row6HasContent) {
      const row6El = getContainer(6).createDiv("property-row property-row-6");
      if (settings.propertyLayout1112SideBySide) {
        row6El.addClass("property-row-sidebyside");
      }
      const field11El = row6El.createDiv("property-field property-field-11");
      if (effectiveProps[10])
        this.renderPropertyContent(
          field11El,
          effectiveProps[10],
          values[10],
          card,
          entry,
          settings
        );
      const field12El = row6El.createDiv("property-field property-field-12");
      if (effectiveProps[11])
        this.renderPropertyContent(
          field12El,
          effectiveProps[11],
          values[11],
          card,
          entry,
          settings
        );
      const has11 = field11El.children.length > 0 || ((_k = field11El.textContent) == null ? void 0 : _k.trim().length) > 0;
      const has12 = field12El.children.length > 0 || ((_l = field12El.textContent) == null ? void 0 : _l.trim().length) > 0;
      const prop11Set = effectiveProps[10] !== "";
      const prop12Set = effectiveProps[11] !== "";
      if (!has11 && !has12) {
        row6El.remove();
      } else if (has11 && !has12) {
        if (prop12Set) {
          const shouldHide = values[11] === null && shouldHideMissingProperties() || values[11] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field12El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has11 && has12) {
        if (prop11Set) {
          const shouldHide = values[10] === null && shouldHideMissingProperties() || values[10] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field11El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (row7HasContent) {
      const row7El = getContainer(7).createDiv("property-row property-row-7");
      if (settings.propertyLayout1314SideBySide) {
        row7El.addClass("property-row-sidebyside");
      }
      const field13El = row7El.createDiv("property-field property-field-13");
      if (effectiveProps[12])
        this.renderPropertyContent(
          field13El,
          effectiveProps[12],
          values[12],
          card,
          entry,
          settings
        );
      const field14El = row7El.createDiv("property-field property-field-14");
      if (effectiveProps[13])
        this.renderPropertyContent(
          field14El,
          effectiveProps[13],
          values[13],
          card,
          entry,
          settings
        );
      const has13 = field13El.children.length > 0 || ((_m = field13El.textContent) == null ? void 0 : _m.trim().length) > 0;
      const has14 = field14El.children.length > 0 || ((_n = field14El.textContent) == null ? void 0 : _n.trim().length) > 0;
      const prop13Set = effectiveProps[12] !== "";
      const prop14Set = effectiveProps[13] !== "";
      if (!has13 && !has14) {
        row7El.remove();
      } else if (has13 && !has14) {
        if (prop14Set) {
          const shouldHide = values[13] === null && shouldHideMissingProperties() || values[13] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field14El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      } else if (!has13 && has14) {
        if (prop13Set) {
          const shouldHide = values[12] === null && shouldHideMissingProperties() || values[12] === "" && shouldHideEmptyProperties();
          if (!shouldHide) {
            const placeholderContent = field13El.createDiv("property-content");
            const markerSpan = placeholderContent.createSpan("empty-value-marker");
            markerSpan.textContent = getEmptyValueMarker();
          }
        }
      }
    }
    if (topPropertiesEl && topPropertiesEl.children.length === 0) {
      topPropertiesEl.remove();
    }
    if (bottomPropertiesEl && bottomPropertiesEl.children.length === 0) {
      bottomPropertiesEl.remove();
    }
    if (topPropertiesEl && topPropertiesEl.children.length > 0 || bottomPropertiesEl && bottomPropertiesEl.children.length > 0) {
      this.measurePropertyFields(cardEl);
      setupScrollGradients(cardEl, updateScrollGradient);
    }
  }
  /**
   * Renders individual property content
   */
  renderPropertyContent(container, propertyName, resolvedValue, card, entry, settings) {
    if (propertyName === "") {
      return;
    }
    const stringValue = typeof resolvedValue === "string" ? resolvedValue : null;
    if (!stringValue && settings.propertyLabels === "hide") {
      return;
    }
    if (stringValue === null && shouldHideMissingProperties()) {
      return;
    }
    if (stringValue === "" && shouldHideEmptyProperties()) {
      return;
    }
    if (settings.propertyLabels === "hide") {
      if ((propertyName === "tags" || propertyName === "note.tags") && card.yamlTags.length === 0) {
        return;
      }
      if ((propertyName === "file.tags" || propertyName === "file tags") && card.tags.length === 0) {
        return;
      }
      if ((propertyName === "file.path" || propertyName === "path" || propertyName === "file path") && card.folderPath.length === 0) {
        return;
      }
    }
    if (settings.propertyLabels === "above") {
      const labelEl = container.createDiv("property-label");
      labelEl.textContent = getPropertyLabel(propertyName);
    }
    if (settings.propertyLabels === "inline") {
      const labelSpan = container.createSpan("property-label-inline");
      labelSpan.textContent = getPropertyLabel(propertyName) + " ";
    }
    const contentWrapper = container.createDiv("property-content-wrapper");
    const metaContent = contentWrapper.createDiv("property-content");
    if (!stringValue) {
      const markerSpan = metaContent.createSpan("empty-value-marker");
      markerSpan.textContent = getEmptyValueMarker();
      return;
    }
    if (stringValue.startsWith('{"type":"array","items":[')) {
      try {
        const arrayData = JSON.parse(stringValue);
        if (arrayData.type === "array" && Array.isArray(arrayData.items)) {
          const listWrapper = metaContent.createSpan("list-wrapper");
          const separator = getListSeparator();
          arrayData.items.forEach((item, idx) => {
            const span = listWrapper.createSpan();
            const listItem = span.createSpan({ cls: "list-item" });
            this.renderTextWithLinks(listItem, item);
            if (idx < arrayData.items.length - 1) {
              span.createSpan({ cls: "list-separator", text: separator });
            }
          });
          return;
        }
      } catch (e) {
      }
    }
    const isKnownTimestampProperty = propertyName === "file.mtime" || propertyName === "file.ctime" || propertyName === "modified time" || propertyName === "created time";
    if (isKnownTimestampProperty) {
      const timestampWrapper = metaContent.createSpan();
      if (showTimestampIcon() && settings.propertyLabels === "hide") {
        const iconName = getTimestampIcon(propertyName, settings);
        const iconEl = timestampWrapper.createSpan("timestamp-icon");
        (0, import_obsidian7.setIcon)(iconEl, iconName);
      }
      timestampWrapper.appendText(stringValue);
    } else if ((propertyName === "tags" || propertyName === "note.tags") && card.yamlTags.length > 0) {
      const showHashPrefix = showTagHashPrefix();
      const tagsWrapper = metaContent.createDiv("tags-wrapper");
      card.yamlTags.forEach((tag) => {
        const tagEl = tagsWrapper.createEl("a", {
          cls: "tag",
          text: showHashPrefix ? "#" + tag : tag,
          href: "#"
        });
        tagEl.addEventListener("click", (e) => {
          var _a;
          e.preventDefault();
          const searchPlugin = this.plugin.app.internalPlugins.plugins["global-search"];
          if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
            searchPlugin.instance.openGlobalSearch("tag:" + tag);
          }
        });
      });
    } else if ((propertyName === "file.tags" || propertyName === "file tags") && card.tags.length > 0) {
      const showHashPrefix = showTagHashPrefix();
      const tagsWrapper = metaContent.createDiv("tags-wrapper");
      card.tags.forEach((tag) => {
        const tagEl = tagsWrapper.createEl("a", {
          cls: "tag",
          text: showHashPrefix ? "#" + tag : tag,
          href: "#"
        });
        tagEl.addEventListener("click", (e) => {
          var _a;
          e.preventDefault();
          const searchPlugin = this.plugin.app.internalPlugins.plugins["global-search"];
          if ((_a = searchPlugin == null ? void 0 : searchPlugin.instance) == null ? void 0 : _a.openGlobalSearch) {
            searchPlugin.instance.openGlobalSearch("tag:" + tag);
          }
        });
      });
    } else if ((propertyName === "file.path" || propertyName === "path" || propertyName === "file path") && card.path.length > 0) {
      const pathWrapper = metaContent.createDiv("path-wrapper");
      const segments = card.path.split("/").filter((f) => f);
      segments.forEach((segment, idx) => {
        const span = pathWrapper.createSpan();
        const isLastSegment = idx === segments.length - 1;
        const segmentClass = isLastSegment ? "path-segment filename-segment" : "path-segment file-path-segment";
        const segmentEl = span.createSpan({ cls: segmentClass, text: segment });
        const cumulativePath = segments.slice(0, idx + 1).join("/");
        segmentEl.addEventListener("click", (e) => {
          var _a, _b, _c;
          e.stopPropagation();
          if (isLastSegment) {
            const file = this.app.vault.getAbstractFileByPath(card.path);
            if (file instanceof import_obsidian7.TFile) {
              void this.app.workspace.getLeaf(false).openFile(file);
            }
          } else {
            const fileExplorer = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["file-explorer"];
            if ((_c = fileExplorer == null ? void 0 : fileExplorer.instance) == null ? void 0 : _c.revealInFolder) {
              const folderFile = this.app.vault.getAbstractFileByPath(cumulativePath);
              if (folderFile) {
                fileExplorer.instance.revealInFolder(folderFile);
              }
            }
          }
        });
        if (!isLastSegment) {
          segmentEl.addEventListener("contextmenu", (e) => {
            e.stopPropagation();
            e.preventDefault();
            const folderFile = this.app.vault.getAbstractFileByPath(cumulativePath);
            if (folderFile instanceof import_obsidian7.TFolder) {
              const menu = new import_obsidian7.Menu();
              this.app.workspace.trigger(
                "file-menu",
                menu,
                folderFile,
                "file-explorer"
              );
              menu.showAtMouseEvent(e);
            }
          });
        }
        if (idx < segments.length - 1) {
          span.createSpan({ cls: "path-separator", text: "/" });
        }
      });
    } else if ((propertyName === "file.folder" || propertyName === "folder") && card.folderPath.length > 0) {
      const folderWrapper = metaContent.createDiv("path-wrapper");
      const folders = card.folderPath.split("/").filter((f) => f);
      folders.forEach((folder, idx) => {
        const span = folderWrapper.createSpan();
        const segmentEl = span.createSpan({
          cls: "path-segment folder-segment",
          text: folder
        });
        const cumulativePath = folders.slice(0, idx + 1).join("/");
        segmentEl.addEventListener("click", (e) => {
          var _a, _b, _c;
          e.stopPropagation();
          const fileExplorer = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["file-explorer"];
          if ((_c = fileExplorer == null ? void 0 : fileExplorer.instance) == null ? void 0 : _c.revealInFolder) {
            const folderFile = this.app.vault.getAbstractFileByPath(cumulativePath);
            if (folderFile) {
              fileExplorer.instance.revealInFolder(folderFile);
            }
          }
        });
        segmentEl.addEventListener("contextmenu", (e) => {
          e.stopPropagation();
          e.preventDefault();
          const folderFile = this.app.vault.getAbstractFileByPath(cumulativePath);
          if (folderFile instanceof import_obsidian7.TFolder) {
            const menu = new import_obsidian7.Menu();
            this.app.workspace.trigger(
              "file-menu",
              menu,
              folderFile,
              "file-explorer"
            );
            menu.showAtMouseEvent(e);
          }
        });
        if (idx < folders.length - 1) {
          span.createSpan({ cls: "path-separator", text: "/" });
        }
      });
    } else {
      const textWrapper = metaContent.createDiv("text-wrapper");
      this.renderTextWithLinks(textWrapper, stringValue);
    }
    if (!metaContent.textContent || metaContent.textContent.trim().length === 0) {
      metaContent.remove();
    }
  }
  /**
   * Measures property fields for side-by-side layout
   */
  measurePropertyFields(container) {
    const rows = container.querySelectorAll(".property-row-sidebyside");
    rows.forEach((row) => {
      const rowEl = row;
      const field1 = rowEl.querySelector(
        ".property-field-1, .property-field-3"
      );
      const field2 = rowEl.querySelector(
        ".property-field-2, .property-field-4"
      );
      if (field1 && field2) {
        requestAnimationFrame(() => {
          this.measureSideBySideRow(rowEl, field1, field2);
        });
        const card = rowEl.closest(".card");
        const observer = new ResizeObserver(() => {
          this.measureSideBySideRow(rowEl, field1, field2);
        });
        observer.observe(card);
        this.propertyObservers.push(observer);
      }
    });
  }
  /**
   * Measures and applies widths for side-by-side row
   */
  measureSideBySideRow(row, field1, field2) {
    try {
      const card = row.closest(".card");
      const cardProperties = row.closest(".card-properties");
      row.removeClass("property-measured");
      row.addClass("property-measuring");
      void row.offsetWidth;
      const wrapper1 = field1.querySelector(
        ".property-content-wrapper"
      );
      const wrapper2 = field2.querySelector(
        ".property-content-wrapper"
      );
      const label1 = field1.querySelector(
        ".property-label-inline"
      );
      const label2 = field2.querySelector(
        ".property-label-inline"
      );
      let width1 = wrapper1 ? wrapper1.scrollWidth : 0;
      let width2 = wrapper2 ? wrapper2.scrollWidth : 0;
      const inlineLabelGap = parseFloat(getComputedStyle(field1).gap) || 4;
      if (label1) {
        width1 += label1.scrollWidth + inlineLabelGap;
      }
      if (label2) {
        width2 += label2.scrollWidth + inlineLabelGap;
      }
      const sideCoverPadding = parseFloat(
        getComputedStyle(card).getPropertyValue(
          "--dynamic-views-side-cover-content-padding"
        )
      ) || 0;
      let containerWidth;
      if (sideCoverPadding > 0) {
        const cardContentWidth = card.clientWidth;
        containerWidth = cardContentWidth - sideCoverPadding;
      } else {
        containerWidth = cardProperties.clientWidth;
      }
      if (containerWidth <= 0) {
        return;
      }
      const fieldGap = parseFloat(getComputedStyle(row).gap) || 8;
      const availableWidth = containerWidth - fieldGap;
      const percent1 = width1 / availableWidth * 100;
      const percent2 = width2 / availableWidth * 100;
      let field1Width;
      let field2Width;
      if (percent1 <= 50) {
        field1Width = `${width1}px`;
        field2Width = `${availableWidth - width1}px`;
      } else if (percent2 <= 50) {
        field1Width = `${availableWidth - width2}px`;
        field2Width = `${width2}px`;
      } else {
        const half = availableWidth / 2;
        field1Width = `${half}px`;
        field2Width = `${half}px`;
      }
      row.style.setProperty("--field1-width", field1Width);
      row.style.setProperty("--field2-width", field2Width);
      row.addClass("property-measured");
      if (wrapper1)
        wrapper1.scrollLeft = 0;
      if (wrapper2)
        wrapper2.scrollLeft = 0;
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          updateScrollGradient(field1);
          updateScrollGradient(field2);
        });
      });
    } finally {
      row.removeClass("property-measuring");
    }
  }
};

// src/bases/card-view.ts
var GRID_VIEW_TYPE = "dynamic-views-grid";
var DynamicViewsCardView = class extends import_obsidian8.BasesView {
  constructor(controller, scrollEl) {
    super(controller);
    this.type = GRID_VIEW_TYPE;
    this.snippets = {};
    this.images = {};
    this.hasImageAvailable = {};
    this.updateLayoutRef = { current: null };
    this.focusableCardIndex = 0;
    this.displayedCount = 50;
    this.isLoading = false;
    this.scrollListener = null;
    this.scrollThrottleTimeout = null;
    this.resizeObserver = null;
    this.isShuffled = false;
    this.shuffledOrder = [];
    this.lastSortMethod = null;
    // Style Settings compatibility - must be own property (not prototype)
    this.setSettings = () => {
    };
    this.containerEl = scrollEl.createDiv({
      cls: "dynamic-views dynamic-views-bases-container"
    });
    this.plugin = this.app.plugins.plugins["dynamic-views"];
    this.cardRenderer = new SharedCardRenderer(
      this.app,
      this.plugin,
      this.updateLayoutRef
    );
    this.displayedCount = this.app.isMobile ? 25 : BATCH_SIZE;
    const observer = new MutationObserver((mutations) => {
      var _a;
      for (const mutation of mutations) {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          const oldClasses = ((_a = mutation.oldValue) == null ? void 0 : _a.split(" ")) || [];
          const newClasses = document.body.className.split(" ");
          const dynamicViewsChanged = oldClasses.filter((c) => c.startsWith("dynamic-views-")).sort().join() !== newClasses.filter((c) => c.startsWith("dynamic-views-")).sort().join();
          if (dynamicViewsChanged) {
            this.onDataUpdated();
            break;
          }
        }
      }
    });
    observer.observe(document.body, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: ["class"]
    });
    this.register(() => observer.disconnect());
  }
  onload() {
    super.onload();
  }
  onDataUpdated() {
    void (async () => {
      var _a;
      if (!this.data) {
        return;
      }
      const groupedData = this.data.groupedData;
      const allEntries = this.data.data;
      const settings = readBasesSettings(
        this.config,
        this.plugin.persistenceManager.getGlobalSettings(),
        this.plugin.persistenceManager.getDefaultViewSettings()
      );
      const containerWidth = this.containerEl.clientWidth;
      const cardSize = settings.cardSize;
      const minColumns = getMinGridColumns();
      const gap = getCardSpacing();
      const cols = Math.max(
        minColumns,
        Math.floor((containerWidth + gap) / (cardSize + gap))
      );
      this.containerEl.style.setProperty("--grid-columns", String(cols));
      this.containerEl.style.setProperty(
        "--dynamic-views-image-aspect-ratio",
        String(settings.imageAspectRatio)
      );
      const savedScrollTop = this.containerEl.scrollTop;
      const sortMethod = this.getSortMethod();
      if (this.lastSortMethod !== null && this.lastSortMethod !== sortMethod) {
        this.isShuffled = false;
        this.shuffledOrder = [];
      }
      this.lastSortMethod = sortMethod;
      const processedGroups = groupedData.map((group) => {
        let groupEntries = [...group.entries];
        if (this.isShuffled && this.shuffledOrder.length > 0) {
          groupEntries = groupEntries.sort((a, b) => {
            const indexA = this.shuffledOrder.indexOf(a.file.path);
            const indexB = this.shuffledOrder.indexOf(b.file.path);
            return indexA - indexB;
          });
        }
        return { group, entries: groupEntries };
      });
      const visibleEntries = [];
      let remainingCount = this.displayedCount;
      for (const processedGroup of processedGroups) {
        if (remainingCount <= 0)
          break;
        const entriesToTake = Math.min(
          processedGroup.entries.length,
          remainingCount
        );
        visibleEntries.push(...processedGroup.entries.slice(0, entriesToTake));
        remainingCount -= entriesToTake;
      }
      await this.loadContentForEntries(visibleEntries, settings);
      this.containerEl.empty();
      this.cardRenderer.cleanup();
      const feedEl = this.containerEl.createDiv("dynamic-views-grid");
      let displayedSoFar = 0;
      for (const processedGroup of processedGroups) {
        if (displayedSoFar >= this.displayedCount)
          break;
        const entriesToDisplay = Math.min(
          processedGroup.entries.length,
          this.displayedCount - displayedSoFar
        );
        if (entriesToDisplay === 0)
          continue;
        const groupEntries = processedGroup.entries.slice(0, entriesToDisplay);
        const groupEl = feedEl.createDiv("dynamic-views-group");
        if (processedGroup.group.hasKey()) {
          const headerEl = groupEl.createDiv("bases-group-heading");
          const groupBy = this.config.groupBy;
          if (groupBy == null ? void 0 : groupBy.property) {
            const propertyEl = headerEl.createDiv("bases-group-property");
            const propertyName = this.config.getDisplayName(groupBy.property);
            propertyEl.setText(propertyName);
          }
          const valueEl = headerEl.createDiv("bases-group-value");
          const keyValue = ((_a = processedGroup.group.key) == null ? void 0 : _a.toString()) || "";
          valueEl.setText(keyValue);
        }
        const cards = transformBasesEntries(
          this.app,
          groupEntries,
          settings,
          sortMethod,
          false,
          this.snippets,
          this.images,
          this.hasImageAvailable
        );
        for (let i = 0; i < cards.length; i++) {
          const card = cards[i];
          const entry = groupEntries[i];
          this.renderCard(groupEl, card, entry, displayedSoFar + i, settings);
        }
        displayedSoFar += entriesToDisplay;
      }
      if (savedScrollTop > 0) {
        this.containerEl.scrollTop = savedScrollTop;
      }
      this.setupInfiniteScroll(allEntries.length);
      if (!this.resizeObserver) {
        this.resizeObserver = new ResizeObserver(() => {
          const containerWidth2 = this.containerEl.clientWidth;
          const cardSize2 = settings.cardSize;
          const minColumns2 = getMinGridColumns();
          const gap2 = getCardSpacing();
          const cols2 = Math.max(
            minColumns2,
            Math.floor((containerWidth2 + gap2) / (cardSize2 + gap2))
          );
          this.containerEl.style.setProperty("--grid-columns", String(cols2));
        });
        this.resizeObserver.observe(this.containerEl);
      }
      this.isLoading = false;
    })();
  }
  renderCard(container, card, entry, index, settings) {
    this.cardRenderer.renderCard(container, card, entry, settings, this);
  }
  getSortMethod() {
    const sortConfigs = this.config.getSort();
    if (sortConfigs && sortConfigs.length > 0) {
      const firstSort = sortConfigs[0];
      const property = firstSort.property;
      const direction = firstSort.direction.toLowerCase();
      if (property.includes("ctime")) {
        const result = `ctime-${direction}`;
        return result;
      }
      if (property.includes("mtime")) {
        const result = `mtime-${direction}`;
        return result;
      }
    }
    return "mtime-desc";
  }
  async loadContentForEntries(entries, settings) {
    if (settings.showTextPreview) {
      const snippetEntries = entries.filter((entry) => !(entry.file.path in this.snippets)).map((entry) => {
        const file = this.app.vault.getAbstractFileByPath(entry.file.path);
        if (!(file instanceof import_obsidian8.TFile))
          return null;
        const descValue = getFirstBasesPropertyValue(
          this.app,
          entry,
          settings.descriptionProperty
        );
        return {
          path: entry.file.path,
          file,
          descriptionData: descValue == null ? void 0 : descValue.data
        };
      }).filter(
        (e) => e !== null
      );
      await loadSnippetsForEntries(
        snippetEntries,
        settings.fallbackToContent,
        settings.omitFirstLine,
        this.app,
        this.snippets
      );
    }
    if (settings.imageFormat !== "none") {
      const imageEntries = entries.filter((entry) => !(entry.file.path in this.images)).map((entry) => {
        const file = this.app.vault.getAbstractFileByPath(entry.file.path);
        if (!(file instanceof import_obsidian8.TFile))
          return null;
        const imagePropertyValues = getAllBasesImagePropertyValues(
          this.app,
          entry,
          settings.imageProperty
        );
        return {
          path: entry.file.path,
          file,
          imagePropertyValues
        };
      }).filter((e) => e !== null);
      await loadImagesForEntries(
        imageEntries,
        settings.fallbackToEmbeds,
        this.app,
        this.images,
        this.hasImageAvailable
      );
    }
  }
  setupInfiniteScroll(totalEntries) {
    if (this.scrollListener) {
      this.containerEl.removeEventListener("scroll", this.scrollListener);
      this.scrollListener = null;
    }
    if (this.displayedCount >= totalEntries) {
      return;
    }
    this.scrollListener = () => {
      if (this.scrollThrottleTimeout !== null) {
        return;
      }
      if (this.isLoading) {
        return;
      }
      const scrollTop = this.containerEl.scrollTop;
      const scrollHeight = this.containerEl.scrollHeight;
      const clientHeight = this.containerEl.clientHeight;
      const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);
      const isMobile = this.app.isMobile;
      const viewportMultiplier = isMobile ? 1 : 2;
      const threshold = clientHeight * viewportMultiplier;
      if (distanceFromBottom < threshold && this.displayedCount < totalEntries) {
        this.isLoading = true;
        const batchSize = 50;
        this.displayedCount = Math.min(
          this.displayedCount + batchSize,
          totalEntries
        );
        this.onDataUpdated();
      }
      this.scrollThrottleTimeout = window.setTimeout(() => {
        this.scrollThrottleTimeout = null;
      }, 100);
    };
    this.containerEl.addEventListener("scroll", this.scrollListener);
    this.register(() => {
      if (this.scrollListener) {
        this.containerEl.removeEventListener("scroll", this.scrollListener);
      }
      if (this.scrollThrottleTimeout !== null) {
        window.clearTimeout(this.scrollThrottleTimeout);
      }
    });
  }
  onunload() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    this.cardRenderer.cleanup();
  }
  focus() {
    this.containerEl.focus({ preventScroll: true });
  }
};
var cardViewOptions = getBasesViewOptions;

// src/bases/masonry-view.ts
var import_obsidian9 = require("obsidian");
init_property();
init_style_settings();
var MASONRY_VIEW_TYPE = "dynamic-views-masonry";
var DynamicViewsMasonryView = class extends import_obsidian9.BasesView {
  constructor(controller, scrollEl) {
    super(controller);
    this.type = MASONRY_VIEW_TYPE;
    this.snippets = {};
    this.images = {};
    this.hasImageAvailable = {};
    this.updateLayoutRef = { current: null };
    this.focusableCardIndex = 0;
    this.masonryContainer = null;
    this.displayedCount = 50;
    this.isLoading = false;
    this.scrollListener = null;
    this.scrollThrottleTimeout = null;
    this.resizeObserver = null;
    this.isShuffled = false;
    this.shuffledOrder = [];
    this.lastSortMethod = null;
    // Style Settings compatibility - must be own property (not prototype)
    this.setSettings = () => {
    };
    this.containerEl = scrollEl.createDiv({
      cls: "dynamic-views dynamic-views-bases-container"
    });
    this.plugin = this.app.plugins.plugins["dynamic-views"];
    this.cardRenderer = new SharedCardRenderer(
      this.app,
      this.plugin,
      this.updateLayoutRef
    );
    this.displayedCount = this.app.isMobile ? 25 : BATCH_SIZE;
    const observer = new MutationObserver((mutations) => {
      var _a;
      for (const mutation of mutations) {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          const oldClasses = ((_a = mutation.oldValue) == null ? void 0 : _a.split(" ")) || [];
          const newClasses = document.body.className.split(" ");
          const dynamicViewsChanged = oldClasses.filter((c) => c.startsWith("dynamic-views-")).sort().join() !== newClasses.filter((c) => c.startsWith("dynamic-views-")).sort().join();
          if (dynamicViewsChanged) {
            this.onDataUpdated();
            break;
          }
        }
      }
    });
    observer.observe(document.body, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: ["class"]
    });
    this.register(() => observer.disconnect());
  }
  onload() {
    super.onload();
  }
  onDataUpdated() {
    void (async () => {
      var _a;
      if (!this.data) {
        return;
      }
      const groupedData = this.data.groupedData;
      const allEntries = this.data.data;
      const settings = readBasesSettings(
        this.config,
        this.plugin.persistenceManager.getGlobalSettings(),
        this.plugin.persistenceManager.getDefaultViewSettings()
      );
      this.containerEl.style.setProperty(
        "--dynamic-views-image-aspect-ratio",
        String(settings.imageAspectRatio)
      );
      const savedScrollTop = this.containerEl.scrollTop;
      let anchorCardPath = null;
      if (savedScrollTop > 0 && this.masonryContainer) {
        const cards = this.masonryContainer.querySelectorAll(".card");
        const containerTop = this.containerEl.getBoundingClientRect().top;
        for (const card of Array.from(cards)) {
          const cardTop = card.getBoundingClientRect().top;
          if (cardTop >= containerTop - 50) {
            anchorCardPath = card.getAttribute("data-path");
            break;
          }
        }
      }
      const sortMethod = this.getSortMethod();
      if (this.lastSortMethod !== null && this.lastSortMethod !== sortMethod) {
        this.isShuffled = false;
        this.shuffledOrder = [];
      }
      this.lastSortMethod = sortMethod;
      const processedGroups = groupedData.map((group) => {
        let groupEntries = [...group.entries];
        if (this.isShuffled && this.shuffledOrder.length > 0) {
          groupEntries = groupEntries.sort((a, b) => {
            const indexA = this.shuffledOrder.indexOf(a.file.path);
            const indexB = this.shuffledOrder.indexOf(b.file.path);
            return indexA - indexB;
          });
        }
        return { group, entries: groupEntries };
      });
      const visibleEntries = [];
      let remainingCount = this.displayedCount;
      for (const processedGroup of processedGroups) {
        if (remainingCount <= 0)
          break;
        const entriesToTake = Math.min(
          processedGroup.entries.length,
          remainingCount
        );
        visibleEntries.push(...processedGroup.entries.slice(0, entriesToTake));
        remainingCount -= entriesToTake;
      }
      await this.loadContentForEntries(visibleEntries, settings);
      this.containerEl.empty();
      this.cardRenderer.cleanup();
      this.masonryContainer = this.containerEl.createDiv(
        "dynamic-views-masonry"
      );
      this.setupMasonryLayout(settings);
      let displayedSoFar = 0;
      for (const processedGroup of processedGroups) {
        if (displayedSoFar >= this.displayedCount)
          break;
        const entriesToDisplay = Math.min(
          processedGroup.entries.length,
          this.displayedCount - displayedSoFar
        );
        if (entriesToDisplay === 0)
          continue;
        const groupEntries = processedGroup.entries.slice(0, entriesToDisplay);
        const groupEl = this.masonryContainer.createDiv("dynamic-views-group");
        if (processedGroup.group.hasKey()) {
          const headerEl = groupEl.createDiv("bases-group-heading");
          const groupBy = this.config.groupBy;
          if (groupBy == null ? void 0 : groupBy.property) {
            const propertyEl = headerEl.createDiv("bases-group-property");
            const propertyName = this.config.getDisplayName(groupBy.property);
            propertyEl.setText(propertyName);
          }
          const valueEl = headerEl.createDiv("bases-group-value");
          const keyValue = ((_a = processedGroup.group.key) == null ? void 0 : _a.toString()) || "";
          valueEl.setText(keyValue);
        }
        const cards = transformBasesEntries(
          this.app,
          groupEntries,
          settings,
          sortMethod,
          false,
          this.snippets,
          this.images,
          this.hasImageAvailable
        );
        for (let i = 0; i < cards.length; i++) {
          const card = cards[i];
          const entry = groupEntries[i];
          this.renderCard(groupEl, card, entry, displayedSoFar + i, settings);
        }
        displayedSoFar += entriesToDisplay;
      }
      if (this.updateLayoutRef.current) {
        setTimeout(() => {
          if (this.updateLayoutRef.current) {
            this.updateLayoutRef.current();
          }
          if (savedScrollTop > 0) {
            requestAnimationFrame(() => {
              if (anchorCardPath && this.masonryContainer) {
                const anchorCard = this.masonryContainer.querySelector(
                  `.card[data-path="${anchorCardPath}"]`
                );
                if (anchorCard) {
                  const cardTop = anchorCard.offsetTop;
                  this.containerEl.scrollTop = Math.max(0, cardTop - 100);
                  return;
                }
              }
              this.containerEl.scrollTop = savedScrollTop;
            });
          }
        }, 50);
      } else {
        if (savedScrollTop > 0) {
          this.containerEl.scrollTop = savedScrollTop;
        }
      }
      this.setupInfiniteScroll(allEntries.length);
      this.isLoading = false;
    })();
  }
  setupMasonryLayout(settings) {
    if (!this.masonryContainer)
      return;
    const minColumns = getMinMasonryColumns();
    this.updateLayoutRef.current = () => {
      if (!this.masonryContainer)
        return;
      const cards = Array.from(
        this.masonryContainer.querySelectorAll(".card")
      );
      if (cards.length === 0)
        return;
      const containerWidth = this.masonryContainer.clientWidth;
      const gap = getCardSpacing();
      console.log("masonry calc:", { containerWidth, cardSize: settings.cardSize, minColumns, gap });
      const result = calculateMasonryLayout({
        cards,
        containerWidth,
        cardSize: settings.cardSize,
        minColumns,
        gap
      });
      applyMasonryLayout(this.masonryContainer, cards, result);
    };
    const resizeObserver = new ResizeObserver(() => {
      if (this.updateLayoutRef.current) {
        this.updateLayoutRef.current();
      }
    });
    resizeObserver.observe(this.masonryContainer);
    this.register(() => resizeObserver.disconnect());
    const handleResize = () => {
      if (this.updateLayoutRef.current) {
        this.updateLayoutRef.current();
      }
    };
    window.addEventListener("resize", handleResize);
    this.register(() => window.removeEventListener("resize", handleResize));
  }
  renderCard(container, card, entry, index, settings) {
    this.cardRenderer.renderCard(container, card, entry, settings, this);
  }
  getSortMethod() {
    const sortConfigs = this.config.getSort();
    if (sortConfigs && sortConfigs.length > 0) {
      const firstSort = sortConfigs[0];
      const property = firstSort.property;
      const direction = firstSort.direction.toLowerCase();
      if (property.includes("ctime")) {
        const result = `ctime-${direction}`;
        return result;
      }
      if (property.includes("mtime")) {
        const result = `mtime-${direction}`;
        return result;
      }
    }
    return "mtime-desc";
  }
  async loadContentForEntries(entries, settings) {
    if (settings.showTextPreview) {
      const snippetEntries = entries.filter((entry) => !(entry.file.path in this.snippets)).map((entry) => {
        const file = this.app.vault.getAbstractFileByPath(entry.file.path);
        if (!(file instanceof import_obsidian9.TFile))
          return null;
        const descValue = getFirstBasesPropertyValue(
          this.app,
          entry,
          settings.descriptionProperty
        );
        return {
          path: entry.file.path,
          file,
          descriptionData: descValue == null ? void 0 : descValue.data
        };
      }).filter(
        (e) => e !== null
      );
      await loadSnippetsForEntries(
        snippetEntries,
        settings.fallbackToContent,
        settings.omitFirstLine,
        this.app,
        this.snippets
      );
    }
    if (settings.imageFormat !== "none") {
      const imageEntries = entries.filter((entry) => !(entry.file.path in this.images)).map((entry) => {
        const file = this.app.vault.getAbstractFileByPath(entry.file.path);
        if (!(file instanceof import_obsidian9.TFile))
          return null;
        const imagePropertyValues = getAllBasesImagePropertyValues(
          this.app,
          entry,
          settings.imageProperty
        );
        return {
          path: entry.file.path,
          file,
          imagePropertyValues
        };
      }).filter((e) => e !== null);
      await loadImagesForEntries(
        imageEntries,
        settings.fallbackToEmbeds,
        this.app,
        this.images,
        this.hasImageAvailable
      );
    }
  }
  setupInfiniteScroll(totalEntries) {
    if (this.scrollListener) {
      this.containerEl.removeEventListener("scroll", this.scrollListener);
      this.scrollListener = null;
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.displayedCount >= totalEntries) {
      return;
    }
    const checkAndLoad = (trigger) => {
      if (this.isLoading) {
        return;
      }
      const scrollTop = this.containerEl.scrollTop;
      const scrollHeight = this.containerEl.scrollHeight;
      const clientHeight = this.containerEl.clientHeight;
      const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);
      const isMobile = this.app.isMobile;
      const viewportMultiplier = isMobile ? 1 : 2;
      const threshold = clientHeight * viewportMultiplier;
      if (distanceFromBottom < threshold && this.displayedCount < totalEntries) {
        this.isLoading = true;
        const batchSize = Math.min(30, 70);
        this.displayedCount = Math.min(
          this.displayedCount + batchSize,
          totalEntries
        );
        this.onDataUpdated();
      }
    };
    this.scrollListener = () => {
      if (this.scrollThrottleTimeout !== null) {
        return;
      }
      checkAndLoad("scroll");
      this.scrollThrottleTimeout = window.setTimeout(() => {
        this.scrollThrottleTimeout = null;
      }, 100);
    };
    this.containerEl.addEventListener("scroll", this.scrollListener);
    if (this.masonryContainer) {
      this.resizeObserver = new ResizeObserver(() => {
        checkAndLoad("resize");
      });
      this.resizeObserver.observe(this.masonryContainer);
    }
    this.register(() => {
      if (this.scrollListener) {
        this.containerEl.removeEventListener("scroll", this.scrollListener);
      }
      if (this.scrollThrottleTimeout !== null) {
        window.clearTimeout(this.scrollThrottleTimeout);
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    });
  }
  onunload() {
    this.cardRenderer.cleanup();
  }
  focus() {
    this.containerEl.focus({ preventScroll: true });
  }
};
var masonryViewOptions = getMasonryViewOptions;

// src/settings-tab.ts
var import_obsidian11 = require("obsidian");
init_property();

// src/modals.ts
var import_obsidian10 = require("obsidian");
var ClearSettingsModal = class extends import_obsidian10.Modal {
  constructor(app, plugin, onConfirm) {
    super(app);
    this.plugin = plugin;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.setTitle("Caution");
    contentEl.createEl("p", {
      text: "This will reset all plugin settings to their default values. This action cannot be undone."
    });
    const buttonContainer = contentEl.createDiv({
      cls: "modal-button-container"
    });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const clearButton = buttonContainer.createEl("button", {
      text: "Clear settings"
    });
    clearButton.addClass("mod-warning");
    clearButton.onclick = async () => {
      this.close();
      await this.onConfirm();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings-tab.ts
var PropertySuggest = class extends import_obsidian11.AbstractInputSuggest {
  constructor(app, inputEl, properties) {
    super(app, inputEl);
    this.properties = properties;
    this.textInputEl = inputEl;
  }
  getSuggestions(query) {
    const lowerQuery = query.toLowerCase();
    return this.properties.filter(
      (prop) => prop.toLowerCase().includes(lowerQuery)
    );
  }
  renderSuggestion(value, el) {
    el.setText(value || "(None)");
  }
  selectSuggestion(value) {
    this.textInputEl.value = value;
    this.textInputEl.trigger("input");
    this.close();
  }
};
var DynamicViewsSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  /**
   * Trim whitespace from all text field settings
   */
  async trimTextFieldSettings() {
    const globalSettings = this.plugin.persistenceManager.getGlobalSettings();
    const defaultViewSettings = this.plugin.persistenceManager.getDefaultViewSettings();
    const trimmedGlobalSettings = {};
    let hasGlobalChanges = false;
    if (globalSettings.timestampFormat.trim() !== globalSettings.timestampFormat) {
      trimmedGlobalSettings.timestampFormat = globalSettings.timestampFormat.trim();
      hasGlobalChanges = true;
    }
    if (globalSettings.createdTimeProperty.trim() !== globalSettings.createdTimeProperty) {
      trimmedGlobalSettings.createdTimeProperty = globalSettings.createdTimeProperty.trim();
      hasGlobalChanges = true;
    }
    if (globalSettings.modifiedTimeProperty.trim() !== globalSettings.modifiedTimeProperty) {
      trimmedGlobalSettings.modifiedTimeProperty = globalSettings.modifiedTimeProperty.trim();
      hasGlobalChanges = true;
    }
    const trimmedDefaultViewSettings = {};
    let hasDefaultViewChanges = false;
    if (defaultViewSettings.titleProperty.trim() !== defaultViewSettings.titleProperty) {
      trimmedDefaultViewSettings.titleProperty = defaultViewSettings.titleProperty.trim();
      hasDefaultViewChanges = true;
    }
    if (defaultViewSettings.descriptionProperty.trim() !== defaultViewSettings.descriptionProperty) {
      trimmedDefaultViewSettings.descriptionProperty = defaultViewSettings.descriptionProperty.trim();
      hasDefaultViewChanges = true;
    }
    if (defaultViewSettings.imageProperty.trim() !== defaultViewSettings.imageProperty) {
      trimmedDefaultViewSettings.imageProperty = defaultViewSettings.imageProperty.trim();
      hasDefaultViewChanges = true;
    }
    if (hasGlobalChanges) {
      await this.plugin.persistenceManager.setGlobalSettings(
        trimmedGlobalSettings
      );
    }
    if (hasDefaultViewChanges) {
      await this.plugin.persistenceManager.setDefaultViewSettings(
        trimmedDefaultViewSettings
      );
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    void this.trimTextFieldSettings();
    const settings = this.plugin.persistenceManager.getGlobalSettings();
    new import_obsidian11.Setting(containerEl).setName("Open file action").setDesc("How files should open when clicked").addDropdown(
      (dropdown) => dropdown.addOption("card", "Press on title or card").addOption("title", "Press on title").setValue(settings.openFileAction).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          openFileAction: value
        });
        document.body.classList.remove(
          "dynamic-views-open-on-card",
          "dynamic-views-open-on-title"
        );
        document.body.classList.add(`dynamic-views-open-on-${value}`);
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Open random file in new pane").setDesc(
      "When opening a random file from Bases view, open it in a new pane instead of the same pane"
    ).addToggle(
      (toggle) => toggle.setValue(settings.openRandomInNewPane).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          openRandomInNewPane: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName('Show "Shuffle" in ribbon').setDesc(
      "Display the shuffle button in the left sidebar ribbon. Reload plugin or Obsidian to apply."
    ).addToggle(
      (toggle) => toggle.setValue(settings.showShuffleInRibbon).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          showShuffleInRibbon: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName('Show "Open random note" in ribbon').setDesc(
      "Display the random note button in the left sidebar ribbon. Reload plugin or Obsidian to apply."
    ).addToggle(
      (toggle) => toggle.setValue(settings.showRandomInRibbon).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          showRandomInRibbon: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Thumbnail cache size").setDesc("Size of cached thumbnails (affects performance and quality)").addDropdown(
      (dropdown) => dropdown.addOption("minimal", "Minimal").addOption("small", "Small").addOption("balanced", "Balanced").addOption("large", "Large").addOption("unlimited", "Unlimited").setValue(settings.thumbnailCacheSize).onChange(
        async (value) => {
          await this.plugin.persistenceManager.setGlobalSettings({
            thumbnailCacheSize: value
          });
        }
      )
    );
    new import_obsidian11.Setting(containerEl).setName("Omit first line in text preview").setDesc(
      "Always skip first line in text previews (in addition to automatic omission when first line matches title/filename)"
    ).addToggle(
      (toggle) => toggle.setValue(settings.omitFirstLine).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          omitFirstLine: value
        });
      })
    );
    const timestampFormatSetting = new import_obsidian11.Setting(containerEl).setName("Timestamp format").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD HH:mm").setValue(settings.timestampFormat).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          timestampFormat: value
        });
      })
    );
    const timestampFormatDesc = timestampFormatSetting.descEl;
    timestampFormatDesc.createEl("a", {
      text: "Moment.js",
      href: "https://momentjs.com/docs/#/displaying/format/"
    });
    timestampFormatDesc.appendText(" format for displaying date properties.");
    const smartTimestampSetting = new import_obsidian11.Setting(containerEl).setName("Smart timestamp").addToggle(
      (toggle) => toggle.setValue(settings.smartTimestamp).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          smartTimestamp: value
        });
        if (value) {
          conditionalText.show();
          smartTimestampSubSettings.show();
        } else {
          conditionalText.hide();
          smartTimestampSubSettings.hide();
        }
      })
    );
    const smartTimestampDesc = smartTimestampSetting.descEl;
    smartTimestampDesc.createSpan({
      text: "Automatically show the created or modified time when sorting by that property. "
    });
    const conditionalText = smartTimestampDesc.createSpan({
      text: "One of the properties below must be shown in one of the property fields below."
    });
    const smartTimestampSubSettings = containerEl.createDiv(
      "smart-timestamp-sub-settings"
    );
    let createdTimeValue = settings.createdTimeProperty;
    let modifiedTimeValue = settings.modifiedTimeProperty;
    let fallbackSetting;
    const updateFallbackVisibility = () => {
      const hasValue = createdTimeValue.trim() !== "" || modifiedTimeValue.trim() !== "";
      if (hasValue) {
        fallbackSetting.settingEl.show();
      } else {
        fallbackSetting.settingEl.hide();
      }
    };
    new import_obsidian11.Setting(smartTimestampSubSettings).setName("Created time property").setDesc("Leave blank to use file metadata.").addText(
      (text) => text.setPlaceholder("created").setValue(settings.createdTimeProperty).onChange(async (value) => {
        createdTimeValue = value;
        await this.plugin.persistenceManager.setGlobalSettings({
          createdTimeProperty: value
        });
        updateFallbackVisibility();
      })
    );
    new import_obsidian11.Setting(smartTimestampSubSettings).setName("Modified time property").setDesc("Leave blank to use file metadata.").addText(
      (text) => text.setPlaceholder("modified").setValue(settings.modifiedTimeProperty).onChange(async (value) => {
        modifiedTimeValue = value;
        await this.plugin.persistenceManager.setGlobalSettings({
          modifiedTimeProperty: value
        });
        updateFallbackVisibility();
      })
    );
    fallbackSetting = new import_obsidian11.Setting(smartTimestampSubSettings).setName("Fall back to file metadata").setDesc("Use file metadata if a property above is missing or empty.").addToggle(
      (toggle) => toggle.setValue(settings.fallbackToFileMetadata).onChange(async (value) => {
        await this.plugin.persistenceManager.setGlobalSettings({
          fallbackToFileMetadata: value
        });
      })
    );
    updateFallbackVisibility();
    if (settings.smartTimestamp) {
      conditionalText.show();
      smartTimestampSubSettings.show();
    } else {
      conditionalText.hide();
      smartTimestampSubSettings.hide();
    }
    const appearanceHeading = new import_obsidian11.Setting(containerEl).setName("Appearance").setHeading();
    appearanceHeading.settingEl.addClass("dynamic-views-appearance-heading");
    const appearanceDesc = containerEl.createEl("p", {
      cls: "setting-item-description"
    });
    appearanceDesc.appendText("Appearance settings can be configured in ");
    appearanceDesc.createEl("a", {
      text: "Style Settings",
      href: "obsidian://show-plugin?id=obsidian-style-settings"
    });
    appearanceDesc.appendText(".");
    const appearanceTip = containerEl.createEl("p", {
      cls: "setting-item-description"
    });
    appearanceTip.appendText("Tip: Run ");
    appearanceTip.createEl("em").appendText("Show style settings view");
    appearanceTip.appendText(" command to open settings in a tab.");
    new import_obsidian11.Setting(containerEl).setName("Default settings for new views").setHeading();
    const defaultViewSettings = this.plugin.persistenceManager.getDefaultViewSettings();
    const allProperties = getAllVaultProperties(this.app);
    new import_obsidian11.Setting(containerEl).setName("First property").setDesc("Property to show in first position").addSearch((search) => {
      search.setPlaceholder("Search properties").setValue(defaultViewSettings.propertyDisplay1).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          propertyDisplay1: value
        });
      });
      new PropertySuggest(this.app, search.inputEl, allProperties);
    });
    new import_obsidian11.Setting(containerEl).setName("Second property").setDesc("Property to show in second position").addSearch((search) => {
      search.setPlaceholder("Search properties").setValue(defaultViewSettings.propertyDisplay2).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          propertyDisplay2: value
        });
      });
      new PropertySuggest(this.app, search.inputEl, allProperties);
    });
    new import_obsidian11.Setting(containerEl).setName("Pair first and second properties").setDesc("Display first two properties horizontally").addToggle(
      (toggle) => toggle.setValue(defaultViewSettings.propertyLayout12SideBySide).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          propertyLayout12SideBySide: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Third property").setDesc("Property to show in third position").addSearch((search) => {
      search.setPlaceholder("Search properties").setValue(defaultViewSettings.propertyDisplay3).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          propertyDisplay3: value
        });
      });
      new PropertySuggest(this.app, search.inputEl, allProperties);
    });
    new import_obsidian11.Setting(containerEl).setName("Fourth property").setDesc("Property to show in fourth position").addSearch((search) => {
      search.setPlaceholder("Search properties").setValue(defaultViewSettings.propertyDisplay4).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          propertyDisplay4: value
        });
      });
      new PropertySuggest(this.app, search.inputEl, allProperties);
    });
    new import_obsidian11.Setting(containerEl).setName("Pair third and fourth properties").setDesc("Display third and fourth properties horizontally").addToggle(
      (toggle) => toggle.setValue(defaultViewSettings.propertyLayout34SideBySide).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          propertyLayout34SideBySide: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Title property").setDesc("Default property to show as file title").addText(
      (text) => text.setPlaceholder("Comma-separated if multiple").setValue(defaultViewSettings.titleProperty).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          titleProperty: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Show text preview").setDesc("Show text preview by default").addToggle(
      (toggle) => toggle.setValue(defaultViewSettings.showTextPreview).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          showTextPreview: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Text preview property").setDesc("Default property to show as text preview").addText(
      (text) => text.setPlaceholder("Comma-separated if multiple").setValue(defaultViewSettings.descriptionProperty).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          descriptionProperty: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Use note content if text preview property unavailable").setDesc(
      "Fall back to note content when text preview property is not set"
    ).addToggle(
      (toggle) => toggle.setValue(defaultViewSettings.fallbackToContent).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          fallbackToContent: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Image format").setDesc("Default image format for cards").addDropdown(
      (dropdown) => dropdown.addOption("thumbnail-left", "Thumbnail left").addOption("thumbnail-right", "Thumbnail right").addOption("cover-top", "Cover top").addOption("cover-bottom", "Cover bottom").addOption("cover-left", "Cover left").addOption("cover-right", "Cover right").addOption("none", "None").setValue(defaultViewSettings.imageFormat).onChange(
        async (value) => {
          await this.plugin.persistenceManager.setDefaultViewSettings({
            imageFormat: value
          });
        }
      )
    );
    new import_obsidian11.Setting(containerEl).setName("Cover fit mode").setDesc("Default fit mode for cover images").addDropdown(
      (dropdown) => dropdown.addOption("crop", "Crop").addOption("contain", "Contain").setValue(defaultViewSettings.coverFitMode).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          coverFitMode: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Image property").setDesc("Default property to use for card images").addText(
      (text) => text.setPlaceholder("Comma-separated if multiple").setValue(defaultViewSettings.imageProperty).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          imageProperty: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Show image embeds").setDesc(
      "Control when in-note image embeds are shown alongside image property values"
    ).addDropdown(
      (dropdown) => dropdown.addOption("always", "Always").addOption("if-empty", "If property missing or empty").addOption("never", "Never").setValue(defaultViewSettings.fallbackToEmbeds).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          fallbackToEmbeds: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("List marker").setDesc("Default marker style for list view").addDropdown(
      (dropdown) => dropdown.addOption("bullet", "Bullet").addOption("number", "Number").addOption("none", "None").setValue(defaultViewSettings.listMarker).onChange(async (value) => {
        await this.plugin.persistenceManager.setDefaultViewSettings({
          listMarker: value
        });
      })
    );
    new import_obsidian11.Setting(containerEl).setName("View height").setDesc(
      "Default maximum height of results area in pixels. Set to 0 for unlimited."
    ).addText(
      (text) => text.setPlaceholder("500").setValue(String(defaultViewSettings.queryHeight)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          await this.plugin.persistenceManager.setDefaultViewSettings({
            queryHeight: num
          });
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Configuration").setHeading();
    new import_obsidian11.Setting(containerEl).setName("Manage settings").setDesc("Back up plugin settings to a file or restore from backup.").addButton(
      (button) => button.setButtonText("Import").onClick(() => {
        const input = document.createElement("input");
        input.setAttrs({
          type: "file",
          accept: ".json"
        });
        input.onchange = () => {
          var _a;
          const selectedFile = (_a = input.files) == null ? void 0 : _a[0];
          if (selectedFile) {
            const reader = new FileReader();
            reader.readAsText(selectedFile, "UTF-8");
            reader.onload = async (readerEvent) => {
              var _a2;
              let importedJson;
              const content = (_a2 = readerEvent.target) == null ? void 0 : _a2.result;
              if (typeof content === "string") {
                try {
                  importedJson = JSON.parse(content);
                } catch (e) {
                  new import_obsidian11.Notice("Invalid import file");
                  console.error("Invalid import file");
                  return;
                }
              }
              if (importedJson) {
                const newGlobalSettings = Object.assign(
                  {},
                  DEFAULT_SETTINGS
                );
                const newDefaultViewSettings = Object.assign({}, DEFAULT_VIEW_SETTINGS);
                if (importedJson.globalSettings) {
                  for (const setting in importedJson.globalSettings) {
                    if (setting in newGlobalSettings) {
                      newGlobalSettings[setting] = importedJson.globalSettings[setting];
                    }
                  }
                }
                if (importedJson.defaultViewSettings) {
                  for (const setting in importedJson.defaultViewSettings) {
                    if (setting in newDefaultViewSettings) {
                      newDefaultViewSettings[setting] = importedJson.defaultViewSettings[setting];
                    }
                  }
                }
                await this.plugin.persistenceManager.setGlobalSettings(
                  newGlobalSettings
                );
                await this.plugin.persistenceManager.setDefaultViewSettings(
                  newDefaultViewSettings
                );
                new import_obsidian11.Notice("Settings imported");
                this.display();
              }
              input.remove();
            };
          }
        };
        input.click();
      })
    ).addButton(
      (button) => button.setButtonText("Export").onClick(async () => {
        const globalSettings = this.plugin.persistenceManager.getGlobalSettings();
        const defaultViewSettings2 = this.plugin.persistenceManager.getDefaultViewSettings();
        const settingsText = JSON.stringify(
          {
            globalSettings,
            defaultViewSettings: defaultViewSettings2
          },
          null,
          2
        );
        const fileName = "dynamic-views-settings.json";
        if (navigator.share && navigator.canShare) {
          try {
            const blob = new Blob([settingsText], {
              type: "application/json"
            });
            const file = new File([blob], fileName, {
              type: "application/json"
            });
            if (navigator.canShare({ files: [file] })) {
              await navigator.share({
                files: [file],
                title: "Dynamic Views Settings"
              });
              return;
            }
          } catch (error) {
            console.error("Share failed:", error);
          }
        }
        const exportLink = document.createElement("a");
        exportLink.setAttrs({
          download: fileName,
          href: `data:application/json;charset=utf-8,${encodeURIComponent(settingsText)}`
        });
        exportLink.click();
        exportLink.remove();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Clear settings").setDesc("Reset all plugin settings to their default values.").addButton((button) => {
      button.setButtonText("Clear").setWarning().onClick(() => {
        new ClearSettingsModal(this.app, this.plugin, async () => {
          const newGlobalSettings = JSON.parse(
            JSON.stringify(DEFAULT_SETTINGS)
          );
          const newDefaultViewSettings = JSON.parse(
            JSON.stringify(DEFAULT_VIEW_SETTINGS)
          );
          await this.plugin.persistenceManager.setGlobalSettings(
            newGlobalSettings
          );
          await this.plugin.persistenceManager.setDefaultViewSettings(
            newDefaultViewSettings
          );
          new import_obsidian11.Notice("Settings cleared");
          this.display();
        }).open();
      });
    });
  }
  hide() {
    void this.trimTextFieldSettings();
  }
};

// src/utils/randomize.ts
var import_obsidian12 = require("obsidian");
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
function getActiveBasesView(app) {
  var _a, _b, _c, _d;
  const activeLeaf = app.workspace.activeLeaf;
  if (!activeLeaf)
    return null;
  const view = activeLeaf.view;
  const viewType = view.getViewType();
  if (viewType === "bases" || viewType === "base-view") {
    const wrapper = view;
    if (((_c = (_b = (_a = wrapper.controller) == null ? void 0 : _a.view) == null ? void 0 : _b.data) == null ? void 0 : _c.data) && Array.isArray(wrapper.controller.view.data.data)) {
      const viewInstanceType = wrapper.controller.view.type || "unknown";
      if (viewInstanceType === "dynamic-views-grid" || viewInstanceType === "dynamic-views-masonry") {
        return wrapper.controller.view;
      }
      return {
        type: viewInstanceType,
        data: wrapper.controller.view.data,
        onDataUpdated: (_d = wrapper.controller.view.onDataUpdated) == null ? void 0 : _d.bind(
          wrapper.controller.view
        ),
        isShuffled: wrapper.controller.view.isShuffled,
        shuffledOrder: wrapper.controller.view.shuffledOrder
      };
    }
    if (wrapper.basesView) {
      return wrapper.basesView;
    }
  }
  return null;
}
async function openRandomFile(app, openInNewPane) {
  var _a;
  const basesView = getActiveBasesView(app);
  if (!basesView) {
    new import_obsidian12.Notice("No active Bases view");
    return;
  }
  const entries = (_a = basesView.data) == null ? void 0 : _a.data;
  if (!entries || entries.length === 0) {
    return;
  }
  const randomIndex = Math.floor(Math.random() * entries.length);
  const randomEntry = entries[randomIndex];
  if (!randomEntry.file) {
    return;
  }
  const filePath = randomEntry.file.path;
  await app.workspace.openLinkText(filePath, "", openInNewPane);
}
function toggleShuffleActiveView(app) {
  var _a, _b, _c;
  const basesView = getActiveBasesView(app);
  if (!basesView) {
    new import_obsidian12.Notice("No active Bases view");
    return;
  }
  const isDynamicView = basesView.type === "dynamic-views-grid" || basesView.type === "dynamic-views-masonry";
  if (isDynamicView) {
    const dynamicView = basesView;
    const currentState = (_a = dynamicView.isShuffled) != null ? _a : false;
    console.log(
      "// [Shuffle Debug] toggleShuffle - current state:",
      currentState
    );
    console.log("// [Shuffle Debug] basesView type:", basesView.type);
    dynamicView.isShuffled = !currentState;
    if (dynamicView.isShuffled) {
      const entries = (_b = basesView.data) == null ? void 0 : _b.data;
      console.log(
        "// [Shuffle Debug] Enabling shuffle, entries.length:",
        entries == null ? void 0 : entries.length
      );
      if (entries && entries.length > 0) {
        const paths = entries.map((e) => e.file.path);
        dynamicView.shuffledOrder = shuffleArray([...paths]);
        console.log(
          "// [Shuffle Debug] Created shuffledOrder.length:",
          dynamicView.shuffledOrder.length
        );
        console.log(
          "// [Shuffle Debug] First 3 shuffled paths:",
          dynamicView.shuffledOrder.slice(0, 3)
        );
      }
    } else {
      console.log(
        "// [Shuffle Debug] Disabling shuffle, clearing shuffledOrder"
      );
      dynamicView.shuffledOrder = [];
    }
    if (dynamicView.onDataUpdated) {
      console.log("// [Shuffle Debug] Triggering onDataUpdated");
      dynamicView.onDataUpdated();
    }
  } else {
    const entries = (_c = basesView.data) == null ? void 0 : _c.data;
    if (entries && entries.length > 0) {
      shuffleArray(entries);
      if (basesView.onDataUpdated) {
        basesView.onDataUpdated();
      }
    }
  }
}

// main.ts
var DynamicViewsPlugin = class extends import_obsidian13.Plugin {
  /**
   * Extract alpha from --background-modifier-cover and set as CSS custom property
   */
  syncOverlayOpacity() {
    const computedStyle = getComputedStyle(document.body);
    const coverBg = computedStyle.getPropertyValue(
      "--background-modifier-cover"
    );
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = 1;
    const ctx = canvas.getContext("2d");
    if (!ctx)
      return;
    ctx.fillStyle = coverBg;
    ctx.fillRect(0, 0, 1, 1);
    const [, , , a] = ctx.getImageData(0, 0, 1, 1).data;
    const alphaPercent = Math.round(a / 255 * 100);
    document.body.style.setProperty(
      "--dynamic-views-overlay-opacity",
      `${alphaPercent}%`
    );
  }
  // Helper function for datacorejsx blocks
  createView(dc, userQuery) {
    setDatacorePreact(dc.preact);
    return () => {
      return View({
        plugin: this,
        app: this.app,
        dc,
        USER_QUERY: userQuery || "@page"
      });
    };
  }
  async onload() {
    this.persistenceManager = new PersistenceManager(this);
    await this.persistenceManager.load();
    const settings = this.persistenceManager.getGlobalSettings();
    document.body.classList.add(
      `dynamic-views-open-on-${settings.openFileAction}`
    );
    setPluginInstance(this);
    this.addSettingTab(new DynamicViewsSettingTab(this.app, this));
    this.registerBasesView("dynamic-views-grid", {
      name: "Grid",
      icon: "lucide-grid-2x-2",
      factory: (controller, scrollEl) => new DynamicViewsCardView(controller, scrollEl),
      options: cardViewOptions
    });
    this.registerBasesView("dynamic-views-masonry", {
      name: "Masonry",
      icon: "panels-right-bottom",
      factory: (controller, scrollEl) => new DynamicViewsMasonryView(controller, scrollEl),
      options: masonryViewOptions
    });
    this.app.workspace.trigger("parse-style-settings");
    if (document.body.classList.contains("dynamic-views-image-zoom-enabled")) {
      this.syncOverlayOpacity();
    }
    this.registerEvent(
      this.app.workspace.on("css-change", () => {
        if (document.body.classList.contains("dynamic-views-image-zoom-enabled")) {
          this.syncOverlayOpacity();
        }
      })
    );
    this.addCommand({
      id: "create-dynamic-view",
      name: "Create note with query",
      callback: async () => {
        await this.createExplorerFile();
      }
    });
    this.addCommand({
      id: "insert-dynamic-view-at-cursor",
      name: "Insert query at cursor position",
      editorCheckCallback: (checking, editor, view) => {
        const cursor = editor.getCursor();
        const lineContent = editor.getLine(cursor.line);
        const isEmptyLine = lineContent.trim().length === 0;
        if (isEmptyLine) {
          if (!checking) {
            const template = this.getQueryTemplate();
            editor.replaceRange(template, cursor);
          }
          return true;
        }
        return false;
      }
    });
    if (settings.showRandomInRibbon) {
      const _randomRibbon = this.addRibbonIcon(
        "dices",
        "Open random file from Bases view",
        async (evt) => {
          document.querySelectorAll(".image-embed.is-zoomed").forEach((el) => {
            el.classList.remove("is-zoomed");
          });
          const defaultOpenInNewPane = this.persistenceManager.getGlobalSettings().openRandomInNewPane;
          const openInNewPane = import_obsidian13.Keymap.isModEvent(evt) ? !defaultOpenInNewPane : defaultOpenInNewPane;
          await openRandomFile(this.app, openInNewPane);
        }
      );
    }
    if (settings.showShuffleInRibbon) {
      this.addRibbonIcon("shuffle", "Shuffle Bases view", () => {
        document.querySelectorAll(".image-embed.is-zoomed").forEach((el) => {
          el.classList.remove("is-zoomed");
        });
        toggleShuffleActiveView(this.app);
      });
    }
    this.addCommand({
      id: "random-file-from-bases",
      name: "Open random file from Bases view",
      callback: async () => {
        document.querySelectorAll(".image-embed.is-zoomed").forEach((el) => {
          el.classList.remove("is-zoomed");
        });
        const openInNewPane = this.persistenceManager.getGlobalSettings().openRandomInNewPane;
        await openRandomFile(this.app, openInNewPane);
      }
    });
    this.addCommand({
      id: "shuffle-bases-view",
      name: "Shuffle Bases view",
      callback: () => {
        document.querySelectorAll(".image-embed.is-zoomed").forEach((el) => {
          el.classList.remove("is-zoomed");
        });
        toggleShuffleActiveView(this.app);
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-drop", (evt, editor, view) => {
        var _a, _b;
        const data = (_a = evt.dataTransfer) == null ? void 0 : _a.getData("text/plain");
        if (data && data.startsWith("obsidian://open?vault=")) {
          const url = new URL(data);
          const filePath = url.searchParams.get("file");
          if (filePath) {
            const decodedPath = decodeURIComponent(filePath);
            const file = this.app.vault.getAbstractFileByPath(
              decodedPath + ".md"
            );
            if (file instanceof import_obsidian13.TFile) {
              const sourcePath = ((_b = view.file) == null ? void 0 : _b.path) || "";
              const link = this.app.fileManager.generateMarkdownLink(
                file,
                sourcePath
              );
              editor.replaceSelection(link);
              evt.preventDefault();
            }
          }
        }
      })
    );
  }
  getQueryTemplate() {
    return `\`\`\`datacorejsx
const USER_QUERY = \`
// \u2013\u2013\u2013\u2013\u2013 DQL QUERY START \u2013\u2013\u2013\u2013\u2013

// \u2013\u2013\u2013\u2013\u2013 DQL QUERY END \u2013\u2013\u2013\u2013\u2013
\`;

const dv = app.plugins.plugins['dynamic-views'];
return dv.createView(dc, USER_QUERY);
\`\`\`
`;
  }
  async createExplorerFile() {
    var _a, _b;
    try {
      const activeFile = this.app.workspace.getActiveFile();
      const folderPath = (_b = (_a = activeFile == null ? void 0 : activeFile.parent) == null ? void 0 : _a.path) != null ? _b : this.app.fileManager.getNewFileParent("").path;
      const filePath = getAvailablePath(this.app, folderPath, "Dynamic view");
      const template = this.getQueryTemplate();
      await this.app.vault.create(filePath, template);
      const file = this.app.vault.getFileByPath(filePath);
      if (file) {
        const leaf = this.app.workspace.getLeaf("tab");
        await leaf.openFile(file);
        const view = leaf.view;
        if (view instanceof import_obsidian13.MarkdownView) {
          const viewState = view.getState();
          viewState.mode = "preview";
          await view.setState(viewState, { history: false });
        }
      }
    } catch (error) {
      new import_obsidian13.Notice(`Failed to create file. Check console for details.`);
      console.error("File creation failed:", error);
    }
  }
  onunload() {
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
